{"mode":"editor","version":1,"windowDimensions":{"x":0,"y":22,"width":1440,"height":874},"syntax":{"deserializer":"Syntax","grammarOverridesByPath":{}},"project":{"path":"/Users/zk/napplelabs/cider","buffers":[{"text":";;; cider-interaction.el --- IDE for Clojure -*- lexical-binding: t -*-\n\n;; Copyright © 2012-2014 Tim King, Phil Hagelberg\n;; Copyright © 2013-2014 Bozhidar Batsov, Hugo Duncan, Steve Purcell\n;;\n;; Author: Tim King <kingtim@gmail.com>\n;;         Phil Hagelberg <technomancy@gmail.com>\n;;         Bozhidar Batsov <bozhidar@batsov.com>\n;;         Hugo Duncan <hugo@hugoduncan.org>\n;;         Steve Purcell <steve@sanityinc.com>\n\n;; This program is free software: you can redistribute it and/or modify\n;; it under the terms of the GNU General Public License as published by\n;; the Free Software Foundation, either version 3 of the License, or\n;; (at your option) any later version.\n\n;; This program is distributed in the hope that it will be useful,\n;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n;; GNU General Public License for more details.\n\n;; You should have received a copy of the GNU General Public License\n;; along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n;; This file is not part of GNU Emacs.\n\n;;; Commentary:\n\n;; Provides an Emacs Lisp client to connect to Clojure nREPL servers.\n\n;;; Code:\n\n(require 'cider-client)\n(require 'cider-util)\n(require 'cider-stacktrace)\n(require 'cider-test)\n(require 'cider-doc)\n\n(require 'clojure-mode)\n(require 'dash)\n(require 'thingatpt)\n(require 'etags)\n(require 'arc-mode)\n(require 'ansi-color)\n(require 'cl-lib)\n(require 'compile)\n(require 'tramp)\n(require 'button)\n\n(defconst cider-error-buffer \"*cider-error*\")\n(defconst cider-doc-buffer \"*cider-doc*\")\n(defconst cider-result-buffer \"*cider-result*\")\n\n(define-obsolete-variable-alias 'cider-use-local-resources\n  'cider-prefer-local-resources \"0.7.0\")\n\n(defcustom cider-prefer-local-resources nil\n  \"Prefer local resources to remote (tramp) ones when both are available.\"\n  :type 'boolean\n  :group 'cider)\n\n(defcustom cider-show-error-buffer t\n  \"Control the popup behavior of cider stacktraces.\nThe following values are possible t or 'always, 'except-in-repl,\n'only-in-repl. Any other value, including nil, will cause the stacktrace\nnot to be automatically shown.\n\nIrespective of the value of this variable, the `cider-error-buffer' is\nalways generated in the background. Use `cider-visit-error-buffer' to\nnavigate to this buffer.\"\n  :type '(choice (const :tag \"always\" t)\n                 (const except-in-repl)\n                 (const only-in-repl)\n                 (const :tag \"never\" nil))\n  :group 'cider)\n\n(define-obsolete-variable-alias 'cider-popup-stacktraces\n  'cider-show-error-buffer \"0.7.0\")\n\n(defcustom cider-auto-select-error-buffer t\n  \"Controls whether to auto-select the error popup buffer.\"\n  :type 'boolean\n  :group 'cider)\n\n(defcustom cider-interactive-eval-result-prefix \"=> \"\n  \"The prefix displayed in the minibuffer before a result value.\"\n  :type 'string\n  :group 'cider\n  :package-version '(cider . \"0.5.0\"))\n\n(defcustom cider-switch-to-repl-command 'cider-switch-to-relevant-repl-buffer\n  \"Select the command to be invoked when switching-to-repl.\nThe default option is `cider-switch-to-relevant-repl-buffer'.  If\nyou'd like to not use smart matching of repl buffer based on\nproject directory, you can assign it to `cider-switch-to-current-repl-buffer'\nwhich will use the default REPL connection.\"\n  :type 'symbol\n  :group 'cider)\n\n(defcustom cider-prompt-save-file-on-load t\n  \"Controls whether to prompt to save the file when loading a buffer.\"\n  :type 'boolean\n  :group 'cider\n  :package-version '(cider . \"0.6.0\"))\n\n(defcustom cider-completion-use-context t\n  \"When true, uses context at point to improve completion suggestions.\"\n  :type 'boolean\n  :group 'cider\n  :package-version '(cider . \"0.7.0\"))\n\n(defconst cider-output-buffer \"*cider-out*\")\n\n(defcustom cider-interactive-eval-output-destination 'repl-buffer\n  \"The destination for stdout and stderr produced from interactive evaluation.\"\n  :type '(choice (const output-buffer)\n                 (const repl-buffer))\n  :group 'cider\n  :package-version '(cider . \"0.7.0\"))\n\n(defface cider-error-highlight-face\n  '((((supports :underline (:style wave)))\n     (:underline (:style wave :color \"red\") :inherit unspecified))\n    (t (:inherit font-lock-warning-face :underline t)))\n  \"Face used to highlight compilation errors in Clojure buffers.\"\n  :group 'cider)\n\n(defface cider-warning-highlight-face\n  '((((supports :underline (:style wave)))\n     (:underline (:style wave :color \"yellow\") :inherit unspecified))\n    (t (:inherit font-lock-warning-face :underline (:color \"yellow\"))))\n  \"Face used to highlight compilation warnings in Clojure buffers.\"\n  :group 'cider)\n\n(defvar cider-required-nrepl-ops\n  '(\"classpath\" \"complete\" \"info\"\n    \"inspect-start\" \"inspect-refresh\"\n    \"inspect-pop\" \"inspect-push\" \"inspect-reset\"\n    \"macroexpand\" \"macroexpand-1\" \"macroexpand-all\"\n    \"resource\" \"stacktrace\" \"toggle-trace\")\n  \"A list of nREPL ops required by CIDER to function properly.\n\nAll of them are provided by CIDER's nREPL middleware(cider-nrepl).\")\n\n(defun cider-ensure-op-supported (op)\n  \"Check for support of middleware op OP.\nSignal an error if it is not supported.\"\n  (unless (nrepl-op-supported-p op)\n    (error \"Can't find nREPL middleware providing op \\\"%s\\\".  Please, install (or update) cider-nrepl %s and restart CIDER\" op cider-version)))\n\n(defun cider-verify-required-nrepl-ops ()\n  \"Check whether all required nREPL ops are present.\"\n  (let ((missing-ops (-remove 'nrepl-op-supported-p cider-required-nrepl-ops)))\n    (when missing-ops\n      (cider-repl-emit-interactive-output\n       (format \"WARNING: The following required nREPL ops are not supported: \\n%s\\nPlease, install (or update) cider-nrepl %s and restart CIDER\"\n               (cider-string-join missing-ops \" \")\n               cider-version)))))\n\n;;; Connection info\n(defun cider--java-version ()\n  \"Retrieve the underlying connection's Java version.\"\n  (cider-eval-and-get-value \"(System/getProperty \\\"java.version\\\")\"))\n\n(defun cider--clojure-version ()\n  \"Retrieve the underlying connection's Clojure version.\"\n  (cider-eval-and-get-value \"(clojure-version)\"))\n\n(defun cider--nrepl-version ()\n  \"Retrieve the underlying connection's nREPL version.\"\n  (cider-eval-and-get-value \"(:version-string clojure.tools.nrepl/version)\"))\n\n(defun cider--nrepl-middleware-version ()\n  \"Retrieve the underlying connection's CIDER nREPL version.\"\n  (cider-eval-and-get-value \"(try (require 'cider.nrepl)\n                                  (:version-string @(resolve 'cider.nrepl/version))\n                               (catch Throwable _ \\\"not installed\\\"))\"))\n\n(defun cider--connection-info (connection-buffer)\n  \"Return info about CONNECTION-BUFFER.\n\nInfo contains project name, current REPL namespace, host:port\nendpoint and Clojure version.\"\n  (with-current-buffer (get-buffer connection-buffer)\n    (format \"Active nREPL connection: %s:%s, %s:%s (Java %s, Clojure %s, nREPL %s, cider-nrepl %s)\"\n            (or (nrepl--project-name nrepl-project-dir) \"<no project>\")\n            nrepl-buffer-ns\n            (car nrepl-endpoint)\n            (cadr nrepl-endpoint)\n            (cider--java-version)\n            (cider--clojure-version)\n            (cider--nrepl-version)\n            (cider--nrepl-middleware-version))))\n\n(defun cider-display-current-connection-info ()\n  \"Display information about the current connection.\"\n  (interactive)\n  (message (cider--connection-info (nrepl-current-connection-buffer))))\n\n(defun cider-rotate-connection ()\n  \"Rotate and display the current nREPL connection.\"\n  (interactive)\n  (cider-ensure-connected)\n  (setq nrepl-connection-list\n        (append (cdr nrepl-connection-list)\n                (list (car nrepl-connection-list))))\n  (message (cider--connection-info (car nrepl-connection-list))))\n\n(defun cider-extract-designation-from-current-repl-buffer ()\n  \"Extract the designation from the cider repl buffer name.\"\n  (let ((repl-buffer-name (cider-current-repl-buffer))\n        (template (split-string nrepl-repl-buffer-name-template \"%s\")))\n    (string-match (format \"^%s\\\\(.*\\\\)%s\"\n                          (regexp-quote (concat (car template) nrepl-buffer-name-separator))\n                          (regexp-quote (cadr template)))\n                  repl-buffer-name)\n    (or (match-string 1 repl-buffer-name) \"<no designation>\")))\n\n(defun cider-change-buffers-designation ()\n  \"Changes the designation in cider buffer names.\nBuffer names changed are cider-repl, nrepl-connection and nrepl-server.\"\n  (interactive)\n  (cider-ensure-connected)\n  (let* ((designation (read-string (format \"Change CIDER buffer designation from '%s': \"\n                                           (cider-extract-designation-from-current-repl-buffer))))\n         (new-repl-buffer-name (nrepl-format-buffer-name-template\n                                nrepl-repl-buffer-name-template designation)))\n    (with-current-buffer (cider-current-repl-buffer)\n      (rename-buffer new-repl-buffer-name))\n    (with-current-buffer (nrepl-current-connection-buffer)\n      (setq-local nrepl-repl-buffer new-repl-buffer-name)\n      (let ((new-connection-buffer-name (nrepl-format-buffer-name-template\n                                         nrepl-connection-buffer-name-template designation)))\n        (rename-buffer new-connection-buffer-name)\n        (setq nrepl-connection-list\n              (cons new-connection-buffer-name (cdr nrepl-connection-list)))\n        (with-current-buffer (cider-current-repl-buffer)\n          (setq-local nrepl-connection-buffer new-connection-buffer-name))\n        (when nrepl-server-buffer\n          (let ((new-server-buffer-name (nrepl-format-buffer-name-template\n                                         nrepl-server-buffer-name-template designation)))\n            (with-current-buffer nrepl-server-buffer\n              (rename-buffer new-server-buffer-name))\n            (setq-local nrepl-server-buffer new-server-buffer-name)))))\n    (message \"CIDER buffer designation changed to: %s\" designation)))\n\n;;; Switching between REPL & source buffers\n(defvar-local cider-last-clojure-buffer nil\n  \"A buffer-local variable holding the last Clojure source buffer.\n`cider-switch-to-last-clojure-buffer' uses this variable to jump\nback to last Clojure source buffer.\")\n\n(defvar cider-current-clojure-buffer nil\n  \"This variable holds current buffer temporarily when connecting to a REPL.\nIt is set to current buffer when `cider' or `cider-jack-in' is called.\nAfter the REPL buffer is created, the value of this variable is used\nto call `cider-remember-clojure-buffer'.\")\n\n(defun cider-remember-clojure-buffer (buffer)\n  \"Try to remember the BUFFER from which the user jumps.\nThe BUFFER needs to be a Clojure buffer and current major mode needs\nto be `cider-repl-mode'.  The user can use `cider-switch-to-last-clojure-buffer'\nto jump back to the last Clojure source buffer.\"\n  (when (and buffer\n             (with-current-buffer buffer\n               (derived-mode-p 'clojure-mode))\n             (derived-mode-p 'cider-repl-mode))\n    (setq cider-last-clojure-buffer buffer)))\n\n(defun cider-switch-to-repl-buffer (&optional arg)\n  \"Invoke `cider-switch-to-repl-command'.\"\n  (interactive \"p\")\n  (funcall cider-switch-to-repl-command arg))\n\n(defun cider-switch-to-current-repl-buffer (&optional arg)\n  \"Select the REPL buffer, when possible in an existing window.\n\nHint: You can use `display-buffer-reuse-frames' and\n`special-display-buffer-names' to customize the frame in which\nthe buffer should appear.\n\nWith a prefix ARG sets the namespace in the REPL buffer to that\nof the namespace in the Clojure source buffer.\"\n  (interactive \"p\")\n  (cider-ensure-connected)\n  (let ((buffer (current-buffer)))\n    (when (eq 4 arg)\n      (cider-repl-set-ns (cider-current-ns)))\n    (pop-to-buffer (cider-find-or-create-repl-buffer))\n    (cider-remember-clojure-buffer buffer)\n    (goto-char (point-max))))\n\n(defun cider-find-connection-buffer-for-project-directory (project-directory)\n  \"Find the relevant connection-buffer for the given PROJECT-DIRECTORY.\n\nA check is made to ensure that all connection buffers have a project-directory\notherwise there is ambiguity as to which connection buffer should be selected.\n\nIf there are multiple connection buffers matching PROJECT-DIRECTORY there\nis ambiguity, therefore nil is returned.\"\n  (unless (-filter\n           (lambda (conn)\n             (not\n              (with-current-buffer (get-buffer conn)\n                nrepl-project-dir)))\n           nrepl-connection-list)\n    (let ((matching-connections\n           (-filter\n            (lambda (conn)\n              (let ((conn-proj-dir (with-current-buffer (get-buffer conn)\n                                     nrepl-project-dir)))\n                (when conn-proj-dir\n                  (equal (file-truename project-directory)\n                         (file-truename conn-proj-dir)))))\n            nrepl-connection-list)))\n      (when (= 1 (length matching-connections))\n        (car matching-connections)))))\n\n(defun cider-switch-to-relevant-repl-buffer (&optional arg)\n  \"Select the REPL buffer, when possible in an existing window.\nThe buffer chosen is based on the file open in the current buffer.\n\nIf the REPL buffer cannot be unambiguously determined, the REPL\nbuffer is chosen based on the current connection buffer and a\nmessage raised informing the user.\n\nHint: You can use `display-buffer-reuse-frames' and\n`special-display-buffer-names' to customize the frame in which\nthe buffer should appear.\n\nWith a prefix ARG sets the namespace in the REPL buffer to that\nof the namespace in the Clojure source buffer.\n\nWith a second prefix ARG the chosen REPL buffer is based on a\nsupplied project directory.\"\n  (interactive \"p\")\n  (cider-ensure-connected)\n  (let* ((project-directory\n          (or (when (eq 16 arg) (read-directory-name \"Project: \"))\n              (nrepl-project-directory-for (nrepl-current-dir))))\n         (connection-buffer\n          (or\n           (and (= 1 (length nrepl-connection-list)) (car nrepl-connection-list))\n           (and project-directory\n                (cider-find-connection-buffer-for-project-directory project-directory)))))\n    (when connection-buffer\n      (setq nrepl-connection-list\n            (cons connection-buffer (delq connection-buffer nrepl-connection-list))))\n    (cider-switch-to-current-repl-buffer arg)\n    (message\n     (format (if connection-buffer\n                 \"Switched to REPL: %s\"\n               \"Could not determine relevant nREPL connection, using: %s\")\n             (with-current-buffer (nrepl-current-connection-buffer)\n               (format \"%s:%s, %s:%s\"\n                       (or (nrepl--project-name nrepl-project-dir) \"<no project>\")\n                       nrepl-buffer-ns\n                       (car nrepl-endpoint)\n                       (cadr nrepl-endpoint)))))))\n\n(defun cider-switch-to-last-clojure-buffer ()\n  \"Switch to the last Clojure buffer.\nThe default keybinding for this command is\nthe same as `cider-switch-to-repl-buffer',\nso that it is very convenient to jump between a\nClojure buffer and the REPL buffer.\"\n  (interactive)\n  (if (and (derived-mode-p 'cider-repl-mode)\n           (buffer-live-p cider-last-clojure-buffer))\n      (pop-to-buffer cider-last-clojure-buffer)\n    (message \"Don't know the original Clojure buffer\")))\n\n(defun cider-find-and-clear-repl-buffer ()\n  \"Find the current REPL buffer and clear it.\nReturns to the buffer in which the command was invoked.\"\n  (interactive)\n  (let ((origin-buffer (current-buffer)))\n    (switch-to-buffer (cider-current-repl-buffer))\n    (cider-repl-clear-buffer)\n    (switch-to-buffer origin-buffer)))\n\n;;; Minibuffer eval\n(defvar cider-minibuffer-history '()\n  \"History list of expressions read from the minibuffer.\")\n\n(defvar cider-minibuffer-map\n  (let ((map (make-sparse-keymap)))\n    (set-keymap-parent map minibuffer-local-map)\n    (define-key map \"TAB\" 'complete-symbol)\n    (define-key map \"M-TAB\" 'complete-symbol)\n    map)\n  \"Minibuffer keymap used for reading Clojure expressions.\")\n\n(defun cider-read-from-minibuffer (prompt &optional initial-value)\n  \"Read a string from the minibuffer, prompting with PROMPT.\nIf INITIAL-VALUE is non-nil, it is inserted into the minibuffer before\nreading input.\"\n  (minibuffer-with-setup-hook\n      (lambda ()\n        (add-hook 'completion-at-point-functions\n                  #'cider-complete-at-point nil t)\n        (run-hooks 'eval-expression-minibuffer-setup-hook))\n    (read-from-minibuffer prompt initial-value\n                          cider-minibuffer-map nil\n                          cider-minibuffer-history)))\n\n(defun cider-read-and-eval ()\n  \"Read a sexp from the minibuffer and output its result to the echo area.\"\n  (interactive)\n  (cider-interactive-eval (cider-read-from-minibuffer \"CIDER Eval: \")))\n\n;;; Eval\n(defun cider-eval-region (start end)\n  \"Evaluate the region.\nThe two arguments START and END are character positions;\nthey can be in either order.\"\n  (interactive \"r\")\n  (cider-interactive-eval (buffer-substring-no-properties start end)))\n\n(defun cider-eval-buffer ()\n  \"Evaluate the current buffer.\"\n  (interactive)\n  (cider-eval-region (point-min) (point-max)))\n\n(defun cider-defun-at-point ()\n  \"Return the text of the top-level sexp at point.\"\n  (apply #'buffer-substring-no-properties\n         (cider--region-for-defun-at-point)))\n\n(defun cider--region-for-defun-at-point ()\n  \"Return the start and end position of defun at point.\"\n  (save-excursion\n    (save-match-data\n      (end-of-defun)\n      (let ((end (point)))\n        (beginning-of-defun)\n        (list (point) end)))))\n\n(defun cider-eval-defun-at-point (&optional prefix)\n  \"Evaluate the current toplevel form, and print result in the minibuffer.\nWith a PREFIX argument, print the result in the current buffer.\"\n  (interactive \"P\")\n  (let ((form (cider-defun-at-point)))\n    (if prefix\n        (cider-interactive-eval-print form)\n      (cider-interactive-eval form))))\n\n(defun cider-ns-form ()\n  \"Retrieve the ns form.\"\n  (when (clojure-find-ns)\n    (save-excursion\n      (goto-char (match-beginning 0))\n      (cider-defun-at-point))))\n\n(defun cider-eval-ns-form ()\n  \"Evaluate the current buffer's namespace form.\"\n  (interactive)\n  (when (clojure-find-ns)\n    (save-excursion\n      (goto-char (match-beginning 0))\n      (cider-eval-defun-at-point))))\n\n(defun cider-bounds-of-sexp-at-point ()\n  \"Return the bounds sexp at point as a pair (or nil).\"\n  (or (and (equal (char-after) ?\\()\n           (member (char-before) '(?\\' ?\\, ?\\@))\n           ;; hide stuff before ( to avoid quirks with '( etc.\n           (save-restriction\n             (narrow-to-region (point) (point-max))\n             (bounds-of-thing-at-point 'sexp)))\n      (bounds-of-thing-at-point 'sexp)))\n\n;; FIXME: This doesn't have properly at the beginning of the REPL prompt\n(defun cider-symbol-at-point ()\n  \"Return the name of the symbol at point, otherwise nil.\"\n  (let ((str (substring-no-properties (or (thing-at-point 'symbol) \"\"))))\n    (if (equal str (concat (cider-find-ns) \"> \"))\n        \"\"\n      str)))\n\n(defun cider-sexp-at-point ()\n  \"Return the sexp at point as a string, otherwise nil.\"\n  (let ((bounds (cider-bounds-of-sexp-at-point)))\n    (if bounds\n        (buffer-substring-no-properties (car bounds)\n                                        (cdr bounds)))))\n\n(defun cider-sexp-at-point-with-bounds ()\n  \"Return a list containing the sexp at point and its bounds.\"\n  (let ((bounds (cider-bounds-of-sexp-at-point)))\n    (if bounds\n        (let ((start (car bounds))\n              (end (cdr bounds)))\n          (list (buffer-substring-no-properties start end)\n                (cons (set-marker (make-marker) start)\n                      (set-marker (make-marker) end)))))))\n\n(defun cider-last-sexp ()\n  \"Return the sexp preceding the point.\"\n  (buffer-substring-no-properties\n   (save-excursion\n     (backward-sexp)\n     (point))\n   (point)))\n\n;;;\n(defun cider-tramp-prefix (&optional buffer)\n  \"Use the filename for BUFFER to determine a tramp prefix.\nDefaults to the current buffer.\nReturn the tramp prefix, or nil if BUFFER is local.\"\n  (let* ((buffer (or buffer (current-buffer)))\n         (name (buffer-file-name buffer)))\n    (when (tramp-tramp-file-p name)\n      (let ((vec (tramp-dissect-file-name name)))\n        (tramp-make-tramp-file-name (tramp-file-name-method vec)\n                                    (tramp-file-name-user vec)\n                                    (tramp-file-name-host vec)\n                                    nil)))))\n\n(defun cider--client-tramp-filename (name &optional buffer)\n  \"Return the tramp filename for path NAME relative to BUFFER.\nIf BUFFER has a tramp prefix, it will be added as a prefix to NAME.\nIf the resulting path is an existing tramp file, it returns the path,\notherwise, nil.\"\n  (let* ((buffer (or buffer (current-buffer)))\n         (name (concat (cider-tramp-prefix buffer) name)))\n    (if (tramp-handle-file-exists-p name)\n        name)))\n\n(defun cider--server-filename (name)\n  \"Return the nREPL server-relative filename for NAME.\"\n  (if (tramp-tramp-file-p name)\n      (with-parsed-tramp-file-name name nil\n        localname)\n    name))\n\n(defun cider-file-path (resource)\n  \"Return RESOURCE's local or remote path using `cider-prefer-local-resources'.\"\n  (let ((local-path resource)\n        (remote-path (concat (cider-tramp-prefix) resource)))\n    (cond ((equal resource \"\") \"\")\n          ((and cider-prefer-local-resources\n                (file-exists-p local-path))\n           local-path)\n          ((file-exists-p remote-path)\n           remote-path)\n          (t\n           resource))))\n\n(defun cider-find-or-create-file-buffer (filename)\n  \"Return a buffer visiting FILENAME.\"\n  (let ((large-file-warning-threshold nil))\n    (find-file-noselect (cider-file-path filename))))\n\n(defun cider-find-or-create-resource-buffer (resource)\n  \"Return a buffer displaying RESOURCE.\"\n  (cond ((string-match \"^file:\\\\(.+\\\\)\" resource)\n         (cider-find-or-create-file-buffer (match-string 1 resource)))\n        ((string-match \"^\\\\(jar\\\\|zip\\\\):file:\\\\(.+\\\\)!/\\\\(.+\\\\)\" resource)\n         (let* ((jar (match-string 2 resource))\n                (path (match-string 3 resource))\n                (file (cider-file-path jar))\n                (name (format \"%s:%s\" jar path)))\n           (or (get-file-buffer name)\n               (with-current-buffer (generate-new-buffer\n                                     (file-name-nondirectory path))\n                 (archive-zip-extract file path)\n                 (set-visited-file-name name)\n                 (setq-local default-directory (file-name-directory file))\n                 (setq-local buffer-read-only t)\n                 (set-buffer-modified-p nil)\n                 (set-auto-mode)\n                 (current-buffer)))))\n        (t (error \"Unknown resource path %s\" resource))))\n\n(defun cider-find-or-create-definition-buffer (location)\n  \"Return a buffer containing LOCATION's definition in the source code.\n\nThe current buffer is used to determine a tramp prefix, which (if it\nexists) is added as a prefix to LOCATION.\"\n  (let* ((path (cider-get-path-for location))\n         (tramp-path (and path (cider--client-tramp-filename path)))\n         (buffer (cond (tramp-path (cider-find-or-create-file-buffer tramp-path))\n                       ((and path (file-exists-p path)) (cider-find-or-create-file-buffer path))\n                       (t (cider-find-or-create-resource-buffer path)))))\n    (with-current-buffer buffer\n      (cider-mode 1) ; enable cider-jump keybindings on java sources\n      buffer)))\n\n(defun cider-jump-to-def-for (def-location)\n  \"Jump to DEF-LOCATION in the source code.\"\n  (-when-let* ((buffer (cider-find-or-create-definition-buffer def-location))\n               (line (cider-get-line-for def-location)))\n    (ring-insert find-tag-marker-ring (point-marker))\n    (switch-to-buffer buffer)\n    (goto-line line)))\n\n(defun cider-get-def-location (var)\n  \"Return the location of the definition of VAR.\"\n  (let* ((info (cider-var-info var))\n         (file (cadr (assoc \"file\" info)))\n         (line (cadr (assoc \"line\" info))))\n    (if info\n        (if (and file line)\n            (vector file line)\n          (message \"No source available for %s\" var) nil)\n      (message \"Symbol %s not resolved\" var) nil)))\n\n(defun cider-get-path-for (location)\n  \"Return the path of LOCATION's definition.\"\n  (aref location 0))\n\n(defun cider-get-line-for (location)\n  \"Return the line number of LOCATION's definition.\"\n  (aref location 1))\n\n(defun cider-jump-to-def (var &optional line)\n  \"Jump to the definition of the VAR, and optionally to the given LINE.\"\n  (cider-ensure-op-supported \"info\")\n  (-when-let (location (cider-get-def-location var))\n    (cider-jump-to-def-for location)\n    (when line (goto-line line))))\n\n(defun cider-jump (query)\n  \"Jump to the definition of QUERY.\"\n  (interactive \"P\")\n  (cider-read-symbol-name \"Symbol: \" 'cider-jump-to-def query))\n\n(defun cider-jump-to-resource ()\n  \"Jump to resource file at point.\"\n  (interactive)\n  (cider-ensure-op-supported \"resource\")\n  (let ((resource (thing-at-point 'filename)))\n    (-if-let (resource-path (plist-get (nrepl-send-request-sync\n                                          (list \"op\" \"resource\"\n                                                \"name\" resource)) :value))\n        (progn\n          (ring-insert find-tag-marker-ring (point-marker))\n          (find-file resource-path)\n          ;; enable cider-mode in the resource buffer so that jump back will work\n          (cider-mode +1))\n      (message \"Cannot find resource %s\" resource))))\n\n(defalias 'cider-jump-back 'pop-tag-mark)\n\n(defvar cider-completion-last-context nil)\n\n(defun cider-completion-symbol-start-pos ()\n  \"Find the starting position of the symbol at point, unless inside a string.\"\n  (let ((sap (symbol-at-point)))\n    (when (and sap (not (in-string-p)))\n      (car (bounds-of-thing-at-point 'symbol)))))\n\n(defun cider-completion-get-context-at-point ()\n  \"Extract the context at point.\nIf point is not inside the list, returns nil; otherwise return top-level\nform, with symbol at point replaced by __prefix__.\"\n  (when (save-excursion\n          (condition-case foo\n              (progn\n                (up-list)\n                (check-parens)\n                t)\n            (scan-error nil)\n            (user-error nil)))\n    (save-excursion\n      (let* ((pref-end (point))\n             (pref-start (cider-completion-symbol-start-pos))\n             (context (cider-defun-at-point))\n             (_ (beginning-of-defun))\n             (expr-start (point)))\n        (concat (substring context 0 (- pref-start expr-start))\n                \"__prefix__\"\n                (substring context (- pref-end expr-start)))))))\n\n(defun cider-completion-get-context ()\n  \"Extract context depending on `cider-completion-use-context' and major mode.\"\n  (let ((context (if (and cider-completion-use-context\n                          ;; Important because `beginning-of-defun' and\n                          ;; `ending-of-defun' work incorrectly in the REPL\n                          ;; buffer, so context extraction fails there.\n                          (not (eq major-mode 'cider-repl-buffer)))\n                     (or (cider-completion-get-context-at-point)\n                         \"nil\")\n                   \"nil\")))\n    (if (string= cider-completion-last-context context)\n        \":same\"\n      (setq cider-completion-last-context context)\n      context)))\n\n(defun cider-complete (str)\n  \"Return a list of completions for STR using nREPL's \\\"complete\\\" op.\"\n  (cider-ensure-op-supported \"complete\")\n  (let ((strlst (plist-get\n                 (nrepl-send-request-sync\n                  (list \"op\" \"complete\"\n                        \"session\" (nrepl-current-session)\n                        \"ns\" nrepl-buffer-ns\n                        \"symbol\" str\n                        \"context\" (cider-completion-get-context)))\n                 :value)))\n    (when strlst\n      strlst)))\n\n(defun cider-complete-at-point ()\n  \"Complete the symbol at point.\"\n  (let ((sap (symbol-at-point)))\n    (when (and sap (not (in-string-p)))\n      (let ((bounds (bounds-of-thing-at-point 'symbol)))\n        (list (car bounds) (cdr bounds)\n              (completion-table-dynamic #'cider-complete)\n              :company-doc-buffer #'cider-create-doc-buffer\n              :company-location #'cider-company-location\n              :company-docsig #'cider-company-docsig)))))\n\n(defun cider-company-location (var)\n  \"Open VAR's definition in a buffer.\n\nReturns the cons of the buffer itself and the location of VAR's definition\nin the buffer.\"\n  (-when-let* ((location (cider-get-def-location var))\n               (buffer (cider-find-or-create-definition-buffer location))\n               (line (cider-get-line-for location)))\n    (with-current-buffer buffer\n      (goto-line line)\n      (cons buffer (point)))))\n\n(defun cider-company-docsig (thing)\n  \"Return signature for THING.\"\n  (let ((arglist (cider-eldoc-arglist thing)))\n    (when arglist\n      (format \"%s: %s\"\n              (cider-eldoc-format-thing thing)\n              arglist))))\n\n(defun cider-javadoc-handler (symbol-name)\n  \"Invoke the nREPL \\\"info\\\" op on SYMBOL-NAME if available.\"\n  (when symbol-name\n    (cider-ensure-op-supported \"info\")\n    (let* ((info (cider-var-info symbol-name))\n           (url (cadr (assoc \"javadoc\" info))))\n      (if url\n          (browse-url url)\n        (error \"No Javadoc available for %s\" symbol-name)))))\n\n(defun cider-javadoc (query)\n  \"Browse Javadoc on the Java symbol QUERY at point.\"\n  (interactive \"P\")\n  (cider-read-symbol-name \"Javadoc for: \" 'cider-javadoc-handler query))\n\n(defun cider-stdin-handler (buffer)\n  \"Make a stdin response handler for BUFFER.\"\n  (nrepl-make-response-handler buffer\n                               (lambda (buffer value)\n                                 (cider-repl-emit-result buffer value t))\n                               (lambda (buffer out)\n                                 (cider-repl-emit-output buffer out t))\n                               (lambda (buffer err)\n                                 (cider-repl-emit-output buffer err t))\n                               nil))\n\n(defun cider-insert-eval-handler (buffer)\n  \"Make a nREPL evaluation handler for the BUFFER.\nThe handler simply inserts the result value in BUFFER.\"\n  (nrepl-make-response-handler buffer\n                               (lambda (_buffer value)\n                                 (with-current-buffer buffer\n                                   (insert value)))\n                               (lambda (_buffer out)\n                                 (cider-repl-emit-interactive-output out))\n                               (lambda (buffer err)\n                                 (message \"%s\" err)\n                                 (cider-highlight-compilation-errors\n                                  buffer err))\n                               '()))\n\n(defun cider-emit-interactive-eval-output (output)\n  \"Emit standard or error output resulting from interactive code evaluation.\n\nThe output can be send to either a dedicated output buffer or the current REPL buffer.\nThis is controlled via `cider-interactive-eval-output-destination'.\"\n  (pcase cider-interactive-eval-output-destination\n    (`output-buffer (let ((output-buffer (or (get-buffer cider-output-buffer)\n                                             (cider-popup-buffer cider-output-buffer t))))\n                      (cider-emit-into-popup-buffer output-buffer output)\n                      (pop-to-buffer output-buffer)))\n    (`repl-buffer (cider-repl-emit-interactive-output output))\n    (t (error \"Unsupported value %s for `cider-interactive-eval-output'\"))))\n\n(defun cider-interactive-eval-handler (buffer)\n  \"Make an interactive eval handler for BUFFER.\"\n  (nrepl-make-response-handler buffer\n                               (lambda (_buffer value)\n                                 (message \"%s%s\"\n                                          cider-interactive-eval-result-prefix\n                                          (cider-font-lock-as-clojure value)))\n                               (lambda (_buffer out)\n                                 (cider-emit-interactive-eval-output out))\n                               (lambda (buffer err)\n                                 (cider-emit-interactive-eval-output err)\n                                 (cider-highlight-compilation-errors\n                                  buffer err))\n                               '()))\n\n(defun cider-load-file-handler (buffer)\n  \"Make a load file handler for BUFFER.\"\n  (nrepl-make-response-handler buffer\n                               (lambda (buffer value)\n                                 (message \"%s\" value)\n                                 (with-current-buffer buffer\n                                   (setq nrepl-buffer-ns (clojure-find-ns))\n                                   (run-hooks 'cider-file-loaded-hook)))\n                               (lambda (_buffer value)\n                                 (cider-emit-interactive-eval-output value))\n                               (lambda (buffer err)\n                                 (cider-emit-interactive-eval-output err)\n                                 (cider-highlight-compilation-errors\n                                  buffer err))\n                               '()\n                               (lambda (buffer ex root-ex session)\n                                 (funcall nrepl-err-handler\n                                          buffer ex root-ex session))))\n\n(defun cider-interactive-eval-print-handler (buffer)\n  \"Make a handler for evaluating and printing result in BUFFER.\"\n  (nrepl-make-response-handler buffer\n                               (lambda (buffer value)\n                                 (with-current-buffer buffer\n                                   (insert (format \"\\n%s\" value))))\n                               (lambda (_buffer out)\n                                 (cider-emit-interactive-eval-output out))\n                               (lambda (_buffer err)\n                                 (cider-emit-interactive-eval-output err))\n                               '()))\n\n(defun cider-popup-eval-print-handler (buffer)\n  \"Make a handler for evaluating and printing result in popup BUFFER.\"\n  (nrepl-make-response-handler buffer\n                               (lambda (buffer str)\n                                 (cider-emit-into-popup-buffer buffer str))\n                               '()\n                               (lambda (buffer str)\n                                 (cider-emit-into-popup-buffer buffer str))\n                               '()))\n\n(defun cider-popup-eval-out-handler (buffer)\n  \"Make a handler for evaluating and printing stdout/stderr in popup BUFFER.\"\n  (nrepl-make-response-handler buffer\n                               '()\n                               (lambda (buffer str)\n                                 (cider-emit-into-popup-buffer buffer str))\n                               (lambda (buffer str)\n                                 (cider-emit-into-popup-buffer buffer str))\n                               '()))\n\n(defun cider-visit-error-buffer ()\n  \"Visit the `cider-error-buffer' (usually *cider-error*) if it exists.\"\n  (interactive)\n  (let ((buffer (get-buffer cider-error-buffer)))\n    (if buffer\n        (cider-popup-buffer-display buffer cider-auto-select-error-buffer)\n      (error \"No %s buffer\" cider-error-buffer))))\n\n(defun cider-find-property (property &optional backward)\n  \"Find the next text region which has the specified PROPERTY.\nIf BACKWARD is t, then search backward.\nReturns the position at which PROPERTY was found, or nil if not found.\"\n  (let ((p (if backward\n               (previous-single-char-property-change (point) property)\n             (next-single-char-property-change (point) property))))\n    (when (and (not (= p (point-min))) (not (= p (point-max))))\n      p)))\n\n(defun cider-jump-to-compilation-error (&optional _arg _reset)\n  \"Jump to the line causing the current compilation error.\n\n_ARG and _RESET are ignored, as there is only ever one compilation error.\nThey exist for compatibility with `next-error'.\"\n  (interactive)\n  (cl-labels ((goto-next-note-boundary\n               ()\n               (let ((p (or (cider-find-property 'cider-note-p)\n                            (cider-find-property 'cider-note-p t))))\n                 (when p\n                   (goto-char p)\n                   (message (get-char-property p 'cider-note))))))\n    ;; if we're already on a compilation error, first jump to the end of\n    ;; it, so that we find the next error.\n    (when (get-char-property (point) 'cider-note-p)\n      (goto-next-note-boundary))\n    (goto-next-note-boundary)))\n\n(defun cider-default-err-eval-handler (buffer session)\n  \"Display in BUFFER the last SESSION exception, without middleware support.\"\n  (cider-eval \"(clojure.stacktrace/print-cause-trace *e)\"\n              (lambda (response)\n                (nrepl-dbind-response response (out)\n                  (when out\n                    (with-current-buffer buffer\n                      (cider-emit-into-color-buffer buffer out)\n                      (compilation-minor-mode +1)))))\n              nil\n              session))\n\n(defun cider-default-err-op-handler (buffer session)\n  \"Display in BUFFER the last SESSION exception, with middleware support.\"\n  (let (causes)\n    (nrepl-send-request\n     (list \"op\" \"stacktrace\" \"session\" session)\n     (lambda (response)\n       (nrepl-dbind-response response (class status)\n         (cond (class  (setq causes (cons response causes)))\n               (status (when causes\n                         (cider-stacktrace-render buffer (reverse causes))))))))))\n\n(defun cider-default-err-handler (buffer ex root-ex session)\n  \"Make an error handler for BUFFER, EX, ROOT-EX and SESSION.\nThis function determines how the error buffer is shown, and then delegates\nthe actual error content to the eval or op handler.\"\n  (let* ((replp (with-current-buffer buffer (derived-mode-p 'cider-repl-mode)))\n         (showp (memq cider-show-error-buffer\n                      (if replp\n                          '(t always only-in-repl)\n                        '(t always except-in-repl))))\n         (error-buffer (if (not showp)\n                           (cider-make-popup-buffer cider-error-buffer)\n                         (cider-popup-buffer cider-error-buffer\n                                             cider-auto-select-error-buffer))))\n    (if (nrepl-op-supported-p \"stacktrace\")\n        (cider-default-err-op-handler error-buffer session)\n      (cider-default-err-eval-handler error-buffer session))))\n\n(defvar cider-compilation-regexp\n  '(\"\\\\(?:.*\\\\(warning, \\\\)\\\\|.*?\\\\(, compiling\\\\):(\\\\)\\\\([^:]*\\\\):\\\\([[:digit:]]+\\\\)\\\\(?::\\\\([[:digit:]]+\\\\)\\\\)?\\\\(\\\\(?: - \\\\(.*\\\\)\\\\)\\\\|)\\\\)\" 3 4 5 (1))\n  \"Specifications for matching errors and warnings in Clojure stacktraces.\nSee `compilation-error-regexp-alist' for help on their format.\")\n\n(add-to-list 'compilation-error-regexp-alist-alist\n             (cons 'cider cider-compilation-regexp))\n(add-to-list 'compilation-error-regexp-alist 'cider)\n\n(defun cider-extract-error-info (regexp message)\n  \"Extract error information with REGEXP against MESSAGE.\"\n  (let ((file (nth 1 regexp))\n        (line (nth 2 regexp))\n        (col (nth 3 regexp))\n        (type (nth 4 regexp))\n        (pat (car regexp)))\n    (when (string-match pat message)\n      ;; special processing for type (1.2) style\n      (setq type (if (consp type)\n                     (or (and (car type) (match-end (car type)) 1)\n                         (and (cdr type) (match-end (cdr type)) 0)\n                         2)))\n      (list\n       (when file\n         (let ((val (match-string-no-properties file message)))\n           (unless (string= val \"NO_SOURCE_PATH\") val)))\n       (when line (string-to-number (match-string-no-properties line message)))\n       (when col\n         (let ((val (match-string-no-properties col message)))\n           (when val (string-to-number val))))\n       (aref [cider-warning-highlight-face\n              cider-warning-highlight-face\n              cider-error-highlight-face]\n             (or type 2))\n       message))))\n\n(defun cider-highlight-compilation-errors (buffer message)\n  \"Highlight compilation error line in BUFFER, using MESSAGE.\"\n  (with-current-buffer buffer\n    (let ((info (cider-extract-error-info cider-compilation-regexp message)))\n      (when info\n        (let ((file (nth 0 info))\n              (line (nth 1 info))\n              (col (nth 2 info))\n              (face (nth 3 info))\n              (note (nth 4 info)))\n          (save-excursion\n            ;; when we don't have a filename or it's different from the one of\n            ;; the current buffer, the line number is relative to form start\n            (if (and file (equal file (file-truename (buffer-file-name))))\n                (goto-char (point-min)) ; start of file\n              (beginning-of-defun))\n            (forward-line (1- line))\n            ;; if have column, highlight sexp at that point otherwise whole line.\n            (move-to-column (or col 0))\n            (let ((begin (progn (if col (backward-up-list) (back-to-indentation)) (point)))\n                  (end (progn (if col (forward-sexp) (move-end-of-line nil)) (point))))\n              (let ((overlay (make-overlay begin end)))\n                (overlay-put overlay 'cider-note-p t)\n                (overlay-put overlay 'face face)\n                (overlay-put overlay 'cider-note note)\n                (overlay-put overlay 'help-echo note)))))))))\n\n(defun cider-need-input (buffer)\n  \"Handle an need-input request from BUFFER.\"\n  (with-current-buffer buffer\n    (nrepl-send-stdin (concat (read-from-minibuffer \"Stdin: \") \"\\n\")\n                      (cider-stdin-handler buffer))))\n\n\f\n;;;; Popup buffers\n(define-minor-mode cider-popup-buffer-mode\n  \"Mode for CIDER popup buffers\"\n  nil\n  (\" cider-tmp\")\n  '((\"q\" .  cider-popup-buffer-quit-function)))\n\n(defvar-local cider-popup-buffer-quit-function 'cider-popup-buffer-quit\n  \"The function that is used to quit a temporary popup buffer.\")\n\n(defun cider-popup-buffer-quit-function (&optional kill-buffer-p)\n  \"Wrapper to invoke the function `cider-popup-buffer-quit-function'.\nKILL-BUFFER-P is passed along.\"\n  (interactive)\n  (funcall cider-popup-buffer-quit-function kill-buffer-p))\n\n(defun cider-popup-buffer (name &optional select)\n  \"Create new popup buffer called NAME.\nIf SELECT is non-nil, select the newly created window\"\n  (with-current-buffer (cider-make-popup-buffer name)\n    (cider-popup-buffer-display (current-buffer) select)))\n\n(defun cider-popup-buffer-display (popup-buffer &optional select)\n  \"Display POPUP-BUFFER.\nIf SELECT is non-nil, select the newly created window\"\n  (with-current-buffer popup-buffer\n    (let ((new-window (display-buffer (current-buffer))))\n      (set-window-point new-window (point))\n      (when select\n        (select-window new-window))\n      (current-buffer))))\n\n(defun cider-popup-buffer-quit (&optional kill-buffer-p)\n  \"Quit the current (temp) window and bury its buffer using `quit-window'.\nIf prefix argument KILL-BUFFER-P is non-nil, kill the buffer instead of burying it.\"\n  (interactive)\n  (quit-window kill-buffer-p (selected-window)))\n\n(defun cider-make-popup-buffer (name)\n  \"Create a temporary buffer called NAME.\"\n  (with-current-buffer (get-buffer-create name)\n    (kill-all-local-variables)\n    (setq buffer-read-only nil)\n    (erase-buffer)\n    (set-syntax-table clojure-mode-syntax-table)\n    (cider-popup-buffer-mode 1)\n    (setq buffer-read-only t)\n    (current-buffer)))\n\n(defun cider-emit-into-popup-buffer (buffer value)\n  \"Emit into BUFFER the provided VALUE.\"\n  (with-current-buffer buffer\n    (let ((inhibit-read-only t)\n          (buffer-undo-list t))\n      (insert (format \"%s\" value))\n      (indent-sexp)\n      (font-lock-fontify-buffer))))\n\n(defun cider-emit-into-color-buffer (buffer value)\n  \"Emit into color BUFFER the provided VALUE.\"\n  (with-current-buffer buffer\n    (let ((inhibit-read-only t)\n          (buffer-undo-list t))\n      (goto-char (point-max))\n      (insert (format \"%s\" value))\n      (ansi-color-apply-on-region (point-min) (point-max)))\n    (goto-char (point-min))))\n\n;;; Namespace handling\n(defun cider-find-ns ()\n  \"Return the ns of the current buffer.\n\nFor Clojure buffers the ns is extracted from the ns header.  If\nit's missing \\\"user\\\" is used as fallback.\"\n  (cond\n   ((derived-mode-p 'clojure-mode)\n    (or (save-restriction\n          (widen)\n          (clojure-find-ns))\n        \"user\"))\n   ((derived-mode-p 'cider-repl-mode)\n    nrepl-buffer-ns)))\n\n(defun cider-current-ns ()\n  \"Return the ns in the current context.\nIf `nrepl-buffer-ns' has a value then return that, otherwise\nsearch for and read a `ns' form.\"\n  (let ((ns nrepl-buffer-ns))\n    (or (and (string= ns \"user\")\n             (cider-find-ns))\n        ns)))\n\n\f\n;;; Evaluation\n(defun cider-popup-eval-print (form)\n  \"Evaluate the given FORM and print value in current buffer.\"\n  (let ((buffer (current-buffer)))\n    (cider-eval form\n                (cider-popup-eval-print-handler buffer)\n                (cider-current-ns))))\n\n(defun cider-interactive-eval-print (form)\n  \"Evaluate the given FORM and print value in current buffer.\"\n  (let ((buffer (current-buffer)))\n    (cider-eval form\n                (cider-interactive-eval-print-handler buffer)\n                (cider-current-ns))))\n\n(defun cider-interactive-eval (form)\n  \"Evaluate the given FORM and print value in minibuffer.\"\n  (remove-overlays (point-min) (point-max) 'cider-note-p t)\n  (let ((buffer (current-buffer)))\n    (cider-eval form\n                (cider-interactive-eval-handler buffer)\n                (cider-current-ns))))\n\n(defun cider-interactive-eval-to-repl (form)\n  \"Evaluate the given FORM and print it's value in REPL buffer.\"\n  (let ((buffer (cider-current-repl-buffer)))\n    (cider-eval form\n                (cider-insert-eval-handler buffer)\n                (cider-current-ns))))\n\n(defun cider-eval-last-sexp (&optional prefix)\n  \"Evaluate the expression preceding point.\nIf invoked with a PREFIX argument, print the result in the current buffer.\"\n  (interactive \"P\")\n  (if prefix\n      (cider-interactive-eval-print (cider-last-sexp))\n    (cider-interactive-eval (cider-last-sexp))))\n\n(defun cider-eval-last-sexp-and-replace ()\n  \"Evaluate the expression preceding point and replace it with its result.\"\n  (interactive)\n  (let ((last-sexp (cider-last-sexp)))\n    ;; we have to be sure the evaluation won't result in an error\n    (cider-eval-and-get-value last-sexp)\n    ;; seems like the sexp is valid, so we can safely kill it\n    (backward-kill-sexp)\n    (cider-interactive-eval-print last-sexp)))\n\n(defun cider-eval-last-sexp-to-repl (&optional prefix)\n  \"Evaluate the expression preceding point and insert its result in the REPL.\nIf invoked with a PREFIX argument, switch to the REPL buffer.\"\n  (interactive \"P\")\n  (cider-interactive-eval-to-repl (cider-last-sexp))\n  (when prefix\n    (cider-switch-to-repl-buffer)))\n\n(defun cider-eval-print-last-sexp ()\n  \"Evaluate the expression preceding point.\nPrint its value into the current buffer.\"\n  (interactive)\n  (cider-interactive-eval-print (cider-last-sexp)))\n\n(defun cider-pprint-eval-last-sexp ()\n  \"Evaluate the sexp preceding point and pprint its value in a popup buffer.\"\n  (interactive)\n  (let ((form (cider-last-sexp))\n        (result-buffer (cider-popup-buffer cider-result-buffer nil)))\n    (cider-eval (cider-format-pprint-eval form)\n                (cider-popup-eval-out-handler result-buffer)\n                (cider-current-ns))))\n\n(defun cider-pprint-eval-defun-at-point ()\n  \"Evaluate the top-level form at point and pprint its value in a popup buffer.\"\n  (interactive)\n  (let ((form (cider-defun-at-point))\n        (result-buffer (cider-popup-buffer cider-result-buffer nil)))\n    (cider-eval (cider-format-pprint-eval form)\n                (cider-popup-eval-out-handler result-buffer)\n                (cider-current-ns))))\n\n(defun cider-insert-in-repl (form eval)\n  \"Insert FORM in the REPL buffer and switch to it.\nIf EVAL is non-nil the form will also be evaluated.\"\n  (let ((start-pos (point)))\n    (while (string-match \"\\\\`[ \\t\\n\\r]+\\\\|[ \\t\\n\\r]+\\\\'\" form)\n      (setq form (replace-match \"\" t t form)))\n    (with-current-buffer (cider-current-repl-buffer)\n      (insert form)\n      (indent-region start-pos (point))\n      (when eval\n        (cider-repl-return))))\n  (cider-switch-to-repl-buffer))\n\n(defun cider-insert-last-sexp-in-repl (&optional arg)\n  \"Insert the expression preceding point in the REPL buffer.\nIf invoked with a prefix ARG eval the expression after inserting it.\"\n  (interactive \"P\")\n  (cider-insert-in-repl (cider-last-sexp) arg))\n\n(defun cider-insert-defun-in-repl (&optional arg)\n  \"Insert the top-level form at point in the REPL buffer.\nIf invoked with a prefix ARG eval the expression after inserting it.\"\n  (interactive \"P\")\n  (cider-insert-in-repl (cider-defun-at-point) arg))\n\n(defun cider-insert-ns-form-in-repl (&optional arg)\n  \"Insert the current buffer's ns form in the REPL buffer.\nIf invoked with a prefix ARG eval the expression after inserting it.\"\n  (interactive \"P\")\n  (cider-insert-in-repl (cider-ns-form) arg))\n\n(defun cider-ping ()\n  \"Check that communication with the server works.\"\n  (interactive)\n  (message \"%s\" (cider-eval-and-get-value \"\\\"PONG\\\"\")))\n\n(defun clojure-enable-cider ()\n  \"Turn on CIDER mode (see command `cider-mode').\nUseful in hooks.\"\n  (cider-mode 1)\n  (setq next-error-function 'cider-jump-to-compilation-error))\n\n(defun clojure-disable-cider ()\n  \"Turn off CIDER mode (see command `cider-mode').\nUseful in hooks.\"\n  (cider-mode -1))\n\n(defun cider-connected-p ()\n  \"Return t if CIDER is currently connected, nil otherwise.\"\n  (condition-case nil\n      (nrepl-current-connection-buffer)\n    (error nil)))\n\n(defun cider-ensure-connected ()\n  \"Ensure there is a cider connection present, otherwise\nan error is signalled.\"\n  (unless (cider-connected-p)\n    (error \"No active nREPL connection\")))\n\n(defun cider-enable-on-existing-clojure-buffers ()\n  \"Enable interaction mode on existing Clojure buffers.\nSee command `cider-mode'.\"\n  (interactive)\n  (add-hook 'clojure-mode-hook 'clojure-enable-cider)\n  (dolist (buffer (cider-util--clojure-buffers))\n    (with-current-buffer buffer\n      (clojure-enable-cider))))\n\n(defun cider-disable-on-existing-clojure-buffers ()\n  \"Disable `cider-mode' on existing Clojure buffers.\nSee command `cider-mode'.\"\n  (interactive)\n  (dolist (buffer (cider-util--clojure-buffers))\n    (with-current-buffer buffer\n      (setq nrepl-buffer-ns \"user\")\n      (clojure-disable-cider))))\n\n(defun cider-possibly-disable-on-existing-clojure-buffers ()\n  \"If not connected, disable `cider-mode' on existing Clojure buffers.\"\n  (unless (cider-connected-p)\n    (cider-disable-on-existing-clojure-buffers)))\n\n(defun cider-fetch-vars-form (ns)\n  \"Construct a Clojure form to read vars inside for NS.\"\n  `(concat (if (find-ns (symbol ,ns))\n               (map name (concat (keys (ns-interns (symbol ,ns)))\n                                 (keys (ns-refers (symbol ,ns))))))\n           (if (not= \"\" ,ns) [\"..\"])\n           (->> (all-ns)\n             (map (fn [n]\n                      (re-find (re-pattern (str \"^\" (if (not= ,ns \"\")\n                                                        (str ,ns \"\\\\.\"))\n                                                \"[^\\\\.]+\"))\n                               (str n))))\n             (filter identity)\n             (map (fn [n] (str n \"/\")))\n             (into (hash-set)))))\n\n(defun cider-parent-ns (ns)\n  \"Go up a level of NS.\nFor example \\\"foo.bar.tar\\\" -> \\\"foo.bar\\\".\"\n  (cider-string-join (butlast (split-string ns \"\\\\.\")) \".\"))\n\n(defun cider-completing-read-var-select (prompt callback ns selected targets)\n  \"Peform completing read using SELECTED and TARGETS.\nIf SELECTED is \\\"..\\\" then another selection is made for vars in the parent namespace of\nNS using PROMPT.\nIf SELECTED is a namespace then another selection is made against that namespace\nusing PROMPT.\nOnce a selecton is made CALLBACK is called with SELECTED.\"\n  ;; TODO: immediate RET gives \"\" as selected for some reason\n  ;; this is an OK workaround though\n  (cond ((equal \"\" selected)\n         (cider-completing-read-var-select prompt callback ns (car targets) targets))\n        ((equal \"/\" (substring selected -1)) ; selected a namespace\n         (cider-completing-read-var prompt (substring selected 0 -1) callback))\n        ((equal \"..\" selected)\n         (cider-completing-read-var prompt (cider-parent-ns ns) callback))\n        ;; non ido variable selection techniques don't return qualified symbols, so this shouldn't either\n        (t (funcall callback selected))))\n\n(defun cider-completing-read-sym-handler (label completing-read-callback buffer)\n  \"Create an nrepl response handler for BUFFER.\nThe handler will parse the response from nrepl to create targets for a completing read.\nThe result of the completing read will be passed to COMPLETING-READ-CALLBACK.\"\n  (nrepl-make-response-handler buffer\n                               (lambda (buffer value)\n                                 ;; make sure to eval the callback in the buffer that the symbol was requested from so we get the right namespace\n                                 (with-current-buffer buffer\n                                   (let* ((targets (car (read-from-string value)))\n                                          (selected (completing-read label targets nil t)))\n                                     (funcall completing-read-callback selected targets))))\n                               nil nil nil))\n\n(defun cider-completing-read-sym-form (label form callback)\n  \"Eval the FORM and pass the result to the response handler.\"\n  (cider-tooling-eval form (cider-completing-read-sym-handler label callback (current-buffer))\n                      nrepl-buffer-ns))\n\n(defun cider-completing-read-var (prompt ns callback)\n  \"Perform completing read var in NS using CALLBACK.\"\n  (cider-completing-read-sym-form prompt (prin1-to-string (cider-fetch-vars-form ns))\n                                  (lambda (selected targets)\n                                    (cider-completing-read-var-select prompt callback ns selected targets))))\n\n(defun cider-fetch-fns-form (ns)\n  \"Construct a Clojure form for reading fns using supplied NS.\"\n  (format \"(let [fn-pred (fn [[k v]] (and (fn? (.get v))\n                                     (not (re-find #\\\"clojure.\\\" (str v)))))]\n              (sort\n                (map (comp name key)\n                     (filter fn-pred\n                         (concat\n                           (ns-interns '%s)\n                           (ns-refers '%s))))))\" ns ns))\n\n(defun cider-load-fn-into-repl-buffer ()\n  \"Browse functions available in current repl buffer.\nOnce selected, the name of the fn will appear in the repl buffer in parens\nready to call.\"\n  (interactive)\n  (cider-completing-read-sym-form (format \"Fn: %s/\" nrepl-buffer-ns)\n                                  (cider-fetch-fns-form (cider-current-ns))\n                                  (lambda (f _targets)\n                                    (with-current-buffer (cider-current-repl-buffer)\n                                      (cider-repl--replace-input (format \"(%s)\" f))\n                                      (goto-char (- (point-max) 1))))))\n\n(defun cider-read-symbol-name (prompt callback &optional query)\n  \"Either read a symbol name using PROMPT or choose the one at point.\nUse CALLBACK as the completing read var callback.\nThe user is prompted with PROMPT if a prefix argument is in effect,\nif there is no symbol at point, or if QUERY is non-nil.\"\n  (let ((symbol-name (cider-symbol-at-point)))\n    (if (not (or current-prefix-arg\n                 query\n                 (not symbol-name)\n                 (equal \"\" symbol-name)))\n        (funcall callback symbol-name)\n      (cider-completing-read-var prompt nrepl-buffer-ns callback))))\n\n(defun cider-toggle-trace (query)\n  \"Toggle tracing for the given QUERY.\nDefaults to the symbol at point.  With prefix arg or no symbol at\npoint, prompts for a var.\"\n  (interactive \"P\")\n  (cider-ensure-op-supported \"toggle-trace\")\n  (cider-read-symbol-name\n   \"Toggle trace for var: \"\n   (lambda (sym)\n     (nrepl-send-request\n      (list \"op\" \"toggle-trace\"\n            \"ns\" (cider-current-ns)\n            \"var\" sym)\n      (cider-interactive-eval-handler (current-buffer))))\n   query))\n\n(defun cider-create-doc-buffer (symbol)\n  \"Populates *cider-doc* with the documentation for SYMBOL.\"\n  (-when-let (info (cider-var-info symbol))\n    (cider-doc-render (cider-make-popup-buffer cider-doc-buffer) symbol info)))\n\n(defun cider-doc-lookup (symbol)\n  \"Look up documentation for SYMBOL.\"\n  (-if-let (buffer (cider-create-doc-buffer symbol))\n      (cider-popup-buffer-display buffer t)\n    (message \"Symbol %s not resolved\" symbol)))\n\n(defun cider-doc (query)\n  \"Open a window with the docstring for the given QUERY.\nDefaults to the symbol at point.  With prefix arg or no symbol\nunder point, prompts for a var.\"\n  (interactive \"P\")\n  (cider-read-symbol-name \"Symbol: \" 'cider-doc-lookup query))\n\n(defun cider-refresh ()\n  \"Refresh loaded code.\"\n  (interactive)\n  (cider-tooling-eval \"(clojure.tools.namespace.repl/refresh)\"\n                      (cider-interactive-eval-handler (current-buffer))))\n\n;; TODO: implement reloading ns\n(defun cider-eval-load-file (form)\n  \"Load FORM.\"\n  (let ((buffer (current-buffer)))\n    (cider-eval form (cider-interactive-eval-handler buffer))))\n\n(defun cider-file-string (file)\n  \"Read the contents of a FILE and return as a string.\"\n  (with-current-buffer (find-file-noselect file)\n    (substring-no-properties (buffer-string))))\n\n(defun cider-load-file (filename)\n  \"Load the Clojure file FILENAME.\"\n  (interactive (list\n                (read-file-name \"Load file: \" nil nil\n                                nil (if (buffer-file-name)\n                                        (file-name-nondirectory\n                                         (buffer-file-name))))))\n  (remove-overlays (point-min) (point-max) 'cider-note-p t)\n  (cider-send-load-file (cider-file-string filename)\n                        (cider--server-filename filename)\n                        (file-name-nondirectory filename))\n  (message \"Loading %s...\" filename))\n\n(defun cider-load-current-buffer ()\n  \"Load current buffer's file.\"\n  (interactive)\n  (check-parens)\n  (unless buffer-file-name\n    (error \"Buffer %s is not associated with a file\" (buffer-name)))\n  (when (and cider-prompt-save-file-on-load\n             (buffer-modified-p)\n             (y-or-n-p (format \"Save file %s? \" (buffer-file-name))))\n    (save-buffer))\n  (cider-load-file (buffer-file-name)))\n\n;;; interrupt evaluation\n(defun cider-interrupt-handler (buffer)\n  \"Create an interrupt response handler for BUFFER.\"\n  (nrepl-make-response-handler buffer nil nil nil nil))\n\n;;; quiting\n(defun cider--close-buffer (buffer)\n  \"Close the BUFFER and kill its associated process (if any).\"\n  (when (get-buffer-process buffer)\n    (delete-process (get-buffer-process buffer)))\n  (when (get-buffer buffer)\n    (kill-buffer buffer)))\n\n(defvar cider-ancilliary-buffers\n  (list cider-error-buffer\n        cider-doc-buffer\n        cider-test-report-buffer\n        nrepl-message-buffer-name))\n\n(defun cider-close-ancilliary-buffers ()\n  \"Close buffers that are shared across connections.\"\n  (interactive)\n  (dolist (buf-name cider-ancilliary-buffers)\n    (cider--close-buffer buf-name)))\n\n(defun cider-quit ()\n  \"Quit CIDER.\n\nQuitting closes all active nREPL connections and kills all CIDER buffers.\"\n  (interactive)\n  (when (y-or-n-p \"Are you sure you want to quit CIDER? \")\n    (dolist (connection nrepl-connection-list)\n      (when connection\n        (nrepl-close connection)))\n    (message \"All active nREPL connections were closed\")\n    (cider-close-ancilliary-buffers)))\n\n(defun cider-restart (&optional prompt-project)\n  \"Quit CIDER and restart it.\nIf PROMPT-PROJECT is t, then prompt for the project in which to\nrestart the server.\"\n  (interactive \"P\")\n  (cider-quit)\n  ;; Workaround for a nasty race condition https://github.com/clojure-emacs/cider/issues/439\n  ;; TODO: Find a better way to ensure `cider-quit' has finished\n  (message \"Waiting for CIDER to quit...\")\n  (sleep-for 2)\n  (cider-jack-in prompt-project))\n\n(add-hook 'nrepl-connected-hook 'cider-enable-on-existing-clojure-buffers)\n(add-hook 'nrepl-disconnected-hook\n          'cider-possibly-disable-on-existing-clojure-buffers)\n\n(provide 'cider-interaction)\n\n;;; cider-interaction.el ends here\n","markers":{"markers":{"1":{"id":1,"range":[[894,57],[894,57]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":56,"autoscroll":true,"preserveFolds":true,"goalBufferRange":null},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/zk/napplelabs/cider/cider-interaction.el","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"4b4bdaaf854ff42bbe131027637b6352d53be215","deserializer":"TextBuffer"},{"text":";;; cider-client.el --- A layer of abstraction above the actual client code. -*- lexical-binding: t -*-\n\n;; Copyright © 2013-2014 Bozhidar Batsov\n;;\n;; Author: Bozhidar Batsov <bozhidar@batsov.com>\n\n;; This program is free software: you can redistribute it and/or modify\n;; it under the terms of the GNU General Public License as published by\n;; the Free Software Foundation, either version 3 of the License, or\n;; (at your option) any later version.\n\n;; This program is distributed in the hope that it will be useful,\n;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n;; GNU General Public License for more details.\n\n;; You should have received a copy of the GNU General Public License\n;; along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n;; This file is not part of GNU Emacs.\n\n;;; Commentary:\n\n;; A layer of abstraction above the actual client code.\n\n;;; Code:\n\n(require 'nrepl-client)\n\n;;; Words of inspiration\n(defun cider-user-first-name ()\n  \"Find the current user's first name.\"\n  (let ((name (if (string= (user-full-name) \"\")\n                  (user-login-name)\n                (user-full-name))))\n    (string-match \"^[^ ]*\" name)\n    (capitalize (match-string 0 name))))\n\n(defvar cider-words-of-inspiration\n  `(\"The best way to predict the future is to invent it. -Alan Kay\"\n    \"A point of view is worth 80 IQ points. -Alan Kay\"\n    \"Lisp isn't a language, it's a building material. -Alan Kay\"\n    \"Simple things should be simple, complex things should be possible. -Alan Kay\"\n    \"Measuring programming progress by lines of code is like measuring aircraft building progress by weight. -Bill Gates\"\n    \"Controlling complexity is the essence of computer programming. -Brian Kernighan\"\n    \"The unavoidable price of reliability is simplicity. -C.A.R. Hoare\"\n    \"You're bound to be unhappy if you optimize everything. -Donald Knuth\"\n    \"Simplicity is prerequisite for reliability. -Edsger W. Dijkstra\"\n    \"Deleted code is debugged code. -Jeff Sickel\"\n    \"The key to performance is elegance, not battalions of special cases. -Jon Bentley and Doug McIlroy\"\n    \"First, solve the problem. Then, write the code. -John Johnson\"\n    \"Simplicity is the ultimate sophistication. -Leonardo da Vinci\"\n    \"Programming is not about typing... it's about thinking. -Rich Hickey\"\n    \"Design is about pulling things apart. -Rich Hickey\"\n    \"Programmers know the benefits of everything and the tradeoffs of nothing. -Rich Hickey\"\n    \"Code never lies, comments sometimes do. -Ron Jeffries\"\n    \"The true delight is in the finding out rather than in the knowing.  -Isaac Asimov\"\n    \"Take this REPL, fellow hacker, and may it serve you well.\"\n    \"Let the hacking commence!\"\n    \"Hacks and glory await!\"\n    \"Hack and be merry!\"\n    \"Your hacking starts... NOW!\"\n    \"May the Source be with you!\"\n    \"May the Source shine upon thy REPL!\"\n    \"Code long and prosper!\"\n    \"Happy hacking!\"\n    \"nREPL server is up, REPL is operational!\"\n    \"Your imagination is the only limit to what you can do with this REPL!\"\n    \"This REPL is yours to command!\"\n    \"Fame is but a hack away!\"\n    ,(format \"%s, this could be the start of a beautiful program.\"\n             (cider-user-first-name)))\n  \"Scientifically-proven optimal words of hackerish encouragement.\")\n\n(defun cider-random-words-of-inspiration ()\n  \"Select a random entry from `cider-words-of-inspiration'.\"\n  (eval (nth (random (length cider-words-of-inspiration))\n             cider-words-of-inspiration)))\n\n(defun cider-display-connected-message ()\n  \"Message displayed on successful connection.\"\n  (message \"Connected.  %s\" (cider-random-words-of-inspiration)))\n\n(add-hook 'nrepl-connected-hook 'cider-display-connected-message)\n\n;;; Evaluation helpers\n(defun cider-ns-form-p (form)\n  \"Check if FORM is an ns form.\"\n  (string-match \"^[[:space:]]*\\(ns\\\\([[:space:]]*$\\\\|[[:space:]]+\\\\)\" form))\n\n(defun cider-eval (input callback &optional ns session)\n  \"Send the request INPUT and register the CALLBACK as the response handler.\nNS & SESSION specify the context in which to evaluate the request.\"\n  ;; namespace forms are always evaluated in the \"user\" namespace\n  (let ((ns (if (cider-ns-form-p input)\n                \"user\"\n              ns)))\n    ;; prevent forms from being evaluated in the wrong or a non-existing namespace\n    (when (and ns\n               (derived-mode-p 'clojure-mode)\n               (not (string= ns nrepl-buffer-ns))\n               (not (cider-ns-form-p input)))\n      (cider-eval-ns-form))\n    (nrepl-send-string input callback ns session)))\n\n(defun cider-tooling-eval (input callback &optional ns)\n  \"Send the request INPUT and register the CALLBACK as the response handler.\nNS specifies the namespace in which to evaluate the request.\"\n  ;; namespace forms are always evaluated in the \"user\" namespace\n  (cider-eval input callback ns (nrepl-current-tooling-session)))\n\n(defun cider-eval-sync (input &optional ns session)\n  \"Send the INPUT to the nREPL server synchronously.\nNS & SESSION specify the evaluation context.\"\n  (nrepl-send-string-sync input ns session))\n\n(defun cider-eval-and-get-value (input &optional ns session)\n  \"Send the INPUT to the nREPL server synchronously and return the value.\nNS & SESSION specify the evaluation context.\"\n  (cider-get-value (cider-eval-sync input ns session)))\n\n(defun cider-tooling-eval-sync (input &optional ns)\n  \"Send the INPUT to the nREPL server using a tooling session synchronously.\nNS specifies the namespace in which to evaluate the request.\"\n  (cider-eval-sync input ns (nrepl-current-tooling-session)))\n\n(defun cider-get-raw-value (eval-result)\n  \"Get the raw value (as string) from EVAL-RESULT.\"\n  (plist-get eval-result :value))\n\n(defun cider-get-value (eval-result)\n  \"Get the value from EVAL-RESULT.\"\n  (read (cider-get-raw-value eval-result)))\n\n(defun cider-send-op (op attributes handler)\n  \"Send the specified OP with ATTRIBUTES and response HANDLER.\"\n  (nrepl-send-request (append\n                       (list \"op\" op\n                             \"session\" (nrepl-current-session)\n                             \"ns\" nrepl-buffer-ns)\n                       attributes)\n                      handler))\n\n(defun cider-send-load-file (file-contents file-path file-name)\n  \"Perform the nREPL \\\"load-file\\\" op.\nFILE-CONTENTS, FILE-PATH and FILE-NAME are details of the file to be\nloaded.\"\n  (let ((buffer (current-buffer)))\n    (nrepl-send-request (list \"op\" \"load-file\"\n                              \"session\" (nrepl-current-session)\n                              \"file\" file-contents\n                              \"file-path\" file-path\n                              \"file-name\" file-name)\n                        (cider-load-file-handler buffer))))\n\n(defun cider-interrupt ()\n  \"Interrupt any pending evaluations.\"\n  (interactive)\n  (let ((pending-request-ids (cider-util--hash-keys nrepl-pending-requests)))\n    (dolist (request-id pending-request-ids)\n      (nrepl-send-interrupt request-id (cider-interrupt-handler (current-buffer))))))\n\n(defun cider-current-repl-buffer ()\n  \"The current REPL buffer.\"\n  (when (nrepl-current-connection-buffer)\n    (buffer-local-value 'nrepl-repl-buffer\n                        (get-buffer (nrepl-current-connection-buffer)))))\n\n(defun cider--dict-to-alist (val)\n  \"Transforms a nREPL bdecoded dict VAL into an alist.\nSimply returns it if it's not a dict.\"\n  (if (and (listp val)\n           (eq (car val) 'dict))\n      (-map '-cons-to-list (cdr val))\n    val))\n\n(defun cider--dict-to-plist (val)\n  \"Transforms a nREPL bdecoded dict VAL into a plist with symbol keys.\nSimply returns it if it's not a dict.\"\n  (if (and (listp val)\n           (eq (car val) 'dict))\n      (-interleave (-map 'intern (-map 'car (cdr val)))\n                   (-map 'cdr (cdr val)))\n    val))\n\n(defun cider--var-choice (var-info)\n  \"Prompt to choose from among multiple VAR-INFO candidates, if required.\nThis is needed only when the symbol queried is an unqualified host platform\nmethod, and multiple classes have a so-named member.  If VAR-INFO does not\ncontain a `candidates' key, it is returned as is.\"\n  (let ((candidates (cdadr (assoc \"candidates\" var-info))))\n    (if candidates\n        (let* ((classes (mapcar (lambda (x) (cdr (assoc \"class\" x))) candidates))\n               (choice (completing-read \"Member in class: \" classes nil t))\n               (info (cdr (assoc choice candidates))))\n          (cider--dict-to-alist info))\n      var-info)))\n\n(defun cider-var-info (var &optional all)\n  \"Return VAR's info as an alist with list cdrs.\n\nWhen multiple matching vars are returned you'll be prompted to select one,\nunless ALL is truthy.\"\n  (when var\n    (let ((val (plist-get (nrepl-send-request-sync\n                           (list \"op\" \"info\"\n                                 \"session\" (nrepl-current-session)\n                                 \"ns\" (cider-current-ns)\n                                 \"symbol\" var))\n                          :value)))\n      (if all\n          (cider--dict-to-alist val)\n        (cider--var-choice\n         (cider--dict-to-alist val))))))\n\n(defun cider-member-info (class member)\n  \"Return the CLASS MEMBER's info as an alist with list cdrs.\"\n  (when (and class member)\n    (let ((val (plist-get (nrepl-send-request-sync\n                           (list \"op\" \"info\"\n                                 \"session\" (nrepl-current-session)\n                                 \"class\" class\n                                 \"member\" member))\n                          :value)))\n      (cider--dict-to-alist val))))\n\n(defun cider-get-var-attr (var-info attr)\n  \"Return VAR-INFO's ATTR.\"\n  (cadr (assoc attr var-info)))\n\n(provide 'cider-client)\n\n;;; cider-client.el ends here\n","markers":{"markers":{"1":{"id":1,"range":[[220,36],[220,36]],"tailed":false,"reversed":true,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":113,"autoscroll":true,"goalBufferRange":null,"preserveFolds":true},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/zk/napplelabs/cider/cider-client.el","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"6906a39f510669acaa747f88c93a1e52ed3a2223","deserializer":"TextBuffer"},{"text":";;; nrepl-client.el --- Client for Clojure nREPL -*- lexical-binding: t -*-\n\n;; Copyright © 2012-2014 Tim King, Phil Hagelberg\n;; Copyright © 2013-2014 Bozhidar Batsov, Hugo Duncan, Steve Purcell\n;;\n;; Author: Tim King <kingtim@gmail.com>\n;;         Phil Hagelberg <technomancy@gmail.com>\n;;         Bozhidar Batsov <bozhidar@batsov.com>\n;;         Hugo Duncan <hugo@hugoduncan.org>\n;;         Steve Purcell <steve@sanityinc.com>\n\n;; This program is free software: you can redistribute it and/or modify\n;; it under the terms of the GNU General Public License as published by\n;; the Free Software Foundation, either version 3 of the License, or\n;; (at your option) any later version.\n\n;; This program is distributed in the hope that it will be useful,\n;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n;; GNU General Public License for more details.\n\n;; You should have received a copy of the GNU General Public License\n;; along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n;; This file is not part of GNU Emacs.\n\n;;; Commentary:\n\n;; Provides an Emacs Lisp client to connect to Clojure nREPL servers.\n\n;;; Code:\n(require 'clojure-mode)\n(require 'dash)\n(require 'thingatpt)\n(require 'etags)\n(require 'ansi-color)\n(require 'ewoc)\n(require 'cl-lib)\n(require 'cider-util)\n\n\f\n(defgroup nrepl nil\n  \"Interaction with the Clojure nREPL Server.\"\n  :prefix \"nrepl-\"\n  :group 'applications)\n\n(defcustom nrepl-buffer-name-separator \" \"\n  \"Used in constructing the REPL buffer name.\nThe `nrepl-buffer-name-separator' separates cider-repl from the project name.\"\n  :type '(string)\n  :group 'nrepl)\n\n(defcustom nrepl-buffer-name-show-port nil\n  \"Show the connection port in the nrepl REPL buffer name, if set to t.\"\n  :type 'boolean\n  :group 'nrepl)\n\n(defcustom nrepl-connected-hook nil\n  \"List of functions to call when connecting to the nREPL server.\"\n  :type 'hook\n  :group 'nrepl)\n\n(defcustom nrepl-disconnected-hook nil\n  \"List of functions to call when disconnected from the nREPL server.\"\n  :type 'hook\n  :group 'nrepl)\n\n(defcustom nrepl-file-loaded-hook nil\n  \"List of functions to call when a load file has completed.\"\n  :type 'hook\n  :group 'nrepl)\n\n(defcustom nrepl-host \"127.0.0.1\"\n  \"The default hostname (or IP address) to connect to.\"\n  :type 'string\n  :group 'nrepl)\n\n(defcustom nrepl-port nil\n  \"The default port to connect to.\"\n  :type 'string\n  :group 'nrepl)\n\n(defcustom nrepl-sync-request-timeout 10\n  \"The number of seconds to wait for a sync response.\nSetting this to nil disables the timeout functionality.\"\n  :type 'integer\n  :group 'nrepl)\n\n(defcustom nrepl-connection-endpoint\n  'nrepl-connection-ssh-tunnel\n  \"A function that is called to determine command that will be run\nonce an nrepl server process is running. Used to set up an ssh tunnel\non remote connections.\n\nThe arguments are dir and port. The return value\nshould be an `plist` of the form\n(:proc-buffer-name \\\"*buf*\\\" :hostname \\\"hostname\\\" :port 1234)\"\n  :type 'function\n  :group 'nrepl)\n\n(defvar-local nrepl-connection-buffer nil)\n(defvar-local nrepl-server-buffer nil)\n(defvar-local nrepl-repl-buffer nil)\n(defvar-local nrepl-endpoint nil)\n(defvar-local nrepl-project-dir nil)\n(defvar-local nrepl-on-connection-buffer nil)\n\n(defconst nrepl-repl-buffer-name-template \"*cider-repl%s*\")\n(defconst nrepl-connection-buffer-name-template \"*nrepl-connection%s*\")\n(defconst nrepl-server-buffer-name-template \"*nrepl-server%s*\")\n(defconst nrepl-on-connection-buffer-name-template \"*nrepl-on-connection%s*\")\n\n(defcustom nrepl-hide-special-buffers nil\n  \"Control the display of some special buffers in buffer switching commands.\nWhen true some special buffers like the connection and the server\nbuffer will be hidden.\")\n\n(defun nrepl-apply-hide-special-buffers (buffer-name)\n  \"Apply a prefix to BUFFER-NAME that will hide the buffer.\"\n  (concat (if nrepl-hide-special-buffers \" \" \"\") buffer-name))\n\n(defun nrepl-format-buffer-name-template (buffer-name-template designation)\n  \"Apply the DESIGNATION to the corresponding BUFFER-NAME-TEMPLATE.\"\n  (format buffer-name-template\n          (if (> (length designation) 0)\n              (concat nrepl-buffer-name-separator designation)\n            \"\")))\n\n(defun nrepl-buffer-name (buffer-name-template)\n  \"Generate a buffer name using BUFFER-NAME-TEMPLATE.\n\nThe name will include the project name if available or the\nendpoint host if it is not.  The name will also include the\nconnection port if `nrepl-buffer-name-show-port' is true.\"\n  (generate-new-buffer-name\n   (let ((project-name (nrepl--project-name nrepl-project-dir))\n         (nrepl-proj-port (cadr nrepl-endpoint)))\n     (nrepl-format-buffer-name-template\n      buffer-name-template\n      (concat (if project-name project-name (car nrepl-endpoint))\n              (if (and nrepl-proj-port nrepl-buffer-name-show-port)\n                  (format \":%s\" nrepl-proj-port) \"\"))))))\n\n(defun nrepl-connection-buffer-name ()\n  \"Return the name of the connection buffer.\"\n  (nrepl-apply-hide-special-buffers\n   (nrepl-buffer-name nrepl-connection-buffer-name-template)))\n\n(defun nrepl-server-buffer-name ()\n  \"Return the name of the server buffer.\"\n  (nrepl-apply-hide-special-buffers\n   (nrepl-buffer-name nrepl-server-buffer-name-template)))\n\n(defun nrepl-on-connection-buffer-name ()\n  \"Return the name of the on-connection buffer.\"\n  (nrepl-apply-hide-special-buffers\n   (nrepl-buffer-name nrepl-on-connection-buffer-name-template)))\n\n;; buffer local declarations\n(defvar-local nrepl-session nil\n  \"Current nREPL session id.\")\n\n(defvar-local nrepl-tooling-session nil\n  \"Current nREPL tooling session id.\nTo be used for tooling calls (i.e. completion, eldoc, etc)\")\n\n(defvar-local nrepl-request-counter 0\n  \"Continuation serial number counter.\")\n\n(defvar-local nrepl-pending-requests (make-hash-table :test 'equal))\n\n(defvar-local nrepl-completed-requests (make-hash-table :test 'equal))\n\n(defvar-local nrepl-buffer-ns \"user\"\n  \"Current Clojure namespace of this buffer.\")\n\n(defvar-local nrepl-sync-response nil\n  \"Result of the last sync request.\")\n\n(defvar-local nrepl-sync-request-start-time nil\n  \"The time when the last sync request was initiated.\")\n\n(defvar nrepl-err-handler 'cider-default-err-handler\n  \"Evaluation error handler.\")\n\n(defvar-local nrepl-ops nil\n  \"Available nREPL server ops (from describe).\")\n\n;;; Bencode\n;;; Adapted from http://www.emacswiki.org/emacs-en/bencode.el\n;;; and modified to work with utf-8\n(defun nrepl-bdecode-buffer ()\n  \"Decode a bencoded string in the current buffer starting at point.\"\n  (cond ((looking-at \"i\\\\(-?[0-9]+\\\\)e\")\n         (goto-char (match-end 0))\n         (string-to-number (match-string 1)))\n        ((looking-at \"\\\\([0-9]+\\\\):\")\n         (goto-char (match-end 0))\n         (let ((start (point))\n               (end (byte-to-position (+ (position-bytes (point))\n                                         (string-to-number (match-string 1))))))\n           (goto-char end)\n           (buffer-substring start end)))\n        ((looking-at \"l\")\n         (goto-char (match-end 0))\n         (let (result item)\n           ;; check for the end sentinel, setq returns the value\n           (while (not (eq :end (setq item (nrepl-bdecode-buffer))))\n             (setq result (cons item result)))\n           (nreverse result)))\n        ((looking-at \"d\")\n         (goto-char (match-end 0))\n         (let (dict key item)\n           ;; check for the end sentinel, setq returns the value\n           (while (not (eq :end (setq item (nrepl-bdecode-buffer))))\n             (if key\n                 (setq dict (cons (cons key item) dict)\n                       key nil)\n               (unless (stringp item)\n                 (error \"Dictionary keys have to be strings: %s\" item))\n               (setq key item)))\n           (cons 'dict (nreverse dict))))\n        ((looking-at \"e\")\n         (goto-char (match-end 0))\n         ;; This line used to return nil and checks above checked for\n         ;; falsiness to indicate the end of a list/dict, but that\n         ;; meant that nil/() was unable to pass through without\n         ;; shorting the algorithm. Now we return an :end keyword\n         ;; as a sentinel value and check for equality.\n         :end)\n        (t\n         (error \"Cannot decode message: %s\" (buffer-substring (point-min) (point-max))))))\n\n(defun nrepl-decode (str)\n  \"Decode bencoded STR.\"\n  (with-temp-buffer\n    (save-excursion\n      (insert str))\n    (let ((result '()))\n      (while (not (eobp))\n        (setq result (cons (nrepl-bdecode-buffer) result)))\n      (nreverse result))))\n\n(defun nrepl-netstring (val)\n  \"Encode VAL in bencode.\"\n  (cond\n   ((integerp val) (format \"i%de\" val))\n   ((listp val)    (format \"l%se\" (apply 'concat (-map 'nrepl-netstring val))))\n   (t              (format \"%s:%s\" (string-bytes val) val))))\n\n(defun nrepl-bencode (message)\n  \"Encode with bencode MESSAGE.\"\n  (concat \"d\" (apply 'concat (mapcar 'nrepl-netstring message)) \"e\"))\n\n;;; Response handlers\n(defmacro nrepl-dbind-response (response keys &rest body)\n  \"Destructure an nREPL RESPONSE dict.\nBind the value of the provided KEYS and execute BODY.\"\n  `(let ,(loop for key in keys\n               collect `(,key (cdr (assoc ,(format \"%s\" key) ,response))))\n     ,@body))\n\n(put 'nrepl-dbind-response 'lisp-indent-function 2)\n\n(defun nrepl-make-response-handler\n  (buffer value-handler stdout-handler stderr-handler done-handler\n          &optional eval-error-handler)\n  \"Make a response handler for BUFFER.\nUses the specified VALUE-HANDLER, STDOUT-HANDLER, STDERR-HANDLER,\nDONE-HANDLER, and EVAL-ERROR-HANDLER as appropriate.\"\n  (lambda (response)\n    (nrepl-dbind-response response (value ns out err status id ex root-ex\n                                          session)\n      (cond (value\n             (with-current-buffer buffer\n               (when ns (setq nrepl-buffer-ns ns)))\n             (when value-handler\n               (funcall value-handler buffer value)))\n            (out\n             (when stdout-handler\n               (funcall stdout-handler buffer out)))\n            (err\n             (when stderr-handler\n               (funcall stderr-handler buffer err)))\n            (status\n             (when (member \"interrupted\" status)\n               (message \"Evaluation interrupted.\"))\n             (when (member \"eval-error\" status)\n               (funcall (or eval-error-handler nrepl-err-handler)\n                        buffer ex root-ex session))\n             (when (member \"namespace-not-found\" status)\n               (message \"Namespace not found.\"))\n             (when (member \"need-input\" status)\n               (cider-need-input buffer))\n             (when (member \"done\" status)\n               (puthash id (gethash id nrepl-pending-requests) nrepl-completed-requests)\n               (remhash id nrepl-pending-requests)\n               (when done-handler\n                 (funcall done-handler buffer))))))))\n\n;;; communication\n(defun nrepl-default-handler (response)\n  \"Default handler which is invoked when no handler is found.\nHandles message contained in RESPONSE.\"\n  (nrepl-dbind-response response (out _value)\n    (cider-repl-emit-interactive-output out)))\n\n(defun nrepl-dispatch (response)\n  \"Dispatch the RESPONSE to associated callback.\n\nFirst we check the list of pending requests for the callback to invoke\nand afterwards we check the completed requests as well, since responses\ncould be received even for requests with status \\\"done\\\".\"\n  (nrepl-log-message response)\n  (nrepl-dbind-response response (id)\n    (let ((callback (or (gethash id nrepl-pending-requests)\n                        (gethash id nrepl-completed-requests))))\n      (if callback\n          (funcall callback response)\n        (nrepl-default-handler response)))))\n\n(defun nrepl-decode-current-buffer ()\n  \"Decode the data in the current buffer.\nRemove the processed data from the buffer if the decode successful.\"\n  (let* ((start (point-min))\n         (end (point-max))\n         (data (buffer-substring-no-properties start end)))\n    (prog1\n        (nrepl-decode data)\n      (delete-region start end))))\n\n(defun nrepl-handle-process-output (process)\n  \"Handle all complete messages from PROCESS.\"\n  (with-current-buffer (process-buffer process)\n    (let ((nrepl-connection-dispatch (current-buffer)))\n      ;; FIXME: An ugly fix for https://github.com/clojure-emacs/cider/issues/583\n      (while (and (not (derived-mode-p 'cider-repl-mode)) (> (buffer-size) 1))\n        (let ((responses (nrepl-decode-current-buffer)))\n          (dolist (r responses)\n            (nrepl-dispatch r)))))))\n\n(defvar nrepl-decode-timeout 0.01\n  \"Seconds to wait before decoding nREPL output.\")\n\n(defun nrepl-net-filter (process string)\n  \"Decode the message(s) from PROCESS contained in STRING and dispatch.\"\n  (with-current-buffer (process-buffer process)\n    (goto-char (point-max))\n    (insert string))\n  ;; end of the dict maybe?\n  (when (eq ?e (aref string (1- (length string))))\n    ;; wait a bit to make sure we are at the real end\n    (unless (accept-process-output process nrepl-decode-timeout)\n      (nrepl-handle-process-output process))))\n\n(defun nrepl-sentinel (process message)\n  \"Handle sentinel events from PROCESS.\nDisplay MESSAGE and if the process is closed kill the\nprocess buffer and run the hook `nrepl-disconnected-hook'.\"\n  (message \"nREPL connection closed: %s\" message)\n  (if (equal (process-status process) 'closed)\n      (progn\n        (with-current-buffer (process-buffer process)\n          (when (get-buffer nrepl-repl-buffer)\n            (kill-buffer nrepl-repl-buffer))\n          (kill-buffer (current-buffer)))\n        (run-hooks 'nrepl-disconnected-hook))))\n\n(defun nrepl-write-message (process message)\n  \"Send the PROCESS the MESSAGE.\"\n  (process-send-string process message))\n\n;;; Log nREPL messages\n\n(defconst nrepl-message-buffer-name \"*nrepl-messages*\"\n  \"Buffer for nREPL message logging.\")\n\n(defcustom nrepl-log-messages nil\n  \"Log protocol messages to the `nrepl-message-buffer-name' buffer.\"\n  :type 'boolean\n  :group 'nrepl)\n\n(define-obsolete-variable-alias 'nrepl-log-events 'nrepl-log-messages \"0.7.0\")\n\n(defconst nrepl-message-buffer-max-size 1000000\n  \"Maximum size for the nREPL message buffer.\nDefaults to 1000000 characters, which should be an insignificant\nmemory burden, while providing reasonable history.\")\n\n(defconst nrepl-message-buffer-reduce-denominator 4\n  \"Divisor by which to reduce message buffer size.\nWhen the maximum size for the nREPL message buffer is exceed, the\nsize of the buffer is reduced by one over this value.  Defaults\nto 4, so that 1/4 of the buffer is removed, which should ensure\nthe buffer's maximum is reasonably utilised, while limiting the\nnumber of buffer shrinking operations.\")\n\n(defun nrepl-log-message (msg)\n  \"Log the given MSG to the buffer given by `nrepl-message-buffer-name'.\"\n  (when nrepl-log-messages\n    (with-current-buffer (nrepl-messages-buffer)\n      (when (> (buffer-size) nrepl-message-buffer-max-size)\n        (goto-char (/ (buffer-size) nrepl-message-buffer-reduce-denominator))\n        (re-search-forward \"^(\" nil t)\n        (delete-region (point-min) (- (point) 1)))\n      (goto-char (point-max))\n      (pp msg (current-buffer)))))\n\n(defun nrepl-messages-buffer ()\n  \"Return or create the buffer given by `nrepl-message-buffer-name'.\nThe default buffer name is *nrepl-messages*.\"\n  (or (get-buffer nrepl-message-buffer-name)\n      (let ((buffer (get-buffer-create nrepl-message-buffer-name)))\n        (with-current-buffer buffer\n          (buffer-disable-undo)\n          (setq-local comment-start \";\")\n          (setq-local comment-end \"\"))\n        buffer)))\n\n(defun nrepl-log-messages (&optional disable)\n  \"Turn on message logging to `nrepl-message-buffer-name'.\nWith a prefix argument DISABLE, turn it off.\"\n  (interactive \"P\")\n  (if disable\n      (message \"nREPL message logging disabled\")\n    (message \"nREPL message logging enabled\"))\n  (setq nrepl-log-messages (not disable)))\n\n(define-obsolete-function-alias 'nrepl-log-events 'nrepl-log-messages \"0.7.0\")\n\n\f\n;;; Connections\n\n;;; A connection is the communication between the nrepl.el client and an nrepl\n;;; server.\n\n(defvar nrepl-connection-dispatch nil\n  \"Bound to the connection a message was received on.\nThis is bound for the duration of the handling of that message\")\n\n(defvar nrepl-connection-list nil\n  \"A list of connections.\")\n\n\n(defun nrepl-current-host ()\n  \"Retrieve the current host.\"\n  (if (and (stringp buffer-file-name)\n           (file-remote-p buffer-file-name))\n      tramp-current-host\n    nrepl-host))\n\n(defun nrepl-make-connection-buffer ()\n  \"Create an nREPL connection buffer.\"\n  (let ((buffer (generate-new-buffer (nrepl-connection-buffer-name))))\n    (with-current-buffer buffer\n      (buffer-disable-undo)\n      (setq-local kill-buffer-query-functions nil))\n    buffer))\n\n(defun nrepl-current-connection-buffer ()\n  \"The connection to use for nREPL interaction.\"\n  (or nrepl-connection-dispatch\n      nrepl-connection-buffer\n      (car (nrepl-connection-buffers))\n      (error \"No nREPL connection\")))\n\n(defun nrepl-connection-buffers ()\n  \"Clean up dead buffers from the `nrepl-connection-list'.\nReturn the connection list.\"\n  (nrepl--connection-list-purge)\n  nrepl-connection-list)\n\n(defun nrepl--connection-list-purge ()\n  \"Clean up dead buffers from the `nrepl-connection-list'.\"\n  (setq nrepl-connection-list\n        (-remove (lambda (buffer)\n                   (not (buffer-live-p (get-buffer buffer))))\n                 nrepl-connection-list)))\n\n(defun nrepl-make-repl-connection-default (connection-buffer)\n  \"Make the nREPL CONNECTION-BUFFER the default connection.\nMoves CONNECITON-BUFFER to the front of `nrepl-connection-list'.\"\n  (interactive (list nrepl-connection-buffer))\n  (if connection-buffer\n      ;; maintain the connection list in most recently used order\n      (let ((buf-name (buffer-name (get-buffer connection-buffer))))\n        (setq nrepl-connection-list\n              (cons buf-name (delq buf-name nrepl-connection-list)))\n        (nrepl--connections-refresh))\n    (message \"Not in an nREPL REPL buffer.\")))\n\n(defun nrepl--close-connection-buffer (connection-buffer)\n  \"Closes CONNECTION-BUFFER, removing it from `nrepl-connection-list'.\nAlso closes associated REPL and server buffers.\"\n  (let ((nrepl-connection-dispatch connection-buffer))\n     (let ((buffer (get-buffer connection-buffer)))\n       (setq nrepl-connection-list\n             (delq (buffer-name buffer) nrepl-connection-list))\n       (when (buffer-live-p buffer)\n         (dolist (buf-name `(,(buffer-local-value 'nrepl-repl-buffer buffer)\n                             ,(buffer-local-value 'nrepl-server-buffer buffer)\n                             ,(buffer-local-value\n                               'nrepl-on-connection-buffer buffer)\n                             ,buffer))\n           (when buf-name\n             (cider--close-buffer buf-name)))))))\n\n;;; Connection browser\n(defvar nrepl-connections-buffer-mode-map\n  (let ((map (make-sparse-keymap)))\n    (define-key map \"d\" 'nrepl-connections-make-default)\n    (define-key map \"g\" 'nrepl-connection-browser)\n    (define-key map (kbd \"C-k\") 'nrepl-connections-close-connection)\n    (define-key map (kbd \"RET\") 'nrepl-connections-goto-connection)\n    map))\n\n(define-derived-mode nrepl-connections-buffer-mode cider-popup-buffer-mode\n  \"nREPL-Connections\"\n  \"nREPL Connections Buffer Mode.\n\\\\{nrepl-connections-buffer-mode-map}\n\\\\{cider-popup-buffer-mode-map}\"\n  (setq-local truncate-lines t))\n\n(defvar nrepl--connection-ewoc)\n(defconst nrepl--connection-browser-buffer-name \"*nrepl-connections*\")\n\n(defun nrepl-connection-browser ()\n  \"Open a browser buffer for nREPL connections.\"\n  (interactive)\n  (let ((buffer (get-buffer nrepl--connection-browser-buffer-name)))\n    (if buffer\n        (progn\n          (nrepl--connections-refresh-buffer buffer)\n          (unless (get-buffer-window buffer)\n            (select-window (display-buffer buffer))))\n      (nrepl--setup-connection-browser))))\n\n(defun nrepl--connections-refresh ()\n  \"Refresh the connections buffer, if the buffer exists.\nThe connections buffer is determined by\n`nrepl--connection-browser-buffer-name'\"\n  (let ((buffer (get-buffer nrepl--connection-browser-buffer-name)))\n    (when buffer\n      (nrepl--connections-refresh-buffer buffer))))\n\n(defun nrepl--connections-refresh-buffer (buffer)\n  \"Refresh the connections BUFFER.\"\n  (nrepl--update-connections-display\n   (buffer-local-value 'nrepl--connection-ewoc buffer)\n   nrepl-connection-list))\n\n(defun nrepl--setup-connection-browser ()\n  \"Create a browser buffer for nREPL connections.\"\n  (with-current-buffer (get-buffer-create nrepl--connection-browser-buffer-name)\n    (let ((ewoc (ewoc-create\n                         'nrepl--connection-pp\n                         \"  Host              Port   Project\\n\")))\n      (setq-local nrepl--connection-ewoc ewoc)\n      (nrepl--update-connections-display ewoc nrepl-connection-list)\n      (setq buffer-read-only t)\n      (nrepl-connections-buffer-mode)\n      (display-buffer (current-buffer)))))\n\n(defun nrepl--connection-pp (connection)\n  \"Print an nREPL CONNECTION to the current buffer.\"\n  (let* ((buffer-read-only nil)\n                 (buffer (get-buffer connection))\n                 (endpoint (buffer-local-value 'nrepl-endpoint buffer)))\n    (insert\n     (format \"%s %-16s %5s   %s\"\n             (if (equal connection (car nrepl-connection-list)) \"*\" \" \")\n             (car endpoint)\n             (prin1-to-string (cadr endpoint))\n             (or (nrepl--project-name\n                  (buffer-local-value 'nrepl-project-dir buffer))\n                 \"\")))))\n\n(defun nrepl--project-name (path)\n  \"Extracts a project name from PATH, possibly nil.\nThe project name is the final component of PATH if not nil.\"\n  (when path\n    (file-name-nondirectory (directory-file-name path))))\n\n(defun nrepl--update-connections-display (ewoc connections)\n  \"Update the connections EWOC to show CONNECTIONS.\"\n  (ewoc-filter ewoc (lambda (n) (member n connections)))\n  (let ((existing))\n    (ewoc-map (lambda (n) (setq existing (cons n existing))) ewoc)\n    (let ((added (-difference connections existing)))\n      (mapc (apply-partially 'ewoc-enter-last ewoc) added)\n      (save-excursion (ewoc-refresh ewoc)))))\n\n(defun nrepl--ewoc-apply-at-point (f)\n  \"Apply function F to the ewoc node at point.\nF is a function of two arguments, the ewoc and the data at point.\"\n  (let* ((ewoc nrepl--connection-ewoc)\n                 (node (and ewoc (ewoc-locate ewoc))))\n    (when node\n      (funcall f ewoc (ewoc-data node)))))\n\n(defun nrepl-connections-make-default ()\n  \"Make default the connection at point in the connection browser.\"\n  (interactive)\n  (save-excursion\n    (nrepl--ewoc-apply-at-point #'nrepl--connections-make-default)))\n\n(defun nrepl--connections-make-default (ewoc data)\n  \"Make the connection in EWOC specified by DATA default.\nRefreshes EWOC.\"\n  (interactive)\n  (nrepl-make-repl-connection-default data)\n  (ewoc-refresh ewoc))\n\n(defun nrepl-connections-close-connection ()\n  \"Close connection at point in the connection browser.\"\n  (interactive)\n  (nrepl--ewoc-apply-at-point #'nrepl--connections-close-connection))\n\n(defun nrepl--connections-close-connection (ewoc data)\n  \"Close the connection in EWOC specified by DATA.\"\n  (nrepl-close (get-buffer data))\n  (nrepl--update-connections-display ewoc nrepl-connection-list))\n\n(defun nrepl-connections-goto-connection ()\n  \"Goto connection at point in the connection browser.\"\n  (interactive)\n  (nrepl--ewoc-apply-at-point #'nrepl--connections-goto-connection))\n\n(defun nrepl--connections-goto-connection (_ewoc data)\n  \"Goto the REPL for the connection in _EWOC specified by DATA.\"\n  (let ((buffer (buffer-local-value 'nrepl-repl-buffer (get-buffer data))))\n    (when buffer\n      (select-window (display-buffer buffer)))))\n\n;;; server messages\n\n(defun nrepl-current-session ()\n  \"Return the current session.\"\n  (with-current-buffer (nrepl-current-connection-buffer)\n    nrepl-session))\n\n(defun nrepl-current-tooling-session ()\n  \"Return the current tooling session.\"\n  (with-current-buffer (nrepl-current-connection-buffer)\n    nrepl-tooling-session))\n\n(defun nrepl-next-request-id ()\n  \"Return the next request id.\"\n  (with-current-buffer (nrepl-current-connection-buffer)\n    (number-to-string (cl-incf nrepl-request-counter))))\n\n(defun nrepl-send-request (request callback)\n  \"Send REQUEST and register response handler CALLBACK.\"\n  (let* ((request-id (nrepl-next-request-id))\n         (request (append (list \"id\" request-id) request))\n         (message (nrepl-bencode request)))\n    (nrepl-log-message request)\n    (puthash request-id callback nrepl-pending-requests)\n    (nrepl-write-message (nrepl-current-connection-buffer) message)))\n\n(defun nrepl-create-client-session (callback)\n  \"Sent a request to create a new client session.\nResponse will be handled by CALLBACK.\"\n  (nrepl-send-request '(\"op\" \"clone\")\n                      callback))\n\n(defun nrepl-send-stdin (input callback)\n  \"Send a stdin message with INPUT.\nRegister CALLBACK as the response handler.\"\n  (nrepl-send-request (list \"op\" \"stdin\"\n                            \"stdin\" input\n                            \"session\" (nrepl-current-session))\n                      callback))\n\n(defun nrepl-send-interrupt (pending-request-id callback)\n  \"Send an interrupt message for PENDING-REQUEST-ID.\nRegister CALLBACK as the response handler.\"\n  (nrepl-send-request (list \"op\" \"interrupt\"\n                            \"session\" (nrepl-current-session)\n                            \"interrupt-id\" pending-request-id)\n                      callback))\n\n(defun nrepl-eval-request (input &optional ns session)\n  \"Send a request to eval INPUT.\nIf NS is non-nil, include it in the request.\nUse SESSION if it is non-nil, otherwise use the current session.\"\n  (append (if ns (list \"ns\" ns))\n          (list\n           \"op\" \"eval\"\n           \"session\" (or session (nrepl-current-session))\n           \"code\" input)))\n\n(defun nrepl-send-string (input callback &optional ns session)\n  \"Send the request INPUT and register the CALLBACK as the response handler.\nSee command `nrepl-eval-request' for details on how NS and SESSION are processed.\"\n  (nrepl-send-request (nrepl-eval-request input ns session) callback))\n\n(defun nrepl-sync-request-handler (buffer)\n  \"Make a synchronous request handler for BUFFER.\"\n  (nrepl-make-response-handler buffer\n                               (lambda (_buffer value)\n                                 (setq nrepl-sync-response\n                                       (plist-put nrepl-sync-response :value value)))\n                               (lambda (_buffer out)\n                                 (let ((so-far (plist-get nrepl-sync-response :stdout)))\n                                   (setq nrepl-sync-response\n                                         (plist-put nrepl-sync-response\n                                                    :stdout (concat so-far out)))))\n                               (lambda (_buffer err)\n                                 (let ((so-far (plist-get nrepl-sync-response :stderr)))\n                                   (setq nrepl-sync-response\n                                         (plist-put nrepl-sync-response\n                                                    :stderr (concat so-far err)))))\n                               (lambda (_buffer)\n                                 (setq nrepl-sync-response\n                                       (plist-put nrepl-sync-response :done t)))))\n\n(defun nrepl-send-request-sync (request)\n  \"Send REQUEST to the nREPL server synchronously (discouraged).\nThe result is a plist with keys :value, :stderr and :stdout.\"\n  (with-current-buffer (nrepl-current-connection-buffer)\n    (setq nrepl-sync-response nil)\n    (setq nrepl-sync-request-start-time (current-time))\n    (nrepl-send-request request (nrepl-sync-request-handler (current-buffer)))\n    (while (or (null nrepl-sync-response)\n               (null (plist-get nrepl-sync-response :done)))\n      (accept-process-output nil 0.005)\n      ;; break out in case we don't receive a response for a while\n      (when nrepl-sync-request-timeout\n        (let ((seconds-ellapsed (cadr (time-subtract (current-time) nrepl-sync-request-start-time))))\n          (if (> seconds-ellapsed nrepl-sync-request-timeout)\n              (keyboard-quit)))))\n    nrepl-sync-response))\n\n(defun nrepl-send-string-sync (input &optional ns session)\n  \"Send the INPUT to the nREPL server synchronously.\nSee command `nrepl-eval-request' for details about how NS and SESSION\nare processed.\"\n  (nrepl-send-request-sync (nrepl-eval-request input ns session)))\n\n;;; server\n(defun nrepl--default-endpoint (dir port)\n  \"The endpoint for a repl in project DIR on PORT.\nReturn a plist with :hostname, :port and :proc keys.\"\n    (list :hostname (if (file-remote-p dir)\n                        tramp-current-host\n                      \"localhost\")\n          :port port\n          :proc-buffer-name nil))\n\n(defun nrepl--endpoint-for-connection (dir port)\n  \"Call any `nrepl-connection-endpoint' for DIR and PORT.\nReturn a plist with :hostname and :port values, specifying where\nto connect, and a :proc-buffer-name key, specifying the name of a\nprocess buffer to associate with the connection.  When no\n`nrepl-connection-endpoint' is specified, returns a plist with\nthe hostname associated with DIR, and PORT.\"\n  (if (functionp nrepl-connection-endpoint)\n      (funcall nrepl-connection-endpoint dir port)\n    (nrepl--default-endpoint dir port)))\n\n(defun nrepl-server-filter (process output)\n  \"Process nREPL server output from PROCESS contained in OUTPUT.\"\n  (with-current-buffer (process-buffer process)\n    (save-excursion\n      (goto-char (point-max))\n      (insert output)))\n  (when (string-match \"nREPL server started on port \\\\([0-9]+\\\\)\" output)\n    (let ((port (string-to-number (match-string 1 output))))\n      (message (format \"nREPL server started on %s\" port))\n      (with-current-buffer (process-buffer process)\n        (let* ((endpoint (nrepl--endpoint-for-connection\n                          default-directory port))\n               (hostname (plist-get endpoint :hostname))\n               (port (plist-get endpoint :port))\n               (proc-buffer-name (plist-get endpoint :proc-buffer-name)))\n          (let ((nrepl-process (nrepl-connect hostname port)))\n            (setq nrepl-connection-buffer\n                  (buffer-name (process-buffer nrepl-process)))\n            (with-current-buffer (process-buffer nrepl-process)\n              (setq nrepl-server-buffer\n                    (buffer-name (process-buffer process))\n                    nrepl-project-dir\n                    (buffer-local-value\n                     'nrepl-project-dir (process-buffer process))\n                    nrepl-on-connection-buffer proc-buffer-name))))))))\n\n(defun nrepl-server-sentinel (process event)\n  \"Handle nREPL server PROCESS EVENT.\"\n  (let* ((nrepl-buffer (process-buffer process))\n         (connection-buffer (buffer-local-value 'nrepl-connection-buffer nrepl-buffer))\n         (problem (if (and nrepl-buffer (buffer-live-p nrepl-buffer))\n                      (with-current-buffer nrepl-buffer\n                        (buffer-substring (point-min) (point-max)))\n                    \"\")))\n    (when nrepl-buffer\n      (kill-buffer nrepl-buffer))\n    (cond\n     ((string-match \"^killed\" event)\n      nil)\n     ((string-match \"^hangup\" event)\n      (when connection-buffer\n        (nrepl-close connection-buffer)))\n     ((string-match \"Wrong number of arguments to repl task\" problem)\n      (error \"Leiningen 2.x is required by CIDER\"))\n     (t (error \"Could not start nREPL server: %s\" problem)))))\n\n(defun nrepl--ssh-tunnel-command (ssh dir port)\n  \"Command string to open SSH tunnel to the host associated with DIR's PORT.\"\n  (with-parsed-tramp-file-name dir nil\n    (format-spec\n     \"%s -v -N -L %p:localhost:%p %u'%h'\"\n     `((?s . ,ssh)\n       (?p . ,port)\n       (?h . ,host)\n       (?u . ,(if user (format \"-l '%s' \" user) \"\"))))))\n\n(defun nrepl--ssh-tunnel-filter (port)\n  \"Return a filter function for waiting on PORT to appear in output.\"\n  (let ((port-string (format \"LOCALHOST:%s\" port)))\n    (lambda (proc string)\n      (when (buffer-live-p (process-buffer proc))\n        (with-current-buffer (process-buffer proc)\n          (let ((moving (= (point) (process-mark proc))))\n            (save-excursion\n              (goto-char (process-mark proc))\n              (insert string)\n              (set-marker (process-mark proc) (point)))\n            (if moving (goto-char (process-mark proc))))))\n      (when (string-match port-string string)\n        (with-current-buffer (process-buffer proc)\n          (setq nrepl-wait-for-port nil))))))\n\n(defun nrepl-connection-ssh-tunnel (dir port)\n  \"Return an endpoint for SSH tunnel to project DIR path, and PORT port.\nIf DIR is remote, then attempt to open an SSH tunnel to port.  If\nthe ssh executable is not found on the path, then fall back to\nspecifying a direct conneciton.\"\n  ;; this abuses the -v option for ssh to get output when the port\n  ;; forwarding is set up, which is used to synchronise on, so that\n  ;; the port forwarding is up when we try to connect.\n  (if (file-remote-p dir)\n      (let ((ssh (executable-find \"ssh\")))\n        (if ssh\n            ;; run cmd in a local shell\n            (let* ((cmd (nrepl--ssh-tunnel-command ssh dir port))\n                   (on-connection-buffer-name (nrepl-on-connection-buffer-name))\n                   (proc (start-process-shell-command\n                          \"nrepl-on-connection\"\n                          on-connection-buffer-name\n                          cmd))\n                   (on-connection-buffer (get-buffer\n                                          on-connection-buffer-name)))\n              (with-current-buffer on-connection-buffer-name\n                (setq-local nrepl-wait-for-port t))\n              (set-process-filter proc (nrepl--ssh-tunnel-filter port))\n              (while (and (buffer-local-value 'nrepl-wait-for-port\n                                              on-connection-buffer)\n                          (process-live-p proc))\n                (accept-process-output nil 0.005))\n              (unless (process-live-p proc)\n                (message \"SSH port forwarding failed\"))\n              (list :hostname \"localhost\" :port port\n                    :proc-buffer-name on-connection-buffer-name))\n          (nrepl--default-endpoint dir port)))\n    (list :hostname \"localhost\" :port port :proc-buffer-name nil)))\n\n(defun nrepl-current-dir ()\n  \"Return the directory of the current buffer.\"\n  (let ((file-name (buffer-file-name (current-buffer))))\n    (or (when file-name\n          (file-name-directory file-name))\n        list-buffers-directory)))\n\n(defun nrepl-project-directory-for (dir-name)\n  \"Return the project directory for the specified DIR-NAME.\"\n  (when dir-name\n    (locate-dominating-file dir-name \"project.clj\")))\n\n(defun nrepl-check-for-repl-buffer (endpoint project-directory)\n  \"Check whether a matching connection buffer already exists.\nLooks for buffers where `nrepl-endpoint' matches ENDPOINT,\nor `nrepl-project-dir' matches PROJECT-DIRECTORY.\nIf so ask the user for confirmation.\"\n  (if (cl-find-if\n       (lambda (buffer)\n         (let ((buffer (get-buffer buffer)))\n           (or (and endpoint\n                    (equal endpoint\n                           (buffer-local-value 'nrepl-endpoint buffer)))\n               (and project-directory\n                    (equal project-directory\n                           (buffer-local-value 'nrepl-project-dir buffer))))))\n       (nrepl-connection-buffers))\n      (y-or-n-p\n       \"An nREPL connection buffer already exists.  Do you really want to create a new one? \")\n    t))\n\n(defun nrepl-close (connection-buffer)\n  \"Close the nrepl connection for CONNECTION-BUFFER.\"\n  (interactive (list (nrepl-current-connection-buffer)))\n  (nrepl--close-connection-buffer connection-buffer)\n  (run-hooks 'nrepl-disconnected-hook)\n  (nrepl--connections-refresh))\n\n;;; client\n(defun nrepl-op-supported-p (op)\n  \"Return t iff the given operation OP is supported by nREPL server.\"\n  (with-current-buffer (nrepl-current-connection-buffer)\n    (if (and nrepl-ops (assoc op nrepl-ops))\n        t)))\n\n(defun nrepl-describe-handler (process-buffer)\n  \"Return a handler to describe into PROCESS-BUFFER.\"\n  (lambda (response)\n    (nrepl-dbind-response response (ops)\n      (with-current-buffer process-buffer\n        (setq nrepl-ops ops)))\n    (cider-make-repl (get-buffer-process process-buffer))\n    (nrepl-make-repl-connection-default process-buffer)\n    (cider-verify-required-nrepl-ops)))\n\n(defun nrepl-describe-session (process)\n  \"Peform describe for the given server PROCESS.\"\n  (let ((buffer (process-buffer process)))\n    (nrepl-send-request (list \"op\" \"describe\")\n                        (nrepl-describe-handler buffer))))\n\n(defun nrepl-new-tooling-session-handler (process)\n  \"Create a new tooling session handler for PROCESS.\"\n  (lambda (response)\n    (nrepl-dbind-response response (id new-session)\n      (with-current-buffer (process-buffer process)\n        (setq nrepl-tooling-session new-session)\n        (remhash id nrepl-pending-requests)))))\n\n(defun nrepl-new-session-handler (process)\n  \"Create a new session handler for PROCESS.\"\n  (lambda (response)\n    (nrepl-dbind-response response (id new-session)\n      (remhash id nrepl-pending-requests)\n      (let ((connection-buffer (process-buffer process)))\n        (setq nrepl-session new-session\n              nrepl-connection-buffer connection-buffer)\n        (run-hooks 'nrepl-connected-hook)))))\n\n(defun nrepl-init-client-sessions (process)\n  \"Initialize client sessions for PROCESS.\"\n  (nrepl-create-client-session (nrepl-new-session-handler process))\n  (nrepl-create-client-session (nrepl-new-tooling-session-handler process)))\n\n(defun nrepl-connect (host port)\n  \"Connect to a running nREPL server running on HOST and PORT.\"\n  (message \"Connecting to nREPL server on %s:%s...\" host port)\n  (let* ((nrepl-endpoint `(,host ,port))\n         (process (open-network-stream \"nrepl\"\n                                       (nrepl-make-connection-buffer)\n                                       host\n                                       port)))\n    (set-process-filter process 'nrepl-net-filter)\n    (set-process-sentinel process 'nrepl-sentinel)\n    (set-process-coding-system process 'utf-8-unix 'utf-8-unix)\n    (with-current-buffer (process-buffer process)\n      (setq nrepl-endpoint `(,host ,port)))\n    (let ((nrepl-connection-dispatch (buffer-name (process-buffer process))))\n      (nrepl-init-client-sessions process)\n      (nrepl-describe-session process))\n    process))\n\n(defun nrepl--port-from-file (file)\n  \"Attempts to read port from a file named by FILE.\"\n  (let* ((dir (nrepl-project-directory-for (nrepl-current-dir)))\n         (f (expand-file-name file dir)))\n    (when (file-exists-p f)\n      (with-temp-buffer\n        (insert-file-contents f)\n        (buffer-string)))))\n\n(defun nrepl-default-port ()\n  \"Attempt to read port from .nrepl-port or target/repl-port.\nFalls back to `nrepl-port' if not found.\"\n  (or (nrepl--port-from-file \".nrepl-port\")\n      (nrepl--port-from-file \"target/repl-port\")\n      nrepl-port))\n\n(provide 'nrepl-client)\n\n;;; nrepl-client.el ends here\n","markers":{"markers":{"1":{"id":1,"range":[[636,28],[636,28]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":174,"autoscroll":true,"preserveFolds":true,"goalBufferRange":null},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/zk/napplelabs/cider/nrepl-client.el","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"6af1fa35e19ec3dbf8cc5ef749ee20730c6b0310","deserializer":"TextBuffer"}],"deserializer":"Project"},"workspace":{"paneContainer":{"root":{"items":[{"id":56,"softTabs":true,"displayBuffer":{"id":57,"softWrap":false,"editorWidthInChars":153,"scrollTop":17787,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/zk/napplelabs/cider/cider-interaction.el","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":113,"softTabs":true,"displayBuffer":{"id":114,"softWrap":false,"editorWidthInChars":178,"scrollTop":3891,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/zk/napplelabs/cider/cider-client.el","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":174,"softTabs":true,"displayBuffer":{"id":175,"softWrap":false,"editorWidthInChars":153,"scrollTop":13168,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/zk/napplelabs/cider/nrepl-client.el","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"}],"activeItemUri":"/Users/zk/napplelabs/cider/cider-client.el","focused":true,"active":true,"deserializer":"Pane"},"deserializer":"PaneContainer"},"fullScreen":false,"deserializer":"Workspace"},"packageStates":{"find-and-replace":{"viewState":{"findHistory":["session","cider-eval","defun cider-eval","defun cider-eval ","excep","(nrepl-current-session)","stacktrace"],"replaceHistory":[],"modelState":{"useRegex":false,"inCurrentSelection":false,"caseSensitive":false}},"projectViewState":{"findHistory":["exception","defun cider-eval","defun nrepl-current-session","stacktrace"],"replaceHistory":[],"pathsHistory":[],"modelState":{"useRegex":false,"caseSensitive":false}},"resultsModelState":{"useRegex":false,"caseSensitive":false}},"fuzzy-finder":{"/Users/zk/napplelabs/cider/cider-interaction.el":1403991065450,"/Users/zk/napplelabs/cider/cider-client.el":1403991277402,"/Users/zk/napplelabs/cider/nrepl-client.el":1403991006311},"keybinding-resolver":{"attached":false},"metrics":{"sessionLength":2095877},"tree-view":{"directoryExpansionStates":{},"selectedPath":"/Users/zk/napplelabs/cider/cider-client.el","hasFocus":false,"attached":true,"scrollLeft":0,"scrollTop":0,"width":200}}}