{"mode":"editor","version":1,"windowDimensions":{"x":0,"y":22,"width":1440,"height":874},"syntax":{"deserializer":"Syntax","grammarOverridesByPath":{}},"project":{"path":"/Users/zk/napplelabs/atom","buffers":[{"text":"React = require 'react'\n{div, span} = require 'reactionary'\n{debounce} = require 'underscore-plus'\n\nGutterComponent = require './gutter-component'\nEditorScrollViewComponent = require './editor-scroll-view-component'\nScrollbarComponent = require './scrollbar-component'\nSubscriberMixin = require './subscriber-mixin'\n\nmodule.exports =\nEditorComponent = React.createClass\n  displayName: 'EditorComponent'\n  mixins: [SubscriberMixin]\n\n  pendingScrollTop: null\n  pendingScrollLeft: null\n  selectOnMouseMove: false\n  batchingUpdates: false\n  updateRequested: false\n  cursorsMoved: false\n  preservedRowRange: null\n  scrollingVertically: false\n\n  render: ->\n    {focused, fontSize, lineHeight, fontFamily, showIndentGuide} = @state\n    {editor, cursorBlinkPeriod, cursorBlinkResumeDelay} = @props\n    if @isMounted()\n      renderedRowRange = @getRenderedRowRange()\n      scrollHeight = editor.getScrollHeight()\n      scrollWidth = editor.getScrollWidth()\n      scrollTop = editor.getScrollTop()\n      scrollLeft = editor.getScrollLeft()\n      lineHeightInPixels = editor.getLineHeight()\n\n    className = 'editor editor-colors react'\n    className += ' is-focused' if focused\n\n    div className: className, style: {fontSize, lineHeight, fontFamily}, tabIndex: -1,\n      GutterComponent {\n        editor, renderedRowRange, scrollTop, scrollHeight,\n        lineHeight: lineHeightInPixels, @pendingChanges\n      }\n\n      EditorScrollViewComponent {\n        ref: 'scrollView', editor, fontSize, fontFamily, showIndentGuide\n        scrollHeight, scrollWidth, lineHeight: lineHeightInPixels,\n        renderedRowRange, @pendingChanges, @scrollingVertically, @cursorsMoved,\n        cursorBlinkPeriod, cursorBlinkResumeDelay, @onInputFocused, @onInputBlurred\n      }\n\n      ScrollbarComponent\n        ref: 'verticalScrollbar'\n        className: 'vertical-scrollbar'\n        orientation: 'vertical'\n        onScroll: @onVerticalScroll\n        scrollTop: scrollTop\n        scrollHeight: scrollHeight\n\n      ScrollbarComponent\n        ref: 'horizontalScrollbar'\n        className: 'horizontal-scrollbar'\n        orientation: 'horizontal'\n        onScroll: @onHorizontalScroll\n        scrollLeft: scrollLeft\n        scrollWidth: scrollWidth\n\n  getRenderedRowRange: ->\n    renderedRowRange = @props.editor.getVisibleRowRange()\n    if @preservedRowRange?\n      renderedRowRange[0] = Math.min(@preservedRowRange[0], renderedRowRange[0])\n      renderedRowRange[1] = Math.max(@preservedRowRange[1], renderedRowRange[1])\n    renderedRowRange\n\n  getInitialState: -> {}\n\n  getDefaultProps: ->\n    cursorBlinkPeriod: 800\n    cursorBlinkResumeDelay: 200\n\n  componentWillMount: ->\n    @pendingChanges = []\n    @props.editor.manageScrollPosition = true\n    @observeConfig()\n\n  componentDidMount: ->\n    @observeEditor()\n    @listenForDOMEvents()\n    @listenForCommands()\n    @props.editor.setVisible(true)\n    @requestUpdate()\n\n  componentWillUnmount: ->\n    @unsubscribe()\n    @getDOMNode().removeEventListener 'mousewheel', @onMouseWheel\n\n  componentWillUpdate: ->\n    @props.parentView.trigger 'cursor:moved' if @cursorsMoved\n\n  componentDidUpdate: ->\n    @pendingChanges.length = 0\n    @cursorsMoved = false\n    @props.parentView.trigger 'editor:display-updated'\n\n  observeEditor: ->\n    {editor} = @props\n    @subscribe editor, 'batched-updates-started', @onBatchedUpdatesStarted\n    @subscribe editor, 'batched-updates-ended', @onBatchedUpdatesEnded\n    @subscribe editor, 'screen-lines-changed', @onScreenLinesChanged\n    @subscribe editor, 'cursors-moved', @onCursorsMoved\n    @subscribe editor, 'selection-screen-range-changed', @requestUpdate\n    @subscribe editor, 'selection-added', @onSelectionAdded\n    @subscribe editor, 'selection-removed', @onSelectionAdded\n    @subscribe editor.$scrollTop.changes, @onScrollTopChanged\n    @subscribe editor.$scrollLeft.changes, @requestUpdate\n    @subscribe editor.$height.changes, @requestUpdate\n    @subscribe editor.$width.changes, @requestUpdate\n    @subscribe editor.$defaultCharWidth.changes, @requestUpdate\n    @subscribe editor.$lineHeight.changes, @requestUpdate\n\n  listenForDOMEvents: ->\n    node = @getDOMNode()\n    node.addEventListener 'mousewheel', @onMouseWheel\n    node.addEventListener 'focus', @onFocus # For some reason, React's built in focus events seem to bubble\n\n  listenForCommands: ->\n    {parentView, editor, mini} = @props\n\n    @addCommandListeners\n      'core:move-left': => editor.moveCursorLeft()\n      'core:move-right': => editor.moveCursorRight()\n      'core:select-left': => editor.selectLeft()\n      'core:select-right': => editor.selectRight()\n      'core:select-all': => editor.selectAll()\n      'core:backspace': => editor.backspace()\n      'core:delete': => editor.delete()\n      'core:undo': => editor.undo()\n      'core:redo': => editor.redo()\n      'core:cut': => editor.cutSelectedText()\n      'core:copy': => editor.copySelectedText()\n      'core:paste': => editor.pasteText()\n      'editor:move-to-previous-word': => editor.moveCursorToPreviousWord()\n      'editor:select-word': => editor.selectWord()\n      'editor:consolidate-selections': @consolidateSelections\n      'editor:backspace-to-beginning-of-word': => editor.backspaceToBeginningOfWord()\n      'editor:backspace-to-beginning-of-line': => editor.backspaceToBeginningOfLine()\n      'editor:delete-to-end-of-word': => editor.deleteToEndOfWord()\n      'editor:delete-line': => editor.deleteLine()\n      'editor:cut-to-end-of-line': => editor.cutToEndOfLine()\n      'editor:move-to-beginning-of-screen-line': => editor.moveCursorToBeginningOfScreenLine()\n      'editor:move-to-beginning-of-line': => editor.moveCursorToBeginningOfLine()\n      'editor:move-to-end-of-screen-line': => editor.moveCursorToEndOfScreenLine()\n      'editor:move-to-end-of-line': => editor.moveCursorToEndOfLine()\n      'editor:move-to-first-character-of-line': => editor.moveCursorToFirstCharacterOfLine()\n      'editor:move-to-beginning-of-word': => editor.moveCursorToBeginningOfWord()\n      'editor:move-to-end-of-word': => editor.moveCursorToEndOfWord()\n      'editor:move-to-beginning-of-next-word': => editor.moveCursorToBeginningOfNextWord()\n      'editor:move-to-previous-word-boundary': => editor.moveCursorToPreviousWordBoundary()\n      'editor:move-to-next-word-boundary': => editor.moveCursorToNextWordBoundary()\n      'editor:select-to-end-of-line': => editor.selectToEndOfLine()\n      'editor:select-to-beginning-of-line': => editor.selectToBeginningOfLine()\n      'editor:select-to-end-of-word': => editor.selectToEndOfWord()\n      'editor:select-to-beginning-of-word': => editor.selectToBeginningOfWord()\n      'editor:select-to-beginning-of-next-word': => editor.selectToBeginningOfNextWord()\n      'editor:select-to-next-word-boundary': => editor.selectToNextWordBoundary()\n      'editor:select-to-previous-word-boundary': => editor.selectToPreviousWordBoundary()\n      'editor:select-to-first-character-of-line': => editor.selectToFirstCharacterOfLine()\n      'editor:select-line': => editor.selectLine()\n      'editor:transpose': => editor.transpose()\n      'editor:upper-case': => editor.upperCase()\n      'editor:lower-case': => editor.lowerCase()\n\n    unless mini\n      @addCommandListeners\n        'core:move-up': => editor.moveCursorUp()\n        'core:move-down': => editor.moveCursorDown()\n        'core:move-to-top': => editor.moveCursorToTop()\n        'core:move-to-bottom': => editor.moveCursorToBottom()\n        'core:select-up': => editor.selectUp()\n        'core:select-down': => editor.selectDown()\n        'core:select-to-top': => editor.selectToTop()\n        'core:select-to-bottom': => editor.selectToBottom()\n        'editor:indent': => editor.indent()\n        'editor:auto-indent': => editor.autoIndentSelectedRows()\n        'editor:indent-selected-rows': => editor.indentSelectedRows()\n        'editor:outdent-selected-rows': => editor.outdentSelectedRows()\n        'editor:newline': => editor.insertNewline()\n        'editor:newline-below': => editor.insertNewlineBelow()\n        'editor:newline-above': => editor.insertNewlineAbove()\n        'editor:add-selection-below': => editor.addSelectionBelow()\n        'editor:add-selection-above': => editor.addSelectionAbove()\n        'editor:split-selections-into-lines': => editor.splitSelectionsIntoLines()\n        'editor:toggle-soft-tabs': => editor.toggleSoftTabs()\n        'editor:toggle-soft-wrap': => editor.toggleSoftWrap()\n        'editor:fold-all': => editor.foldAll()\n        'editor:unfold-all': => editor.unfoldAll()\n        'editor:fold-current-row': => editor.foldCurrentRow()\n        'editor:unfold-current-row': => editor.unfoldCurrentRow()\n        'editor:fold-selection': => neditor.foldSelectedLines()\n        'editor:fold-at-indent-level-1': => editor.foldAllAtIndentLevel(0)\n        'editor:fold-at-indent-level-2': => editor.foldAllAtIndentLevel(1)\n        'editor:fold-at-indent-level-3': => editor.foldAllAtIndentLevel(2)\n        'editor:fold-at-indent-level-4': => editor.foldAllAtIndentLevel(3)\n        'editor:fold-at-indent-level-5': => editor.foldAllAtIndentLevel(4)\n        'editor:fold-at-indent-level-6': => editor.foldAllAtIndentLevel(5)\n        'editor:fold-at-indent-level-7': => editor.foldAllAtIndentLevel(6)\n        'editor:fold-at-indent-level-8': => editor.foldAllAtIndentLevel(7)\n        'editor:fold-at-indent-level-9': => editor.foldAllAtIndentLevel(8)\n        'editor:toggle-line-comments': => editor.toggleLineCommentsInSelection()\n        'editor:log-cursor-scope': => editor.logCursorScope()\n        'editor:checkout-head-revision': => editor.checkoutHead()\n        'editor:copy-path': => editor.copyPathToClipboard()\n        'editor:move-line-up': => editor.moveLineUp()\n        'editor:move-line-down': => editor.moveLineDown()\n        'editor:duplicate-lines': => editor.duplicateLines()\n        'editor:join-lines': => editor.joinLines()\n        'editor:toggle-indent-guide': => atom.config.toggle('editor.showIndentGuide')\n        'editor:toggle-line-numbers': =>  atom.config.toggle('editor.showLineNumbers')\n        'editor:scroll-to-cursor': => editor.scrollToCursorPosition()\n        'core:page-up': => editor.pageUp()\n        'core:page-down': => editor.pageDown()\n\n  addCommandListeners: (listenersByCommandName) ->\n    {parentView} = @props\n\n    for command, listener of listenersByCommandName\n      parentView.command command, listener\n\n  observeConfig: ->\n    @subscribe atom.config.observe 'editor.fontFamily', @setFontFamily\n    @subscribe atom.config.observe 'editor.fontSize', @setFontSize\n    @subscribe atom.config.observe 'editor.showIndentGuide', @setShowIndentGuide\n\n  setFontSize: (fontSize) ->\n    @setState({fontSize})\n\n  setLineHeight: (lineHeight) ->\n    @setState({lineHeight})\n\n  setFontFamily: (fontFamily) ->\n    @setState({fontFamily})\n\n  setShowIndentGuide: (showIndentGuide) ->\n    @setState({showIndentGuide})\n\n  onFocus: ->\n    @refs.scrollView.focus()\n\n  onInputFocused: ->\n    @setState(focused: true)\n\n  onInputBlurred: ->\n    @setState(focused: false)\n\n  onVerticalScroll: (scrollTop) ->\n    {editor} = @props\n\n    return if scrollTop is editor.getScrollTop()\n\n    animationFramePending = @pendingScrollTop?\n    @pendingScrollTop = scrollTop\n    unless animationFramePending\n      requestAnimationFrame =>\n        @props.editor.setScrollTop(@pendingScrollTop)\n        @pendingScrollTop = null\n\n  onHorizontalScroll: (scrollLeft) ->\n    {editor} = @props\n\n    return if scrollLeft is editor.getScrollLeft()\n\n    animationFramePending = @pendingScrollLeft?\n    @pendingScrollLeft = scrollLeft\n    unless animationFramePending\n      requestAnimationFrame =>\n        @props.editor.setScrollLeft(@pendingScrollLeft)\n        @pendingScrollLeft = null\n\n  onMouseWheel: (event) ->\n    # Only scroll in one direction at a time\n    {wheelDeltaX, wheelDeltaY} = event\n    if Math.abs(wheelDeltaX) > Math.abs(wheelDeltaY)\n      @refs.horizontalScrollbar.getDOMNode().scrollLeft -= wheelDeltaX\n    else\n      @refs.verticalScrollbar.getDOMNode().scrollTop -= wheelDeltaY\n\n    event.preventDefault()\n\n  clearPreservedRowRange: ->\n    @preservedRowRange = null\n    @scrollingVertically = false\n    @requestUpdate()\n\n  clearPreservedRowRangeAfterDelay: null # Created lazily\n\n  onBatchedUpdatesStarted: ->\n    @batchingUpdates = true\n\n  onBatchedUpdatesEnded: ->\n    updateRequested = @updateRequested\n    @updateRequested = false\n    @batchingUpdates = false\n    if updateRequested\n      @requestUpdate()\n\n  onScreenLinesChanged: (change) ->\n    {editor} = @props\n    @pendingChanges.push(change)\n    @requestUpdate() if editor.intersectsVisibleRowRange(change.start, change.end + 1) # TODO: Use closed-open intervals for change events\n\n  onSelectionAdded: (selection) ->\n    {editor} = @props\n    @requestUpdate() if editor.selectionIntersectsVisibleRowRange(selection)\n\n  onScrollTopChanged: ->\n    @preservedRowRange = @getRenderedRowRange()\n    @scrollingVertically = true\n    @clearPreservedRowRangeAfterDelay ?= debounce(@clearPreservedRowRange, 200)\n    @clearPreservedRowRangeAfterDelay()\n    @requestUpdate()\n\n  onSelectionRemoved: (selection) ->\n    {editor} = @props\n    @requestUpdate() if editor.selectionIntersectsVisibleRowRange(selection)\n\n  onCursorsMoved: ->\n    @cursorsMoved = true\n\n  requestUpdate: ->\n    if @batchingUpdates\n      @updateRequested = true\n    else\n      @forceUpdate()\n\n  measureHeightAndWidth: ->\n    @refs.scrollView.measureHeightAndWidth()\n\n  consolidateSelections: (e) ->\n    e.abortKeyBinding() unless @props.editor.consolidateSelections()\n","markers":{"markers":{"1":{"id":1,"range":[[182,62],[182,62]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":41,"autoscroll":true,"goalBufferRange":null,"preserveFolds":true},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/zk/napplelabs/atom/src/editor-component.coffee","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"16e8bc1e94ab0ae579d54232b3ac111216ef4ad6","deserializer":"TextBuffer"},{"text":"_ = require 'underscore-plus'\npath = require 'path'\nSerializable = require 'serializable'\nDelegator = require 'delegato'\n{deprecate} = require 'grim'\n{Model} = require 'theorist'\n{Point, Range} = require 'text-buffer'\nLanguageMode = require './language-mode'\nDisplayBuffer = require './display-buffer'\nCursor = require './cursor'\nSelection = require './selection'\nTextMateScopeSelector = require('first-mate').ScopeSelector\n\n# Public: This class represents all essential editing state for a single\n# {TextBuffer}, including cursor and selection positions, folds, and soft wraps.\n# If you're manipulating the state of an editor, use this class. If you're\n# interested in the visual appearance of editors, use {EditorView} instead.\n#\n# A single {TextBuffer} can belong to multiple editors. For example, if the\n# same file is open in two different panes, Atom creates a separate editor for\n# each pane. If the buffer is manipulated the changes are reflected in both\n# editors, but each maintains its own cursor position, folded lines, etc.\n#\n# ## Accessing Editor Instances\n#\n# The easiest way to get hold of `Editor` objects is by registering a callback\n# with `::eachEditor` on the `atom.workspace` global. Your callback will then\n# be called with all current editor instances and also when any editor is\n# created in the future.\n#\n# ```coffeescript\n#   atom.workspace.eachEditor (editor) ->\n#     editor.insertText('Hello World')\n# ```\n#\n# ## Buffer vs. Screen Coordinates\n#\n# Because editors support folds and soft-wrapping, the lines on screen don't\n# always match the lines in the buffer. For example, a long line that soft wraps\n# twice renders as three lines on screen, but only represents one line in the\n# buffer. Similarly, if rows 5-10 are folded, then row 6 on screen corresponds\n# to row 11 in the buffer.\n#\n# Your choice of coordinates systems will depend on what you're trying to\n# achieve. For example, if you're writing a command that jumps the cursor up or\n# down by 10 lines, you'll want to use screen coordinates because the user\n# probably wants to skip lines *on screen*. However, if you're writing a package\n# that jumps between method definitions, you'll want to work in buffer\n# coordinates.\n#\n# **When in doubt, just default to buffer coordinates**, then experiment with\n# soft wraps and folds to ensure your code interacts with them correctly.\n#\n# ## Common Tasks\n#\n# This is a subset of methods on this class. Refer to the complete summary for\n# its full capabilities.\n#\n# ### Cursors\n# - {::setCursorBufferPosition}\n# - {::setCursorScreenPosition}\n# - {::moveCursorUp}\n# - {::moveCursorDown}\n# - {::moveCursorLeft}\n# - {::moveCursorRight}\n# - {::moveCursorToBeginningOfWord}\n# - {::moveCursorToEndOfWord}\n# - {::moveCursorToPreviousWordBoundary}\n# - {::moveCursorToNextWordBoundary}\n# - {::moveCursorToBeginningOfNextWord}\n# - {::moveCursorToBeginningOfLine}\n# - {::moveCursorToEndOfLine}\n# - {::moveCursorToFirstCharacterOfLine}\n# - {::moveCursorToTop}\n# - {::moveCursorToBottom}\n#\n# ### Selections\n# - {::getSelectedBufferRange}\n# - {::getSelectedBufferRanges}\n# - {::setSelectedBufferRange}\n# - {::setSelectedBufferRanges}\n# - {::selectUp}\n# - {::selectDown}\n# - {::selectLeft}\n# - {::selectRight}\n# - {::selectToBeginningOfWord}\n# - {::selectToEndOfWord}\n# - {::selectToPreviousWordBoundary}\n# - {::selectToNextWordBoundary}\n# - {::selectWord}\n# - {::selectToBeginningOfLine}\n# - {::selectToEndOfLine}\n# - {::selectToFirstCharacterOfLine}\n# - {::selectToTop}\n# - {::selectToBottom}\n# - {::selectAll}\n# - {::addSelectionForBufferRange}\n# - {::addSelectionAbove}\n# - {::addSelectionBelow}\n# - {::splitSelectionsIntoLines}\n#\n# ### Manipulating Text\n# - {::getText}\n# - {::getSelectedText}\n# - {::setText}\n# - {::setTextInBufferRange}\n# - {::insertText}\n# - {::insertNewline}\n# - {::insertNewlineAbove}\n# - {::insertNewlineBelow}\n# - {::backspace}\n# - {::backspaceToBeginningOfWord}\n# - {::backspaceToBeginningOfLine}\n# - {::delete}\n# - {::deleteToEndOfWord}\n# - {::deleteLine}\n# - {::cutSelectedText}\n# - {::cutToEndOfLine}\n# - {::copySelectedText}\n# - {::pasteText}\n#\n# ### Undo, Redo, and Transactions\n# - {::undo}\n# - {::redo}\n# - {::transact}\n# - {::abortTransaction}\n#\n# ### Markers\n# - {::markBufferRange}\n# - {::markScreenRange}\n# - {::getMarker}\n# - {::findMarkers}\nmodule.exports =\nclass Editor extends Model\n  Serializable.includeInto(this)\n  atom.deserializers.add(this)\n  Delegator.includeInto(this)\n\n  deserializing: false\n  callDisplayBufferCreatedHook: false\n  registerEditor: false\n  buffer: null\n  languageMode: null\n  cursors: null\n  selections: null\n  suppressSelectionMerging: false\n\n  @delegatesMethods 'suggestedIndentForBufferRow', 'autoIndentBufferRow', 'autoIndentBufferRows',\n    'autoDecreaseIndentForBufferRow', 'toggleLineCommentForBufferRow', 'toggleLineCommentsForBufferRows',\n    toProperty: 'languageMode'\n\n  @delegatesProperties '$lineHeight', '$defaultCharWidth', '$height', '$width',\n    '$scrollTop', '$scrollLeft', 'manageScrollPosition', toProperty: 'displayBuffer'\n\n  constructor: ({@softTabs, initialLine, initialColumn, tabLength, softWrap, @displayBuffer, buffer, registerEditor, suppressCursorCreation}) ->\n    super\n\n    @cursors = []\n    @selections = []\n\n    @displayBuffer ?= new DisplayBuffer({buffer, tabLength, softWrap})\n    @buffer = @displayBuffer.buffer\n    @softTabs = @buffer.usesSoftTabs() ? @softTabs ? atom.config.get('editor.softTabs') ? true\n\n    for marker in @findMarkers(@getSelectionMarkerAttributes())\n      marker.setAttributes(preserveFolds: true)\n      @addSelection(marker)\n\n    @subscribeToBuffer()\n    @subscribeToDisplayBuffer()\n\n    if @getCursors().length is 0 and not suppressCursorCreation\n      initialLine = Math.max(parseInt(initialLine) or 0, 0)\n      initialColumn = Math.max(parseInt(initialColumn) or 0, 0)\n      @addCursorAtBufferPosition([initialLine, initialColumn])\n\n    @languageMode = new LanguageMode(this)\n\n    @subscribe @$scrollTop, (scrollTop) => @emit 'scroll-top-changed', scrollTop\n    @subscribe @$scrollLeft, (scrollLeft) => @emit 'scroll-left-changed', scrollLeft\n\n    atom.workspace?.editorAdded(this) if registerEditor\n\n  serializeParams: ->\n    id: @id\n    softTabs: @softTabs\n    scrollTop: @scrollTop\n    scrollLeft: @scrollLeft\n    displayBuffer: @displayBuffer.serialize()\n\n  deserializeParams: (params) ->\n    params.displayBuffer = DisplayBuffer.deserialize(params.displayBuffer)\n    params.registerEditor = true\n    params\n\n  subscribeToBuffer: ->\n    @buffer.retain()\n    @subscribe @buffer, \"path-changed\", =>\n      unless atom.project.getPath()?\n        atom.project.setPath(path.dirname(@getPath()))\n      @emit \"title-changed\"\n      @emit \"path-changed\"\n    @subscribe @buffer, \"contents-modified\", => @emit \"contents-modified\"\n    @subscribe @buffer, \"contents-conflicted\", => @emit \"contents-conflicted\"\n    @subscribe @buffer, \"modified-status-changed\", => @emit \"modified-status-changed\"\n    @subscribe @buffer, \"destroyed\", => @destroy()\n    @preserveCursorPositionOnBufferReload()\n\n  subscribeToDisplayBuffer: ->\n    @subscribe @displayBuffer, 'marker-created', @handleMarkerCreated\n    @subscribe @displayBuffer, \"changed\", (e) => @emit 'screen-lines-changed', e\n    @subscribe @displayBuffer, \"markers-updated\", => @mergeIntersectingSelections()\n    @subscribe @displayBuffer, 'grammar-changed', => @handleGrammarChange()\n    @subscribe @displayBuffer, 'soft-wrap-changed', (args...) => @emit 'soft-wrap-changed', args...\n\n  getViewClass: ->\n    if atom.config.get('core.useReactEditor')\n      require './react-editor-view'\n    else\n      require './editor-view'\n\n  destroyed: ->\n    @unsubscribe()\n    selection.destroy() for selection in @getSelections()\n    @buffer.release()\n    @displayBuffer.destroy()\n    @languageMode.destroy()\n\n  # Create an {Editor} with its initial state based on this object\n  copy: ->\n    tabLength = @getTabLength()\n    displayBuffer = @displayBuffer.copy()\n    softTabs = @getSoftTabs()\n    newEditor = new Editor({@buffer, displayBuffer, tabLength, softTabs, suppressCursorCreation: true, registerEditor: true})\n    for marker in @findMarkers(editorId: @id)\n      marker.copy(editorId: newEditor.id, preserveFolds: true)\n    newEditor\n\n  # Public: Get the title the editor's title for display in other parts of the\n  # UI such as the tabs.\n  #\n  # If the editor's buffer is saved, its title is the file name. If it is\n  # unsaved, its title is \"untitled\".\n  #\n  # Returns a {String}.\n  getTitle: ->\n    if sessionPath = @getPath()\n      path.basename(sessionPath)\n    else\n      'untitled'\n\n  # Public: Get the editor's long title for display in other parts of the UI\n  # such as the window title.\n  #\n  # If the editor's buffer is saved, its long title is formatted as\n  # \"<filename> - <directory>\". If it is unsaved, its title is \"untitled\"\n  #\n  # Returns a {String}.\n  getLongTitle: ->\n    if sessionPath = @getPath()\n      fileName = path.basename(sessionPath)\n      directory = path.basename(path.dirname(sessionPath))\n      \"#{fileName} - #{directory}\"\n    else\n      'untitled'\n\n  # Controls visiblity based on the given {Boolean}.\n  setVisible: (visible) -> @displayBuffer.setVisible(visible)\n\n  # Set the number of characters that can be displayed horizontally in the\n  # editor.\n  #\n  # editorWidthInChars - A {Number} representing the width of the {EditorView}\n  # in characters.\n  setEditorWidthInChars: (editorWidthInChars) ->\n    @displayBuffer.setEditorWidthInChars(editorWidthInChars)\n\n  # Public: Sets the column at which columsn will soft wrap\n  getSoftWrapColumn: -> @displayBuffer.getSoftWrapColumn()\n\n  # Public: Returns a {Boolean} indicating whether softTabs are enabled for this\n  # editor.\n  getSoftTabs: -> @softTabs\n\n  # Public: Enable or disable soft tabs for this editor.\n  #\n  # softTabs - A {Boolean}\n  setSoftTabs: (@softTabs) -> @softTabs\n\n  # Public: Toggle soft tabs for this editor\n  toggleSoftTabs: -> @setSoftTabs(not @getSoftTabs())\n\n  # Public: Get whether soft wrap is enabled for this editor.\n  getSoftWrap: -> @displayBuffer.getSoftWrap()\n\n  # Public: Enable or disable soft wrap for this editor.\n  #\n  # softWrap - A {Boolean}\n  setSoftWrap: (softWrap) -> @displayBuffer.setSoftWrap(softWrap)\n\n  # Public: Toggle soft wrap for this editor\n  toggleSoftWrap: -> @setSoftWrap(not @getSoftWrap())\n\n  # Public: Get the text representing a single level of indent.\n  #\n  # If soft tabs are enabled, the text is composed of N spaces, where N is the\n  # tab length. Otherwise the text is a tab character (`\\t`).\n  #\n  # Returns a {String}.\n  getTabText: -> @buildIndentString(1)\n\n  # Public: Get the on-screen length of tab characters.\n  #\n  # Returns a {Number}.\n  getTabLength: -> @displayBuffer.getTabLength()\n\n  # Public: Set the on-screen length of tab characters.\n  setTabLength: (tabLength) -> @displayBuffer.setTabLength(tabLength)\n\n  # Public: Clip the given {Point} to a valid position in the buffer.\n  #\n  # If the given {Point} describes a position that is actually reachable by the\n  # cursor based on the current contents of the buffer, it is returned\n  # unchanged. If the {Point} does not describe a valid position, the closest\n  # valid position is returned instead.\n  #\n  # For example:\n  #   * `[-1, -1]` is converted to `[0, 0]`.\n  #   * If the line at row 2 is 10 long, `[2, Infinity]` is converted to\n  #     `[2, 10]`.\n  #\n  # bufferPosition - The {Point} representing the position to clip.\n  #\n  # Returns a {Point}.\n  clipBufferPosition: (bufferPosition) -> @buffer.clipPosition(bufferPosition)\n\n  # Public: Clip the start and end of the given range to valid positions in the\n  # buffer. See {::clipBufferPosition} for more information.\n  #\n  # range - The {Range} to clip.\n  #\n  # Returns a {Range}.\n  clipBufferRange: (range) -> @buffer.clipRange(range)\n\n  # Public: Get the indentation level of the given a buffer row.\n  #\n  # Returns how deeply the given row is indented based on the soft tabs and\n  # tab length settings of this editor. Note that if soft tabs are enabled and\n  # the tab length is 2, a row with 4 leading spaces would have an indentation\n  # level of 2.\n  #\n  # bufferRow - A {Number} indicating the buffer row.\n  #\n  # Returns a {Number}.\n  indentationForBufferRow: (bufferRow) ->\n    @indentLevelForLine(@lineForBufferRow(bufferRow))\n\n  # Public: Set the indentation level for the given buffer row.\n  #\n  # Inserts or removes hard tabs or spaces based on the soft tabs and tab length\n  # settings of this editor in order to bring it to the given indentation level.\n  # Note that if soft tabs are enabled and the tab length is 2, a row with 4\n  # leading spaces would have an indentation level of 2.\n  #\n  # bufferRow - A {Number} indicating the buffer row.\n  # newLevel - A {Number} indicating the new indentation level.\n  # options - An {Object} with the following keys:\n  #   :preserveLeadingWhitespace - true to preserve any whitespace already at\n  #                                the beginning of the line (default: false).\n  setIndentationForBufferRow: (bufferRow, newLevel, {preserveLeadingWhitespace}={}) ->\n    if preserveLeadingWhitespace\n      endColumn = 0\n    else\n      endColumn = @lineForBufferRow(bufferRow).match(/^\\s*/)[0].length\n    newIndentString = @buildIndentString(newLevel)\n    @buffer.setTextInRange([[bufferRow, 0], [bufferRow, endColumn]], newIndentString)\n\n  # Public: Get the indentation level of the given line of text.\n  #\n  # Returns how deeply the given line is indented based on the soft tabs and\n  # tab length settings of this editor. Note that if soft tabs are enabled and\n  # the tab length is 2, a row with 4 leading spaces would have an indentation\n  # level of 2.\n  #\n  # line - A {String} representing a line of text.\n  #\n  # Returns a {Number}.\n  indentLevelForLine: (line) ->\n    @displayBuffer.indentLevelForLine(line)\n\n  # Constructs the string used for tabs.\n  buildIndentString: (number) ->\n    if @getSoftTabs()\n      _.multiplyString(\" \", Math.floor(number * @getTabLength()))\n    else\n      _.multiplyString(\"\\t\", Math.floor(number))\n\n  # Public: Saves the editor's text buffer.\n  #\n  # See {TextBuffer::save} for more details.\n  save: -> @buffer.save()\n\n  # Public: Saves the editor's text buffer as the given path.\n  #\n  # See {TextBuffer::saveAs} for more details.\n  #\n  # filePath - A {String} path.\n  saveAs: (filePath) -> @buffer.saveAs(filePath)\n\n  checkoutHead: ->\n    if filePath = @getPath()\n      atom.project.getRepo()?.checkoutHead(filePath)\n\n  # Copies the current file path to the native clipboard.\n  copyPathToClipboard: ->\n    if filePath = @getPath()\n      atom.clipboard.write(filePath)\n\n  # Public: Returns the {String} path of this editor's text buffer.\n  getPath: -> @buffer.getPath()\n\n  # Public: Returns a {String} representing the entire contents of the editor.\n  getText: -> @buffer.getText()\n\n  # Public: Replaces the entire contents of the buffer with the given {String}.\n  setText: (text) -> @buffer.setText(text)\n\n  # Get the text in the given {Range}.\n  #\n  # Returns a {String}.\n  getTextInRange: (range) -> @buffer.getTextInRange(range)\n\n  # Public: Returns a {Number} representing the number of lines in the editor.\n  getLineCount: -> @buffer.getLineCount()\n\n  # Retrieves the current {TextBuffer}.\n  getBuffer: -> @buffer\n\n  # Public: Retrieves the current buffer's URI.\n  getUri: -> @buffer.getUri()\n\n  # {Delegates to: TextBuffer.isRowBlank}\n  isBufferRowBlank: (bufferRow) -> @buffer.isRowBlank(bufferRow)\n\n  # Public: Determine if the given row is entirely a comment\n  isBufferRowCommented: (bufferRow) ->\n    if match = @lineForBufferRow(bufferRow).match(/\\S/)\n      scopes = @tokenForBufferPosition([bufferRow, match.index]).scopes\n      new TextMateScopeSelector('comment.*').matches(scopes)\n\n  # {Delegates to: TextBuffer.nextNonBlankRow}\n  nextNonBlankBufferRow: (bufferRow) -> @buffer.nextNonBlankRow(bufferRow)\n\n  # {Delegates to: TextBuffer.getEndPosition}\n  getEofBufferPosition: -> @buffer.getEndPosition()\n\n  # Public: Returns a {Number} representing the last zero-indexed buffer row\n  # number of the editor.\n  getLastBufferRow: -> @buffer.getLastRow()\n\n  # Returns the range for the given buffer row.\n  #\n  # row - A row {Number}.\n  # options - An options hash with an `includeNewline` key.\n  #\n  # Returns a {Range}.\n  bufferRangeForBufferRow: (row, {includeNewline}={}) -> @buffer.rangeForRow(row, includeNewline)\n\n  # Public: Returns a {String} representing the contents of the line at the\n  # given buffer row.\n  #\n  # row - A {Number} representing a zero-indexed buffer row.\n  lineForBufferRow: (row) -> @buffer.lineForRow(row)\n\n  # Public: Returns a {Number} representing the line length for the given\n  # buffer row, exclusive of its line-ending character(s).\n  #\n  # row - A {Number} indicating the buffer row.\n  lineLengthForBufferRow: (row) -> @buffer.lineLengthForRow(row)\n\n  # {Delegates to: TextBuffer.scan}\n  scan: (args...) -> @buffer.scan(args...)\n\n  # {Delegates to: TextBuffer.scanInRange}\n  scanInBufferRange: (args...) -> @buffer.scanInRange(args...)\n\n  # {Delegates to: TextBuffer.backwardsScanInRange}\n  backwardsScanInBufferRange: (args...) -> @buffer.backwardsScanInRange(args...)\n\n  # {Delegates to: TextBuffer.isModified}\n  isModified: -> @buffer.isModified()\n\n  # Public: Determine whether the user should be prompted to save before closing\n  # this editor.\n  shouldPromptToSave: -> @isModified() and not @buffer.hasMultipleEditors()\n\n  # Public: Convert a position in buffer-coordinates to screen-coordinates.\n  #\n  # The position is clipped via {::clipBufferPosition} prior to the conversion.\n  # The position is also clipped via {::clipScreenPosition} following the\n  # conversion, which only makes a difference when `options` are supplied.\n  #\n  # bufferPosition - A {Point} or {Array} of [row, column].\n  # options - An options hash for {::clipScreenPosition}.\n  #\n  # Returns a {Point}.\n  screenPositionForBufferPosition: (bufferPosition, options) -> @displayBuffer.screenPositionForBufferPosition(bufferPosition, options)\n\n  # Public: Convert a position in screen-coordinates to buffer-coordinates.\n  #\n  # The position is clipped via {::clipScreenPosition} prior to the conversion.\n  #\n  # bufferPosition - A {Point} or {Array} of [row, column].\n  # options - An options hash for {::clipScreenPosition}.\n  #\n  # Returns a {Point}.\n  bufferPositionForScreenPosition: (screenPosition, options) -> @displayBuffer.bufferPositionForScreenPosition(screenPosition, options)\n\n  # Public: Convert a range in buffer-coordinates to screen-coordinates.\n  #\n  # Returns a {Range}.\n  screenRangeForBufferRange: (bufferRange) -> @displayBuffer.screenRangeForBufferRange(bufferRange)\n\n  # Public: Convert a range in screen-coordinates to buffer-coordinates.\n  #\n  # Returns a {Range}.\n  bufferRangeForScreenRange: (screenRange) -> @displayBuffer.bufferRangeForScreenRange(screenRange)\n\n  # Public: Clip the given {Point} to a valid position on screen.\n  #\n  # If the given {Point} describes a position that is actually reachable by the\n  # cursor based on the current contents of the screen, it is returned\n  # unchanged. If the {Point} does not describe a valid position, the closest\n  # valid position is returned instead.\n  #\n  # For example:\n  #   * `[-1, -1]` is converted to `[0, 0]`.\n  #   * If the line at screen row 2 is 10 long, `[2, Infinity]` is converted to\n  #     `[2, 10]`.\n  #\n  # bufferPosition - The {Point} representing the position to clip.\n  #\n  # Returns a {Point}.\n  clipScreenPosition: (screenPosition, options) -> @displayBuffer.clipScreenPosition(screenPosition, options)\n\n  # {Delegates to: DisplayBuffer.lineForRow}\n  lineForScreenRow: (row) -> @displayBuffer.lineForRow(row)\n\n  # {Delegates to: DisplayBuffer.linesForRows}\n  linesForScreenRows: (start, end) -> @displayBuffer.linesForRows(start, end)\n\n  # {Delegates to: DisplayBuffer.getLineCount}\n  getScreenLineCount: -> @displayBuffer.getLineCount()\n\n  # {Delegates to: DisplayBuffer.getMaxLineLength}\n  getMaxScreenLineLength: -> @displayBuffer.getMaxLineLength()\n\n  # {Delegates to: DisplayBuffer.getLastRow}\n  getLastScreenRow: -> @displayBuffer.getLastRow()\n\n  # {Delegates to: DisplayBuffer.bufferRowsForScreenRows}\n  bufferRowsForScreenRows: (startRow, endRow) -> @displayBuffer.bufferRowsForScreenRows(startRow, endRow)\n\n  bufferRowForScreenRow: (row) -> @displayBuffer.bufferRowForScreenRow(row)\n\n  # Public: Get the syntactic scopes for the most the given position in buffer\n  # coorditanates.\n  #\n  # For example, if called with a position inside the parameter list of an\n  # anonymous CoffeeScript function, the method returns the following array:\n  # `[\"source.coffee\", \"meta.inline.function.coffee\", \"variable.parameter.function.coffee\"]`\n  #\n  # bufferPosition - A {Point} or {Array} of [row, column].\n  #\n  # Returns an {Array} of {String}s.\n  scopesForBufferPosition: (bufferPosition) -> @displayBuffer.scopesForBufferPosition(bufferPosition)\n\n  # Public: Get the range in buffer coordinates of all tokens surrounding the\n  # cursor that match the given scope selector.\n  #\n  # For example, if you wanted to find the string surrounding the cursor, you\n  # could call `editor.bufferRangeForScopeAtCursor(\".string.quoted\")`.\n  #\n  # Returns a {Range}.\n  bufferRangeForScopeAtCursor: (selector) ->\n    @displayBuffer.bufferRangeForScopeAtPosition(selector, @getCursorBufferPosition())\n\n  # {Delegates to: DisplayBuffer.tokenForBufferPosition}\n  tokenForBufferPosition: (bufferPosition) -> @displayBuffer.tokenForBufferPosition(bufferPosition)\n\n  # Public: Get the syntactic scopes for the most recently added cursor's\n  # position. See {::scopesForBufferPosition} for more information.\n  #\n  # Returns an {Array} of {String}s.\n  getCursorScopes: -> @getCursor().getScopes()\n\n  logCursorScope: ->\n    console.log @getCursorScopes()\n\n  # Public: For each selection, replace the selected text with the given text.\n  #\n  # text - A {String} representing the text to insert.\n  # options - See {Selection::insertText}.\n  insertText: (text, options={}) ->\n    options.autoIndentNewline ?= @shouldAutoIndent()\n    options.autoDecreaseIndent ?= @shouldAutoIndent()\n    @mutateSelectedText (selection) -> selection.insertText(text, options)\n\n  # Public: For each selection, replace the selected text with a newline.\n  insertNewline: ->\n    @insertText('\\n')\n\n  # Public: For each cursor, insert a newline at beginning the following line.\n  insertNewlineBelow: ->\n    @transact =>\n      @moveCursorToEndOfLine()\n      @insertNewline()\n\n  # Public: For each cursor, insert a newline at the end of the preceding line.\n  insertNewlineAbove: ->\n    @transact =>\n      bufferRow = @getCursorBufferPosition().row\n      indentLevel = @indentationForBufferRow(bufferRow)\n      onFirstLine = bufferRow is 0\n\n      @moveCursorToBeginningOfLine()\n      @moveCursorLeft()\n      @insertNewline()\n\n      if @shouldAutoIndent() and @indentationForBufferRow(bufferRow) < indentLevel\n        @setIndentationForBufferRow(bufferRow, indentLevel)\n\n      if onFirstLine\n        @moveCursorUp()\n        @moveCursorToEndOfLine()\n\n  # Indent all lines intersecting selections. See {Selection::indent} for more\n  # information.\n  indent: (options={})->\n    options.autoIndent ?= @shouldAutoIndent()\n    @mutateSelectedText (selection) -> selection.indent(options)\n\n  # Public: For each selection, if the selection is empty, delete the character\n  # preceding the cursor. Otherwise delete the selected text.\n  backspace: ->\n    @mutateSelectedText (selection) -> selection.backspace()\n\n  # Public: For each selection, if the selection is empty, delete all characters\n  # of the containing word that precede the cursor. Otherwise delete the\n  # selected text.\n  backspaceToBeginningOfWord: ->\n    @mutateSelectedText (selection) -> selection.backspaceToBeginningOfWord()\n\n  # Public: For each selection, if the selection is empty, delete all characters\n  # of the containing line that precede the cursor. Otherwise delete the\n  # selected text.\n  backspaceToBeginningOfLine: ->\n    @mutateSelectedText (selection) -> selection.backspaceToBeginningOfLine()\n\n  # Public: For each selection, if the selection is empty, delete the character\n  # preceding the cursor. Otherwise delete the selected text.\n  delete: ->\n    @mutateSelectedText (selection) -> selection.delete()\n\n  # Public: For each selection, if the selection is empty, delete all characters\n  # of the containing word following the cursor. Otherwise delete the selected\n  # text.\n  deleteToEndOfWord: ->\n    @mutateSelectedText (selection) -> selection.deleteToEndOfWord()\n\n  # Public: Delete all lines intersecting selections.\n  deleteLine: ->\n    @mutateSelectedText (selection) -> selection.deleteLine()\n\n  # Public: Indent rows intersecting selections by one level.\n  indentSelectedRows: ->\n    @mutateSelectedText (selection) -> selection.indentSelectedRows()\n\n  # Public: Outdent rows intersecting selections by one level.\n  outdentSelectedRows: ->\n    @mutateSelectedText (selection) -> selection.outdentSelectedRows()\n\n  # Public: Toggle line comments for rows intersecting selections.\n  #\n  # If the current grammar doesn't support comments, does nothing.\n  #\n  # Returns an {Array} of the commented {Range}s.\n  toggleLineCommentsInSelection: ->\n    @mutateSelectedText (selection) -> selection.toggleLineComments()\n\n  # Public: Indent rows intersecting selections based on the grammar's suggested\n  # indent level.\n  autoIndentSelectedRows: ->\n    @mutateSelectedText (selection) -> selection.autoIndentSelectedRows()\n\n  # If soft tabs are enabled, convert all hard tabs to soft tabs in the given\n  # {Range}.\n  normalizeTabsInBufferRange: (bufferRange) ->\n    return unless @getSoftTabs()\n    @scanInBufferRange /\\t/g, bufferRange, ({replace}) => replace(@getTabText())\n\n  # Public: For each selection, if the selection is empty, cut all characters\n  # of the containing line following the cursor. Otherwise cut the selected\n  # text.\n  cutToEndOfLine: ->\n    maintainClipboard = false\n    @mutateSelectedText (selection) ->\n      selection.cutToEndOfLine(maintainClipboard)\n      maintainClipboard = true\n\n  # Public: For each selection, cut the selected text.\n  cutSelectedText: ->\n    maintainClipboard = false\n    @mutateSelectedText (selection) ->\n      selection.cut(maintainClipboard)\n      maintainClipboard = true\n\n  # Public: For each selection, copy the selected text.\n  copySelectedText: ->\n    maintainClipboard = false\n    for selection in @getSelections()\n      selection.copy(maintainClipboard)\n      maintainClipboard = true\n\n  # Public: For each selection, replace the selected text with the contents of\n  # the clipboard.\n  #\n  # options - See {Selection::insertText}.\n  pasteText: (options={}) ->\n    {text, metadata} = atom.clipboard.readWithMetadata()\n\n    containsNewlines = text.indexOf('\\n') isnt -1\n\n    if atom.config.get('editor.normalizeIndentOnPaste') and metadata\n      if !@getCursor().hasPrecedingCharactersOnLine() or containsNewlines\n        options.indentBasis ?= metadata.indentBasis\n\n    @insertText(text, options)\n\n  # Public: Undo the last change.\n  undo: ->\n    @getCursor().needsAutoscroll = true\n    @buffer.undo(this)\n\n  # Public: Redo the last change.\n  redo: ->\n    @getCursor().needsAutoscroll = true\n    @buffer.redo(this)\n\n  # Public: Fold the most recent cursor's row based on its indentation level.\n  #\n  # The fold will extend from the nearest preceding line with a lower\n  # indentation level up to the nearest following row with a lower indentation\n  # level.\n  foldCurrentRow: ->\n    bufferRow = @bufferPositionForScreenPosition(@getCursorScreenPosition()).row\n    @foldBufferRow(bufferRow)\n\n  # Public: Unfold the most recent cursor's row by one level.\n  unfoldCurrentRow: ->\n    bufferRow = @bufferPositionForScreenPosition(@getCursorScreenPosition()).row\n    @unfoldBufferRow(bufferRow)\n\n  # Public: For each selection, fold the rows it intersects.\n  foldSelectedLines: ->\n    selection.fold() for selection in @getSelections()\n\n  # Public: Fold all foldable lines.\n  foldAll: ->\n    @languageMode.foldAll()\n\n  # Public: Unfold all existing folds.\n  unfoldAll: ->\n    @languageMode.unfoldAll()\n\n  # Public: Fold all foldable lines at the given indent level.\n  #\n  # level - A {Number}.\n  foldAllAtIndentLevel: (level) ->\n    @languageMode.foldAllAtIndentLevel(level)\n\n  # Public: Fold the given row in buffer coordinates based on its indentation\n  # level.\n  #\n  # If the given row is foldable, the fold will begin there. Otherwise, it will\n  # begin at the first foldable row preceding the given row.\n  #\n  # bufferRow - A {Number}.\n  foldBufferRow: (bufferRow) ->\n    @languageMode.foldBufferRow(bufferRow)\n\n  # Public: Unfold all folds containing the given row in buffer coordinates.\n  #\n  # bufferRow - A {Number}\n  unfoldBufferRow: (bufferRow) ->\n    @displayBuffer.unfoldBufferRow(bufferRow)\n\n  # Public: Determine whether the given row in buffer coordinates is foldable.\n  #\n  # A *foldable* row is a row that *starts* a row range that can be folded.\n  #\n  # bufferRow - A {Number}\n  #\n  # Returns a {Boolean}.\n  isFoldableAtBufferRow: (bufferRow) ->\n    @languageMode.isFoldableAtBufferRow(bufferRow)\n\n  # TODO: Rename to foldRowRange?\n  createFold: (startRow, endRow) ->\n    @displayBuffer.createFold(startRow, endRow)\n\n  # {Delegates to: DisplayBuffer.destroyFoldWithId}\n  destroyFoldWithId: (id) ->\n    @displayBuffer.destroyFoldWithId(id)\n\n  # Remove any {Fold}s found that intersect the given buffer row.\n  destroyFoldsIntersectingBufferRange: (bufferRange) ->\n    for row in [bufferRange.start.row..bufferRange.end.row]\n      @unfoldBufferRow(row)\n\n  # Public: Fold the given buffer row if it isn't currently folded, and unfold\n  # it otherwise.\n  toggleFoldAtBufferRow: (bufferRow) ->\n    if @isFoldedAtBufferRow(bufferRow)\n      @unfoldBufferRow(bufferRow)\n    else\n      @foldBufferRow(bufferRow)\n\n  # Public: Determine whether the most recently added cursor's row is folded.\n  #\n  # Returns a {Boolean}.\n  isFoldedAtCursorRow: ->\n    @isFoldedAtScreenRow(@getCursorScreenRow())\n\n  # Public: Determine whether the given row in buffer coordinates is folded.\n  #\n  # bufferRow - A {Number}\n  #\n  # Returns a {Boolean}.\n  isFoldedAtBufferRow: (bufferRow) ->\n    @displayBuffer.isFoldedAtBufferRow(bufferRow)\n\n  # Public: Determine whether the given row in screen coordinates is folded.\n  #\n  # screenRow - A {Number}\n  #\n  # Returns a {Boolean}.\n  isFoldedAtScreenRow: (screenRow) ->\n    @displayBuffer.isFoldedAtScreenRow(screenRow)\n\n  # {Delegates to: DisplayBuffer.largestFoldContainingBufferRow}\n  largestFoldContainingBufferRow: (bufferRow) ->\n    @displayBuffer.largestFoldContainingBufferRow(bufferRow)\n\n  # {Delegates to: DisplayBuffer.largestFoldStartingAtScreenRow}\n  largestFoldStartingAtScreenRow: (screenRow) ->\n    @displayBuffer.largestFoldStartingAtScreenRow(screenRow)\n\n  # {Delegates to: DisplayBuffer.outermostFoldsForBufferRowRange}\n  outermostFoldsInBufferRowRange: (startRow, endRow) ->\n    @displayBuffer.outermostFoldsInBufferRowRange(startRow, endRow)\n\n  # Move lines intersection the most recent selection up by one row in screen\n  # coordinates.\n  moveLineUp: ->\n    selection = @getSelectedBufferRange()\n    return if selection.start.row is 0\n    lastRow = @buffer.getLastRow()\n    return if selection.isEmpty() and selection.start.row is lastRow and @buffer.getLastLine() is ''\n\n    @transact =>\n      foldedRows = []\n      rows = [selection.start.row..selection.end.row]\n      if selection.start.row isnt selection.end.row and selection.end.column is 0\n        rows.pop() unless @isFoldedAtBufferRow(selection.end.row)\n\n      # Move line around the fold that is directly above the selection\n      precedingScreenRow = @screenPositionForBufferPosition([selection.start.row]).translate([-1])\n      precedingBufferRow = @bufferPositionForScreenPosition(precedingScreenRow).row\n      if fold = @largestFoldContainingBufferRow(precedingBufferRow)\n        insertDelta = fold.getBufferRange().getRowCount()\n      else\n        insertDelta = 1\n\n      for row in rows\n        if fold = @displayBuffer.largestFoldStartingAtBufferRow(row)\n          bufferRange = fold.getBufferRange()\n          startRow = bufferRange.start.row\n          endRow = bufferRange.end.row\n          foldedRows.push(startRow - insertDelta)\n        else\n          startRow = row\n          endRow = row\n\n        insertPosition = Point.fromObject([startRow - insertDelta])\n        endPosition = Point.min([endRow + 1], @buffer.getEndPosition())\n        lines = @buffer.getTextInRange([[startRow], endPosition])\n        if endPosition.row is lastRow and endPosition.column > 0 and not @buffer.lineEndingForRow(endPosition.row)\n          lines = \"#{lines}\\n\"\n\n        @buffer.deleteRows(startRow, endRow)\n\n        # Make sure the inserted text doesn't go into an existing fold\n        if fold = @displayBuffer.largestFoldStartingAtBufferRow(insertPosition.row)\n          @unfoldBufferRow(insertPosition.row)\n          foldedRows.push(insertPosition.row + endRow - startRow + fold.getBufferRange().getRowCount())\n\n        @buffer.insert(insertPosition, lines)\n\n      # Restore folds that existed before the lines were moved\n      for foldedRow in foldedRows when 0 <= foldedRow <= @getLastBufferRow()\n        @foldBufferRow(foldedRow)\n\n      @setSelectedBufferRange(selection.translate([-insertDelta]), preserveFolds: true, autoscroll: true)\n\n  # Move lines intersecting the most recent selection down by one row in screen\n  # coordinates.\n  moveLineDown: ->\n    selection = @getSelectedBufferRange()\n    lastRow = @buffer.getLastRow()\n    return if selection.end.row is lastRow\n    return if selection.end.row is lastRow - 1 and @buffer.getLastLine() is ''\n\n    @transact =>\n      foldedRows = []\n      rows = [selection.end.row..selection.start.row]\n      if selection.start.row isnt selection.end.row and selection.end.column is 0\n        rows.shift() unless @isFoldedAtBufferRow(selection.end.row)\n\n      # Move line around the fold that is directly below the selection\n      followingScreenRow = @screenPositionForBufferPosition([selection.end.row]).translate([1])\n      followingBufferRow = @bufferPositionForScreenPosition(followingScreenRow).row\n      if fold = @largestFoldContainingBufferRow(followingBufferRow)\n        insertDelta = fold.getBufferRange().getRowCount()\n      else\n        insertDelta = 1\n\n      for row in rows\n        if fold = @displayBuffer.largestFoldStartingAtBufferRow(row)\n          bufferRange = fold.getBufferRange()\n          startRow = bufferRange.start.row\n          endRow = bufferRange.end.row\n          foldedRows.push(endRow + insertDelta)\n        else\n          startRow = row\n          endRow = row\n\n        if endRow + 1 is lastRow\n          endPosition = [endRow, @buffer.lineLengthForRow(endRow)]\n        else\n          endPosition = [endRow + 1]\n        lines = @buffer.getTextInRange([[startRow], endPosition])\n        @buffer.deleteRows(startRow, endRow)\n\n        insertPosition = Point.min([startRow + insertDelta], @buffer.getEndPosition())\n        if insertPosition.row is @buffer.getLastRow() and insertPosition.column > 0\n          lines = \"\\n#{lines}\"\n\n        # Make sure the inserted text doesn't go into an existing fold\n        if fold = @displayBuffer.largestFoldStartingAtBufferRow(insertPosition.row)\n          @unfoldBufferRow(insertPosition.row)\n          foldedRows.push(insertPosition.row + fold.getBufferRange().getRowCount())\n\n        @buffer.insert(insertPosition, lines)\n\n      # Restore folds that existed before the lines were moved\n      for foldedRow in foldedRows when 0 <= foldedRow <= @getLastBufferRow()\n        @foldBufferRow(foldedRow)\n\n      @setSelectedBufferRange(selection.translate([insertDelta]), preserveFolds: true, autoscroll: true)\n\n  # Duplicate the most recent cursor's current line.\n  duplicateLines: ->\n    @transact =>\n      for selection in @getSelectionsOrderedByBufferPosition().reverse()\n        selectedBufferRange = selection.getBufferRange()\n        if selection.isEmpty()\n          {start} = selection.getScreenRange()\n          selection.selectToScreenPosition([start.row + 1, 0])\n\n        [startRow, endRow] = selection.getBufferRowRange()\n        endRow++\n\n        foldedRowRanges =\n          @outermostFoldsInBufferRowRange(startRow, endRow)\n            .map (fold) -> fold.getBufferRowRange()\n\n        rangeToDuplicate = [[startRow, 0], [endRow, 0]]\n        textToDuplicate = @getTextInBufferRange(rangeToDuplicate)\n        textToDuplicate = '\\n' + textToDuplicate if endRow > @getLastBufferRow()\n        @buffer.insert([endRow, 0], textToDuplicate)\n\n        delta = endRow - startRow\n        selection.setBufferRange(selectedBufferRange.translate([delta, 0]))\n        for [foldStartRow, foldEndRow] in foldedRowRanges\n          @createFold(foldStartRow + delta, foldEndRow + delta)\n\n  # Deprecated: Use {::duplicateLines} instead.\n  duplicateLine: ->\n    deprecate(\"Use Editor::duplicateLines() instead\")\n    @duplicateLines()\n\n  # Public: Mutate the text of all the selections in a single transaction.\n  #\n  # All the changes made inside the given {Function} can be reverted with a\n  # single call to {::undo}.\n  #\n  # fn - A {Function} that will be called with each {Selection}.\n  mutateSelectedText: (fn) ->\n    @transact => fn(selection) for selection in @getSelections()\n\n  replaceSelectedText: (options={}, fn) ->\n    {selectWordIfEmpty} = options\n    @mutateSelectedText (selection) ->\n      range = selection.getBufferRange()\n      if selectWordIfEmpty and selection.isEmpty()\n        selection.selectWord()\n      text = selection.getText()\n      selection.deleteSelectedText()\n      selection.insertText(fn(text))\n      selection.setBufferRange(range)\n\n  # Public: Get the {DisplayBufferMarker} for the given marker id.\n  getMarker: (id) ->\n    @displayBuffer.getMarker(id)\n\n  # Public: Get all {DisplayBufferMarker}s.\n  getMarkers: ->\n    @displayBuffer.getMarkers()\n\n  # Public: Find all {DisplayBufferMarker}s that match the given properties.\n  #\n  # This method finds markers based on the given properties. Markers can be\n  # associated with custom properties that will be compared with basic equality.\n  # In addition, there are several special properties that will be compared\n  # with the range of the markers rather than their properties.\n  #\n  # properties - An {Object} containing properties that each returned marker\n  #   must satisfy. Markers can be associated with custom properties, which are\n  #   compared with basic equality. In addition, several reserved properties\n  #   can be used to filter markers based on their current range:\n  #     :startBufferRow - Only include markers starting at this row in buffer\n  #       coordinates.\n  #     :endBufferRow - Only include markers ending at this row in buffer\n  #       coordinates.\n  #     :containsBufferRange - Only include markers containing this {Range} or\n  #       in range-compatible {Array} in buffer coordinates.\n  #     :containsBufferPosition - Only include markers containing this {Point}\n  #       or {Array} of `[row, column]` in buffer coordinates.\n  findMarkers: (properties) ->\n    @displayBuffer.findMarkers(properties)\n\n  # Public: Mark the given range in screen coordinates.\n  #\n  # range - A {Range} or range-compatible {Array}.\n  # options - See {TextBuffer::markRange}.\n  #\n  # Returns a {DisplayBufferMarker}.\n  markScreenRange: (args...) ->\n    @displayBuffer.markScreenRange(args...)\n\n  # Public: Mark the given range in buffer coordinates.\n  #\n  # range - A {Range} or range-compatible {Array}.\n  # options - See {TextBuffer::markRange}.\n  #\n  # Returns a {DisplayBufferMarker}.\n  markBufferRange: (args...) ->\n    @displayBuffer.markBufferRange(args...)\n\n  # Public: Mark the given position in screen coordinates.\n  #\n  # position - A {Point} or {Array} of `[row, column]`.\n  # options - See {TextBuffer::markRange}.\n  #\n  # Returns a {DisplayBufferMarker}.\n  markScreenPosition: (args...) ->\n    @displayBuffer.markScreenPosition(args...)\n\n  # Public: Mark the given position in buffer coordinates.\n  #\n  # position - A {Point} or {Array} of `[row, column]`.\n  # options - See {TextBuffer::markRange}.\n  #\n  # Returns a {DisplayBufferMarker}.\n  markBufferPosition: (args...) ->\n    @displayBuffer.markBufferPosition(args...)\n\n  # {Delegates to: DisplayBuffer.destroyMarker}\n  destroyMarker: (args...) ->\n    @displayBuffer.destroyMarker(args...)\n\n  # Public: Get the number of markers in this editor's buffer.\n  #\n  # Returns a {Number}.\n  getMarkerCount: ->\n    @buffer.getMarkerCount()\n\n  # Public: Determine if there are multiple cursors.\n  hasMultipleCursors: ->\n    @getCursors().length > 1\n\n  # Public: Get an Array of all {Cursor}s.\n  getCursors: -> new Array(@cursors...)\n\n  # Public: Get the most recently added {Cursor}.\n  getCursor: ->\n    _.last(@cursors)\n\n  # Public: Add a cursor at the position in screen coordinates.\n  #\n  # Returns a {Cursor}.\n  addCursorAtScreenPosition: (screenPosition) ->\n    @markScreenPosition(screenPosition, @getSelectionMarkerAttributes())\n    @getLastSelection().cursor\n\n  # Public: Add a cursor at the given position in buffer coordinates.\n  #\n  # Returns a {Cursor}.\n  addCursorAtBufferPosition: (bufferPosition) ->\n    @markBufferPosition(bufferPosition, @getSelectionMarkerAttributes())\n    @getLastSelection().cursor\n\n  # Add a cursor based on the given {DisplayBufferMarker}.\n  addCursor: (marker) ->\n    cursor = new Cursor(editor: this, marker: marker)\n    @cursors.push(cursor)\n    @emit 'cursor-added', cursor\n    cursor\n\n  # Remove the given cursor from this editor.\n  removeCursor: (cursor) ->\n    _.remove(@cursors, cursor)\n\n  # Add a {Selection} based on the given {DisplayBufferMarker}.\n  #\n  # marker  - The {DisplayBufferMarker} to highlight\n  # options - An {Object} that pertains to the {Selection} constructor.\n  #\n  # Returns the new {Selection}.\n  addSelection: (marker, options={}) ->\n    unless marker.getAttributes().preserveFolds\n      @destroyFoldsIntersectingBufferRange(marker.getBufferRange())\n    cursor = @addCursor(marker)\n    selection = new Selection(_.extend({editor: this, marker, cursor}, options))\n    @selections.push(selection)\n    selectionBufferRange = selection.getBufferRange()\n    @mergeIntersectingSelections()\n    if selection.destroyed\n      for selection in @getSelections()\n        if selection.intersectsBufferRange(selectionBufferRange)\n          return selection\n    else\n      @emit 'selection-added', selection\n      selection\n\n  # Public: Add a selection for the given range in buffer coordinates.\n  #\n  # bufferRange - A {Range}\n  # options - An options {Object}:\n  #   :reversed - A {Boolean} indicating whether to create the selection in a\n  #     reversed orientation.\n  #\n  # Returns the added {Selection}.\n  addSelectionForBufferRange: (bufferRange, options={}) ->\n    @markBufferRange(bufferRange, _.defaults(@getSelectionMarkerAttributes(), options))\n    @getLastSelection()\n\n  # Public: Set the selected range in buffer coordinates. If there are multiple\n  # selections, they are reduced to a single selection with the given range.\n  #\n  # bufferRange - A {Range} or range-compatible {Array}.\n  # options - An options {Object}:\n  #   :reversed - A {Boolean} indicating whether to create the selection in a\n  #     reversed orientation.\n  setSelectedBufferRange: (bufferRange, options) ->\n    @setSelectedBufferRanges([bufferRange], options)\n\n  # Public: Set the selected range in screen coordinates. If there are multiple\n  # selections, they are reduced to a single selection with the given range.\n  #\n  # screenRange - A {Range} or range-compatible {Array}.\n  # options - An options {Object}:\n  #   :reversed - A {Boolean} indicating whether to create the selection in a\n  #     reversed orientation.\n  setSelectedScreenRange: (screenRange, options) ->\n    @setSelectedBufferRange(@bufferRangeForScreenRange(screenRange, options), options)\n\n  # Public: Set the selected ranges in buffer coordinates. If there are multiple\n  # selections, they are replaced by new selections with the given ranges.\n  #\n  # bufferRanges - An {Array} of {Range}s or range-compatible {Array}s.\n  # options - An options {Object}:\n  #   :reversed - A {Boolean} indicating whether to create the selection in a\n  #     reversed orientation.\n  setSelectedBufferRanges: (bufferRanges, options={}) ->\n    throw new Error(\"Passed an empty array to setSelectedBufferRanges\") unless bufferRanges.length\n\n    selections = @getSelections()\n    selection.destroy() for selection in selections[bufferRanges.length...]\n\n    @mergeIntersectingSelections options, =>\n      for bufferRange, i in bufferRanges\n        bufferRange = Range.fromObject(bufferRange)\n        if selections[i]\n          selections[i].setBufferRange(bufferRange, options)\n        else\n          @addSelectionForBufferRange(bufferRange, options)\n\n  # Remove the given selection.\n  removeSelection: (selection) ->\n    _.remove(@selections, selection)\n    @emit 'selection-removed', selection\n\n  # Reduce one or more selections to a single empty selection based on the most\n  # recently added cursor.\n  clearSelections: ->\n    @consolidateSelections()\n    @getSelection().clear()\n\n  # Reduce multiple selections to the most recently added selection.\n  consolidateSelections: ->\n    selections = @getSelections()\n    if selections.length > 1\n      selection.destroy() for selection in selections[0...-1]\n      true\n    else\n      false\n\n  selectionScreenRangeChanged: (selection) ->\n    @emit 'selection-screen-range-changed', selection\n\n  # Public: Get current {Selection}s.\n  #\n  # Returns: An {Array} of {Selection}s.\n  getSelections: -> new Array(@selections...)\n\n  # Public: Get the most recent {Selection} or the selection at the given\n  # index.\n  #\n  # index - Optional. The index of the selection to return, based on the order\n  #   in which the selections were added.\n  #\n  # Returns a {Selection}.\n  # or the  at the specified index.\n  getSelection: (index) ->\n    index ?= @selections.length - 1\n    @selections[index]\n\n  # Public: Get the most recently added {Selection}.\n  #\n  # Returns a {Selection}.\n  getLastSelection: ->\n    _.last(@selections)\n\n  # Public: Get all {Selection}s, ordered by their position in the buffer\n  # instead of the order in which they were added.\n  #\n  # Returns an {Array} of {Selection}s.\n  getSelectionsOrderedByBufferPosition: ->\n    @getSelections().sort (a, b) -> a.compare(b)\n\n  # Public: Get the last {Selection} based on its position in the buffer.\n  #\n  # Returns a {Selection}.\n  getLastSelectionInBuffer: ->\n    _.last(@getSelectionsOrderedByBufferPosition())\n\n  # Public: Determine if a given range in buffer coordinates intersects a\n  # selection.\n  #\n  # bufferRange - A {Range} or range-comptatible {Array}.\n  #\n  # Returns a {Boolean}.\n  selectionIntersectsBufferRange: (bufferRange) ->\n    _.any @getSelections(), (selection) ->\n      selection.intersectsBufferRange(bufferRange)\n\n  # Public: Move the cursor to the given position in screen coordinates.\n  #\n  # If there are multiple cursors, they will be consolidated to a single cursor.\n  #\n  # position - A {Point} or {Array} of `[row, column]`\n  # options  - An {Object} combining options for {::clipScreenPosition} with:\n  #   :autoscroll - Determines whether the editor scrolls to the new cursor's\n  #     position. Defaults to true.\n  setCursorScreenPosition: (position, options) ->\n    @moveCursors (cursor) -> cursor.setScreenPosition(position, options)\n\n  # Public: Get the position of the most recently added cursor in screen\n  # coordinates.\n  #\n  # Returns a {Point}.\n  getCursorScreenPosition: ->\n    @getCursor().getScreenPosition()\n\n  # Public: Get the row of the most recently added cursor in screen coordinates.\n  #\n  # Returns the screen row {Number}.\n  getCursorScreenRow: ->\n    @getCursor().getScreenRow()\n\n  # Public: Move the cursor to the given position in buffer coordinates.\n  #\n  # If there are multiple cursors, they will be consolidated to a single cursor.\n  #\n  # position - A {Point} or {Array} of `[row, column]`\n  # options  - An {Object} combining options for {::clipScreenPosition} with:\n  #   :autoscroll - Determines whether the editor scrolls to the new cursor's\n  #     position. Defaults to true.\n  setCursorBufferPosition: (position, options) ->\n    @moveCursors (cursor) -> cursor.setBufferPosition(position, options)\n\n  # Public: Get the position of the most recently added cursor in buffer\n  # coordinates.\n  #\n  # Returns a {Point}.\n  getCursorBufferPosition: ->\n    @getCursor().getBufferPosition()\n\n  # Public: Get the {Range} of the most recently added selection in screen\n  # coordinates.\n  #\n  # Returns a {Range}.\n  getSelectedScreenRange: ->\n    @getLastSelection().getScreenRange()\n\n  # Public: Get the {Range} of the most recently added selection in buffer\n  # coordinates.\n  #\n  # Returns a {Range}.\n  getSelectedBufferRange: ->\n    @getLastSelection().getBufferRange()\n\n  # Public: Get the {Range}s of all selections in buffer coordinates.\n  #\n  # The ranges are sorted by their position in the buffer.\n  #\n  # Returns an {Array} of {Range}s.\n  getSelectedBufferRanges: ->\n    selection.getBufferRange() for selection in @getSelectionsOrderedByBufferPosition()\n\n  # Public: Get the {Range}s of all selections in screen coordinates.\n  #\n  # The ranges are sorted by their position in the buffer.\n  #\n  # Returns an {Array} of {Range}s.\n  getSelectedScreenRanges: ->\n    selection.getScreenRange() for selection in @getSelectionsOrderedByBufferPosition()\n\n  # Public: Get the selected text of the most recently added selection.\n  #\n  # Returns a {String}.\n  getSelectedText: ->\n    @getLastSelection().getText()\n\n  # Public: Get the text in the given {Range} in buffer coordinates.\n  #\n  # range - A {Range} or range-compatible {Array}.\n  #\n  # Returns a {String}.\n  getTextInBufferRange: (range) ->\n    @buffer.getTextInRange(range)\n\n  # Public: Set the text in the given {Range} in buffer coordinates.\n  #\n  # range - A {Range} or range-compatible {Array}.\n  # text - A {String}\n  #\n  # Returns the {Range} of the newly-inserted text.\n  setTextInBufferRange: (range, text) -> @getBuffer().setTextInRange(range, text)\n\n  # Public: Get the {Range} of the paragraph surrounding the most recently added\n  # cursor.\n  #\n  # Returns a {Range}.\n  getCurrentParagraphBufferRange: ->\n    @getCursor().getCurrentParagraphBufferRange()\n\n  # Public: Returns the word surrounding the most recently added cursor.\n  #\n  # options - See {Cursor::getBeginningOfCurrentWordBufferPosition}.\n  getWordUnderCursor: (options) ->\n    @getTextInBufferRange(@getCursor().getCurrentWordBufferRange(options))\n\n  # Public: Move every cursor up one row in screen coordinates.\n  moveCursorUp: (lineCount) ->\n    @moveCursors (cursor) -> cursor.moveUp(lineCount, moveToEndOfSelection: true)\n\n  # Public: Move every cursor down one row in screen coordinates.\n  moveCursorDown: (lineCount) ->\n    @moveCursors (cursor) -> cursor.moveDown(lineCount, moveToEndOfSelection: true)\n\n  # Public: Move every cursor left one column.\n  moveCursorLeft: ->\n    @moveCursors (cursor) -> cursor.moveLeft(moveToEndOfSelection: true)\n\n  # Public: Move every cursor right one column.\n  moveCursorRight: ->\n    @moveCursors (cursor) -> cursor.moveRight(moveToEndOfSelection: true)\n\n  # Public: Move every cursor to the top of the buffer.\n  #\n  # If there are multiple cursors, they will be merged into a single cursor.\n  moveCursorToTop: ->\n    @moveCursors (cursor) -> cursor.moveToTop()\n\n  # Public: Move every cursor to the bottom of the buffer.\n  #\n  # If there are multiple cursors, they will be merged into a single cursor.\n  moveCursorToBottom: ->\n    @moveCursors (cursor) -> cursor.moveToBottom()\n\n  # Public: Move every cursor to the beginning of its line in screen coordinates.\n  moveCursorToBeginningOfScreenLine: ->\n    @moveCursors (cursor) -> cursor.moveToBeginningOfScreenLine()\n\n  # Public: Move every cursor to the beginning of its line in buffer coordinates.\n  moveCursorToBeginningOfLine: ->\n    @moveCursors (cursor) -> cursor.moveToBeginningOfLine()\n\n  # Public: Move every cursor to the first non-whitespace character of its line.\n  moveCursorToFirstCharacterOfLine: ->\n    @moveCursors (cursor) -> cursor.moveToFirstCharacterOfLine()\n\n  # Public: Move every cursor to the end of its line in screen coordinates.\n  moveCursorToEndOfScreenLine: ->\n    @moveCursors (cursor) -> cursor.moveToEndOfScreenLine()\n\n  # Public: Move every cursor to the end of its line in buffer coordinates.\n  moveCursorToEndOfLine: ->\n    @moveCursors (cursor) -> cursor.moveToEndOfLine()\n\n  # Public: Move every cursor to the beginning of its surrounding word.\n  moveCursorToBeginningOfWord: ->\n    @moveCursors (cursor) -> cursor.moveToBeginningOfWord()\n\n  # Public: Move every cursor to the end of its surrounding word.\n  moveCursorToEndOfWord: ->\n    @moveCursors (cursor) -> cursor.moveToEndOfWord()\n\n  # Public: Move every cursor to the beginning of the next word.\n  moveCursorToBeginningOfNextWord: ->\n    @moveCursors (cursor) -> cursor.moveToBeginningOfNextWord()\n\n  # Public: Move every cursor to the previous word boundary.\n  moveCursorToPreviousWordBoundary: ->\n    @moveCursors (cursor) -> cursor.moveToPreviousWordBoundary()\n\n  # Public: Move every cursor to the next word boundary.\n  moveCursorToNextWordBoundary: ->\n    @moveCursors (cursor) -> cursor.moveToNextWordBoundary()\n\n  scrollToCursorPosition: ->\n    @getCursor().autoscroll()\n\n  pageUp: ->\n    @setScrollTop(@getScrollTop() - @getHeight())\n\n  pageDown: ->\n    @setScrollTop(@getScrollTop() + @getHeight())\n\n  moveCursors: (fn) ->\n    @movingCursors = true\n    @batchUpdates =>\n      fn(cursor) for cursor in @getCursors()\n      @mergeCursors()\n      @movingCursors = false\n      @emit 'cursors-moved'\n\n  cursorMoved: (event) ->\n    @emit 'cursor-moved', event\n    @emit 'cursors-moved' unless @movingCursors\n\n  # Public: Select from the current cursor position to the given position in\n  # screen coordinates.\n  #\n  # This method may merge selections that end up intesecting.\n  #\n  # position - An instance of {Point}, with a given `row` and `column`.\n  selectToScreenPosition: (position) ->\n    lastSelection = @getLastSelection()\n    lastSelection.selectToScreenPosition(position)\n    @mergeIntersectingSelections(reversed: lastSelection.isReversed())\n\n  # Public: Move the cursor of each selection one character rightward while\n  # preserving the selection's tail position.\n  #\n  # This method may merge selections that end up intesecting.\n  selectRight: ->\n    @expandSelectionsForward (selection) => selection.selectRight()\n\n  # Public: Move the cursor of each selection one character leftward while\n  # preserving the selection's tail position.\n  #\n  # This method may merge selections that end up intesecting.\n  selectLeft: ->\n    @expandSelectionsBackward (selection) => selection.selectLeft()\n\n  # Public: Move the cursor of each selection one character upward while\n  # preserving the selection's tail position.\n  #\n  # This method may merge selections that end up intesecting.\n  selectUp: (rowCount) ->\n    @expandSelectionsBackward (selection) => selection.selectUp(rowCount)\n\n  # Public: Move the cursor of each selection one character downward while\n  # preserving the selection's tail position.\n  #\n  # This method may merge selections that end up intesecting.\n  selectDown: (rowCount) ->\n    @expandSelectionsForward (selection) => selection.selectDown(rowCount)\n\n  # Public: Select from the top of the buffer to the end of the last selection\n  # in the buffer.\n  #\n  # This method merges multiple selections into a single selection.\n  selectToTop: ->\n    @expandSelectionsBackward (selection) => selection.selectToTop()\n\n  # Public: Select all text in the buffer.\n  #\n  # This method merges multiple selections into a single selection.\n  selectAll: ->\n    @expandSelectionsForward (selection) => selection.selectAll()\n\n  # Public: Selects from the top of the first selection in the buffer to the end\n  # of the buffer.\n  #\n  # This method merges multiple selections into a single selection.\n  selectToBottom: ->\n    @expandSelectionsForward (selection) => selection.selectToBottom()\n\n  # Public: Move the cursor of each selection to the beginning of its line\n  # while preserving the selection's tail position.\n  #\n  # This method may merge selections that end up intesecting.\n  selectToBeginningOfLine: ->\n    @expandSelectionsBackward (selection) => selection.selectToBeginningOfLine()\n\n  # Public: Move the cursor of each selection to the first non-whitespace\n  # character of its line while preserving the selection's tail position. If the\n  # cursor is already on the first character of the line, move it to the\n  # beginning of the line.\n  #\n  # This method may merge selections that end up intesecting.\n  selectToFirstCharacterOfLine: ->\n    @expandSelectionsBackward (selection) => selection.selectToFirstCharacterOfLine()\n\n  # Public: Move the cursor of each selection to the end of its line while\n  # preserving the selection's tail position.\n  #\n  # This method may merge selections that end up intesecting.\n  selectToEndOfLine: ->\n    @expandSelectionsForward (selection) => selection.selectToEndOfLine()\n\n  # Public: For each selection, move its cursor to the preceding word boundary\n  # while maintaining the selection's tail position.\n  #\n  # This method may merge selections that end up intesecting.\n  selectToPreviousWordBoundary: ->\n    @expandSelectionsBackward (selection) => selection.selectToPreviousWordBoundary()\n\n  # Public: For each selection, move its cursor to the next word boundary while\n  # maintaining the selection's tail position.\n  #\n  # This method may merge selections that end up intesecting.\n  selectToNextWordBoundary: ->\n    @expandSelectionsForward (selection) => selection.selectToNextWordBoundary()\n\n  # Public: For each cursor, select the containing line.\n  #\n  # This method merges selections on successive lines.\n  selectLine: ->\n    @expandSelectionsForward (selection) => selection.selectLine()\n\n  # Public: Add a similarly-shaped selection to the next elibible line below\n  # each selection.\n  #\n  # Operates on all selections. If the selection is empty, adds an empty\n  # selection to the next following non-empty line as close to the current\n  # selection's column as possible. If the selection is non-empty, adds a\n  # selection to the next line that is long enough for a non-empty selection\n  # starting at the same column as the current selection to be added to it.\n  addSelectionBelow: ->\n    @expandSelectionsForward (selection) => selection.addSelectionBelow()\n\n  # Public: Add a similarly-shaped selection to the next elibible line above\n  # each selection.\n  #\n  # Operates on all selections. If the selection is empty, adds an empty\n  # selection to the next preceding non-empty line as close to the current\n  # selection's column as possible. If the selection is non-empty, adds a\n  # selection to the next line that is long enough for a non-empty selection\n  # starting at the same column as the current selection to be added to it.\n  addSelectionAbove: ->\n    @expandSelectionsBackward (selection) => selection.addSelectionAbove()\n\n  # Public: Split multi-line selections into one selection per line.\n  #\n  # Operates on all selections. This method breaks apart all multi-line\n  # selections to create multiple single-line selections that cumulatively cover\n  # the same original area.\n  splitSelectionsIntoLines: ->\n    for selection in @getSelections()\n      range = selection.getBufferRange()\n      continue if range.isSingleLine()\n\n      selection.destroy()\n      {start, end} = range\n      @addSelectionForBufferRange([start, [start.row, Infinity]])\n      {row} = start\n      while ++row < end.row\n        @addSelectionForBufferRange([[row, 0], [row, Infinity]])\n      @addSelectionForBufferRange([[end.row, 0], [end.row, end.column]])\n\n  # Public: For each selection, transpose the selected text.\n  #\n  # If the selection is empty, the characters preceding and following the cursor\n  # are swapped. Otherwise, the selected characters are reversed.\n  transpose: ->\n    @mutateSelectedText (selection) =>\n      if selection.isEmpty()\n        selection.selectRight()\n        text = selection.getText()\n        selection.delete()\n        selection.cursor.moveLeft()\n        selection.insertText text\n      else\n        selection.insertText selection.getText().split('').reverse().join('')\n\n  # Public: Convert the selected text to upper case.\n  #\n  # For each selection, if the selection is empty, converts the containing word\n  # to upper case. Otherwise convert the selected text to upper case.\n  upperCase: ->\n    @replaceSelectedText selectWordIfEmpty:true, (text) => text.toUpperCase()\n\n  # Public: Convert the selected text to lower case.\n  #\n  # For each selection, if the selection is empty, converts the containing word\n  # to upper case. Otherwise convert the selected text to upper case.\n  lowerCase: ->\n    @replaceSelectedText selectWordIfEmpty:true, (text) => text.toLowerCase()\n\n  # Convert multiple lines to a single line.\n  #\n  # Operates on all selections. If the selection is empty, joins the current\n  # line with the next line. Otherwise it joins all lines that intersect the\n  # selection.\n  #\n  # Joining a line means that multiple lines are converted to a single line with\n  # the contents of each of the original non-empty lines separated by a space.\n  joinLines: ->\n    @mutateSelectedText (selection) -> selection.joinLines()\n\n  # Public: Expand selections to the beginning of their containing word.\n  #\n  # Operates on all selections. Moves the cursor to the beginning of the\n  # containing word while preserving the selection's tail position.\n  selectToBeginningOfWord: ->\n    @expandSelectionsBackward (selection) => selection.selectToBeginningOfWord()\n\n  # Public: Expand selections to the end of their containing word.\n  #\n  # Operates on all selections. Moves the cursor to the end of the containing\n  # word while preserving the selection's tail position.\n  selectToEndOfWord: ->\n    @expandSelectionsForward (selection) => selection.selectToEndOfWord()\n\n  # Public: Expand selections to the beginning of the next word.\n  #\n  # Operates on all selections. Moves the cursor to the beginning of the next\n  # word while preserving the selection's tail position.\n  selectToBeginningOfNextWord: ->\n    @expandSelectionsForward (selection) => selection.selectToBeginningOfNextWord()\n\n  # Public: Select the word containing each cursor.\n  selectWord: ->\n    @expandSelectionsForward (selection) => selection.selectWord()\n\n  # Public: Select the range of the given marker if it is valid.\n  #\n  # marker - A {DisplayBufferMarker}\n  #\n  # Returns the selected {Range} or `undefined` if the marker is invalid.\n  selectMarker: (marker) ->\n    if marker.isValid()\n      range = marker.getBufferRange()\n      @setSelectedBufferRange(range)\n      range\n\n  # Merge cursors that have the same screen position\n  mergeCursors: ->\n    positions = []\n    for cursor in @getCursors()\n      position = cursor.getBufferPosition().toString()\n      if position in positions\n        cursor.destroy()\n      else\n        positions.push(position)\n\n  # Calls the given function with each selection, then merges selections\n  expandSelectionsForward: (fn) ->\n    @mergeIntersectingSelections =>\n      fn(selection) for selection in @getSelections()\n\n  # Calls the given function with each selection, then merges selections in the\n  # reversed orientation\n  expandSelectionsBackward: (fn) ->\n    @mergeIntersectingSelections reversed: true, =>\n      fn(selection) for selection in @getSelections()\n\n  finalizeSelections: ->\n    selection.finalize() for selection in @getSelections()\n\n  # Merges intersecting selections. If passed a function, it executes\n  # the function with merging suppressed, then merges intersecting selections\n  # afterward.\n  mergeIntersectingSelections: (args...) ->\n    fn = args.pop() if _.isFunction(_.last(args))\n    options = args.pop() ? {}\n\n    return fn?() if @suppressSelectionMerging\n\n    if fn?\n      @suppressSelectionMerging = true\n      result = fn()\n      @suppressSelectionMerging = false\n\n    reducer = (disjointSelections, selection) ->\n      intersectingSelection = _.find(disjointSelections, (s) -> s.intersectsWith(selection))\n      if intersectingSelection?\n        intersectingSelection.merge(selection, options)\n        disjointSelections\n      else\n        disjointSelections.concat([selection])\n\n    _.reduce(@getSelections(), reducer, [])\n\n  preserveCursorPositionOnBufferReload: ->\n    cursorPosition = null\n    @subscribe @buffer, \"will-reload\", =>\n      cursorPosition = @getCursorBufferPosition()\n    @subscribe @buffer, \"reloaded\", =>\n      @setCursorBufferPosition(cursorPosition) if cursorPosition\n      cursorPosition = null\n\n  # Public: Get the current {Grammar} of this editor.\n  getGrammar: ->\n    @displayBuffer.getGrammar()\n\n  # Public: Set the current {Grammar} of this editor.\n  #\n  # Assigning a grammar will cause the editor to re-tokenize based on the new\n  # grammar.\n  setGrammar: (grammar) ->\n    @displayBuffer.setGrammar(grammar)\n\n  # Reload the grammar based on the file name.\n  reloadGrammar: ->\n    @displayBuffer.reloadGrammar()\n\n  shouldAutoIndent: ->\n    atom.config.get(\"editor.autoIndent\")\n\n  # Public: Batch multiple operations as a single undo/redo step.\n  #\n  # Any group of operations that are logically grouped from the perspective of\n  # undoing and redoing should be performed in a transaction. If you want to\n  # abort the transaction, call {::abortTransaction} to terminate the function's\n  # execution and revert any changes performed up to the abortion.\n  #\n  # fn - A {Function} to call inside the transaction.\n  transact: (fn) ->\n    @batchUpdates =>\n      @buffer.transact(fn)\n\n  # Public: Start an open-ended transaction.\n  #\n  # Call {::commitTransaction} or {::abortTransaction} to terminate the\n  # transaction. If you nest calls to transactions, only the outermost\n  # transaction is considered. You must match every begin with a matching\n  # commit, but a single call to abort will cancel all nested transactions.\n  beginTransaction: -> @buffer.beginTransaction()\n\n  # Public: Commit an open-ended transaction started with {::beginTransaction}\n  # and push it to the undo stack.\n  #\n  # If transactions are nested, only the outermost commit takes effect.\n  commitTransaction: -> @buffer.commitTransaction()\n\n  # Public: Abort an open transaction, undoing any operations performed so far\n  # within the transaction.\n  abortTransaction: -> @buffer.abortTransaction()\n\n  batchUpdates: (fn) ->\n    @emit 'batched-updates-started'\n    result = fn()\n    @emit 'batched-updates-ended'\n    result\n\n  inspect: ->\n    \"<Editor #{@id}>\"\n\n  logScreenLines: (start, end) -> @displayBuffer.logLines(start, end)\n\n  handleGrammarChange: ->\n    @unfoldAll()\n    @emit 'grammar-changed'\n\n  handleMarkerCreated: (marker) =>\n    if marker.matchesAttributes(@getSelectionMarkerAttributes())\n      @addSelection(marker)\n\n  getSelectionMarkerAttributes: ->\n    type: 'selection', editorId: @id, invalidate: 'never'\n\n  getVerticalScrollMargin: -> @displayBuffer.getVerticalScrollMargin()\n  setVerticalScrollMargin: (verticalScrollMargin) -> @displayBuffer.setVerticalScrollMargin(verticalScrollMargin)\n\n  getHorizontalScrollMargin: -> @displayBuffer.getHorizontalScrollMargin()\n  setHorizontalScrollMargin: (horizontalScrollMargin) -> @displayBuffer.setHorizontalScrollMargin(horizontalScrollMargin)\n\n  getLineHeight: -> @displayBuffer.getLineHeight()\n  setLineHeight: (lineHeight) -> @displayBuffer.setLineHeight(lineHeight)\n\n  getScopedCharWidth: (scopeNames, char) -> @displayBuffer.getScopedCharWidth(scopeNames, char)\n  setScopedCharWidth: (scopeNames, char, width) -> @displayBuffer.setScopedCharWidth(scopeNames, char, width)\n\n  getScopedCharWidths: (scopeNames) -> @displayBuffer.getScopedCharWidths(scopeNames)\n\n  clearScopedCharWidths: -> @displayBuffer.clearScopedCharWidths()\n\n  getDefaultCharWidth: -> @displayBuffer.getDefaultCharWidth()\n  setDefaultCharWidth: (defaultCharWidth) -> @displayBuffer.setDefaultCharWidth(defaultCharWidth)\n\n  setHeight: (height) -> @displayBuffer.setHeight(height)\n  getHeight: -> @displayBuffer.getHeight()\n\n  setWidth: (width) -> @displayBuffer.setWidth(width)\n  getWidth: -> @displayBuffer.getWidth()\n\n  getScrollTop: -> @displayBuffer.getScrollTop()\n  setScrollTop: (scrollTop) -> @displayBuffer.setScrollTop(scrollTop)\n\n  getScrollBottom: -> @displayBuffer.getScrollBottom()\n  setScrollBottom: (scrollBottom) -> @displayBuffer.setScrollBottom(scrollBottom)\n\n  getScrollLeft: -> @displayBuffer.getScrollLeft()\n  setScrollLeft: (scrollLeft) -> @displayBuffer.setScrollLeft(scrollLeft)\n\n  getScrollRight: -> @displayBuffer.getScrollRight()\n  setScrollRight: (scrollRight) -> @displayBuffer.setScrollRight(scrollRight)\n\n  getScrollHeight: -> @displayBuffer.getScrollHeight()\n  getScrollWidth: (scrollWidth) -> @displayBuffer.getScrollWidth(scrollWidth)\n\n  getVisibleRowRange: -> @displayBuffer.getVisibleRowRange()\n\n  intersectsVisibleRowRange: (startRow, endRow) -> @displayBuffer.intersectsVisibleRowRange(startRow, endRow)\n\n  selectionIntersectsVisibleRowRange: (selection) -> @displayBuffer.selectionIntersectsVisibleRowRange(selection)\n\n  pixelPositionForScreenPosition: (screenPosition) -> @displayBuffer.pixelPositionForScreenPosition(screenPosition)\n\n  pixelPositionForBufferPosition: (bufferPosition) -> @displayBuffer.pixelPositionForBufferPosition(bufferPosition)\n\n  screenPositionForPixelPosition: (pixelPosition) -> @displayBuffer.screenPositionForPixelPosition(pixelPosition)\n\n  pixelRectForScreenRange: (screenRange) -> @displayBuffer.pixelRectForScreenRange(screenRange)\n\n  scrollToScreenRange: (screenRange) -> @displayBuffer.scrollToScreenRange(screenRange)\n\n  scrollToScreenPosition: (screenPosition) -> @displayBuffer.scrollToScreenPosition(screenPosition)\n\n  scrollToBufferPosition: (bufferPosition) -> @displayBuffer.scrollToBufferPosition(bufferPosition)\n\n  # Deprecated: Call {::joinLines} instead.\n  joinLine: ->\n    deprecate(\"Use Editor::joinLines() instead\")\n    @joinLines()\n","markers":{"markers":{"1":{"id":1,"range":[[387,20],[387,20]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":53,"autoscroll":true,"goalBufferRange":null,"preserveFolds":true},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/zk/napplelabs/atom/src/editor.coffee","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"9f7aabd8a06166066fff29ba889cf58d0000aa6a","deserializer":"TextBuffer"},{"text":"{Point, Range} = require 'text-buffer'\n{Model} = require 'theorist'\n{pick} = require 'underscore-plus'\n\n# Public: Represents a selection in the {Editor}.\nmodule.exports =\nclass Selection extends Model\n  cursor: null\n  marker: null\n  editor: null\n  initialScreenRange: null\n  wordwise: false\n  needsAutoscroll: null\n\n  constructor: ({@cursor, @marker, @editor, id}) ->\n    @assignId(id)\n    @cursor.selection = this\n    @marker.on 'changed', => @screenRangeChanged()\n    @marker.on 'destroyed', =>\n      @destroyed = true\n      @editor.removeSelection(this)\n      @emit 'destroyed' unless @editor.isDestroyed()\n\n  destroy: ->\n    @marker.destroy()\n\n  finalize: ->\n    @initialScreenRange = null unless @initialScreenRange?.isEqual(@getScreenRange())\n    if @isEmpty()\n      @wordwise = false\n      @linewise = false\n\n  clearAutoscroll: ->\n    @needsAutoscroll = null\n\n  # Public: Determines if the selection contains anything.\n  isEmpty: ->\n    @getBufferRange().isEmpty()\n\n  # Public: Determines if the ending position of a marker is greater than the\n  # starting position.\n  #\n  # This can happen when, for example, you highlight text \"up\" in a {TextBuffer}.\n  isReversed: ->\n    @marker.isReversed()\n\n  # Public: Returns whether the selection is a single line or not.\n  isSingleScreenLine: ->\n    @getScreenRange().isSingleLine()\n\n  # Public: Returns the screen {Range} for the selection.\n  getScreenRange: ->\n    @marker.getScreenRange()\n\n  # Public: Modifies the screen range for the selection.\n  #\n  # screenRange - The new {Range} to use.\n  # options - A hash of options matching those found in {::setBufferRange}.\n  setScreenRange: (screenRange, options) ->\n    @setBufferRange(@editor.bufferRangeForScreenRange(screenRange), options)\n\n  # Public: Returns the buffer {Range} for the selection.\n  getBufferRange: ->\n    @marker.getBufferRange()\n\n  # Public: Modifies the buffer {Range} for the selection.\n  #\n  # screenRange - The new {Range} to select.\n  # options - An {Object} with the keys:\n  #   :preserveFolds - if `true`, the fold settings are preserved after the\n  #                    selection moves.\n  #   :autoscroll - if `true`, the {Editor} scrolls to the new selection.\n  setBufferRange: (bufferRange, options={}) ->\n    bufferRange = Range.fromObject(bufferRange)\n    @needsAutoscroll = options.autoscroll\n    options.reversed ?= @isReversed()\n    @editor.destroyFoldsIntersectingBufferRange(bufferRange) unless options.preserveFolds\n    @modifySelection =>\n      @cursor.needsAutoscroll = false if @needsAutoscroll?\n      @marker.setBufferRange(bufferRange, options)\n      @autoscroll() if @needsAutoscroll and @editor.manageScrollPosition\n\n  # Public: Returns the starting and ending buffer rows the selection is\n  # highlighting.\n  #\n  # Returns an {Array} of two {Number}s: the starting row, and the ending row.\n  getBufferRowRange: ->\n    range = @getBufferRange()\n    start = range.start.row\n    end = range.end.row\n    end = Math.max(start, end - 1) if range.end.column == 0\n    [start, end]\n\n  autoscroll: ->\n    @editor.scrollToScreenRange(@getScreenRange())\n\n  # Public: Returns the text in the selection.\n  getText: ->\n    @editor.buffer.getTextInRange(@getBufferRange())\n\n  # Public: Clears the selection, moving the marker to the head.\n  clear: ->\n    @marker.setAttributes(goalBufferRange: null)\n    @marker.clearTail() unless @retainSelection\n    @finalize()\n\n  # Public: Modifies the selection to encompass the current word.\n  #\n  # Returns a {Range}.\n  selectWord: ->\n    options = {}\n    options.wordRegex = /[\\t ]*/ if @cursor.isSurroundedByWhitespace()\n    if @cursor.isBetweenWordAndNonWord()\n      options.includeNonWordCharacters = false\n\n    @setBufferRange(@cursor.getCurrentWordBufferRange(options))\n    @wordwise = true\n    @initialScreenRange = @getScreenRange()\n\n  # Public: Expands the newest selection to include the entire word on which\n  # the cursors rests.\n  expandOverWord: ->\n    @setBufferRange(@getBufferRange().union(@cursor.getCurrentWordBufferRange()))\n\n  # Public: Selects an entire line in the buffer.\n  #\n  # row - The line {Number} to select (default: the row of the cursor).\n  selectLine: (row=@cursor.getBufferPosition().row) ->\n    range = @editor.bufferRangeForBufferRow(row, includeNewline: true)\n    @setBufferRange(@getBufferRange().union(range))\n    @linewise = true\n    @wordwise = false\n    @initialScreenRange = @getScreenRange()\n\n  # Public: Expands the newest selection to include the entire line on which\n  # the cursor currently rests.\n  #\n  # It also includes the newline character.\n  expandOverLine: ->\n    range = @getBufferRange().union(@cursor.getCurrentLineBufferRange(includeNewline: true))\n    @setBufferRange(range)\n\n  # Public: Selects the text from the current cursor position to a given screen\n  # position.\n  #\n  # position - An instance of {Point}, with a given `row` and `column`.\n  selectToScreenPosition: (position) ->\n    position = Point.fromObject(position)\n\n    @modifySelection =>\n      if @initialScreenRange\n        if position.isLessThan(@initialScreenRange.start)\n          @marker.setScreenRange([position, @initialScreenRange.end], reversed: true)\n        else\n          @marker.setScreenRange([@initialScreenRange.start, position])\n      else\n        @cursor.setScreenPosition(position)\n\n      if @linewise\n        @expandOverLine()\n      else if @wordwise\n        @expandOverWord()\n\n  # Public: Selects the text from the current cursor position to a given buffer\n  # position.\n  #\n  # position - An instance of {Point}, with a given `row` and `column`.\n  selectToBufferPosition: (position) ->\n    @modifySelection => @cursor.setBufferPosition(position)\n\n  # Public: Selects the text one position right of the cursor.\n  selectRight: ->\n    @modifySelection => @cursor.moveRight()\n\n  # Public: Selects the text one position left of the cursor.\n  selectLeft: ->\n    @modifySelection => @cursor.moveLeft()\n\n  # Public: Selects all the text one position above the cursor.\n  selectUp: (rowCount) ->\n    @modifySelection => @cursor.moveUp(rowCount)\n\n  # Public: Selects all the text one position below the cursor.\n  selectDown: (rowCount) ->\n    @modifySelection => @cursor.moveDown(rowCount)\n\n  # Public: Selects all the text from the current cursor position to the top of\n  # the buffer.\n  selectToTop: ->\n    @modifySelection => @cursor.moveToTop()\n\n  # Public: Selects all the text from the current cursor position to the bottom\n  # of the buffer.\n  selectToBottom: ->\n    @modifySelection => @cursor.moveToBottom()\n\n  # Public: Selects all the text in the buffer.\n  selectAll: ->\n    @setBufferRange(@editor.buffer.getRange(), autoscroll: false)\n\n  # Public: Selects all the text from the current cursor position to the\n  # beginning of the line.\n  selectToBeginningOfLine: ->\n    @modifySelection => @cursor.moveToBeginningOfLine()\n\n  # Public: Selects all the text from the current cursor position to the first\n  # character of the line.\n  selectToFirstCharacterOfLine: ->\n    @modifySelection => @cursor.moveToFirstCharacterOfLine()\n\n  # Public: Selects all the text from the current cursor position to the end of\n  # the line.\n  selectToEndOfLine: ->\n    @modifySelection => @cursor.moveToEndOfScreenLine()\n\n  # Public: Selects all the text from the current cursor position to the\n  # beginning of the word.\n  selectToBeginningOfWord: ->\n    @modifySelection => @cursor.moveToBeginningOfWord()\n\n  # Public: Selects all the text from the current cursor position to the end of\n  # the word.\n  selectToEndOfWord: ->\n    @modifySelection => @cursor.moveToEndOfWord()\n\n  # Public: Selects all the text from the current cursor position to the\n  # beginning of the next word.\n  selectToBeginningOfNextWord: ->\n    @modifySelection => @cursor.moveToBeginningOfNextWord()\n\n  # Public: Selects text to the previous word boundary.\n  selectToPreviousWordBoundary: ->\n    @modifySelection => @cursor.moveToPreviousWordBoundary()\n\n  # Public: Selects text to the next word boundary.\n  selectToNextWordBoundary: ->\n    @modifySelection => @cursor.moveToNextWordBoundary()\n\n  # Public: Moves the selection down one row.\n  addSelectionBelow: ->\n    range = (@getGoalBufferRange() ? @getBufferRange()).copy()\n    nextRow = range.end.row + 1\n\n    for row in [nextRow..@editor.getLastBufferRow()]\n      range.start.row = row\n      range.end.row = row\n      clippedRange = @editor.clipBufferRange(range)\n\n      if range.isEmpty()\n        continue if range.end.column > 0 and clippedRange.end.column is 0\n      else\n        continue if clippedRange.isEmpty()\n\n      @editor.addSelectionForBufferRange(range, goalBufferRange: range)\n      break\n\n  # FIXME: I have no idea what this does.\n  getGoalBufferRange: ->\n    @marker.getAttributes().goalBufferRange\n\n  # Public: Moves the selection up one row.\n  addSelectionAbove: ->\n    range = (@getGoalBufferRange() ? @getBufferRange()).copy()\n    previousRow = range.end.row - 1\n\n    for row in [previousRow..0]\n      range.start.row = row\n      range.end.row = row\n      clippedRange = @editor.clipBufferRange(range)\n\n      if range.isEmpty()\n        continue if range.end.column > 0 and clippedRange.end.column is 0\n      else\n        continue if clippedRange.isEmpty()\n\n      @editor.addSelectionForBufferRange(range, goalBufferRange: range)\n      break\n\n  # Public: Replaces text at the current selection.\n  #\n  # text - A {String} representing the text to add\n  # options - An {Object} with keys:\n  #   :select - if `true`, selects the newly added text.\n  #   :autoIndent - if `true`, indents all inserted text appropriately.\n  #   :autoIndentNewline - if `true`, indent newline appropriately.\n  #   :autoDecreaseIndent - if `true`, decreases indent level appropriately\n  #                         (for example, when a closing bracket is inserted).\n  #   :undo - if `skip`, skips the undo stack for this operation.\n  insertText: (text, options={}) ->\n    oldBufferRange = @getBufferRange()\n    @editor.unfoldBufferRow(oldBufferRange.end.row)\n    wasReversed = @isReversed()\n    @clear()\n    @cursor.needsAutoscroll = @cursor.isLastCursor()\n\n    if options.indentBasis? and not options.autoIndent\n      text = @normalizeIndents(text, options.indentBasis)\n\n    newBufferRange = @editor.buffer.setTextInRange(oldBufferRange, text, pick(options, 'undo'))\n    if options.select\n      @setBufferRange(newBufferRange, reversed: wasReversed)\n    else\n      @cursor.setBufferPosition(newBufferRange.end, skipAtomicTokens: true) if wasReversed\n\n    if options.autoIndent\n      @editor.autoIndentBufferRow(row) for row in newBufferRange.getRows()\n    else if options.autoIndentNewline and text == '\\n'\n      @editor.autoIndentBufferRow(newBufferRange.end.row, preserveLeadingWhitespace: true)\n    else if options.autoDecreaseIndent and /\\S/.test text\n      @editor.autoDecreaseIndentForBufferRow(newBufferRange.start.row)\n\n    newBufferRange\n\n  # Public: Indents the given text to the suggested level based on the grammar.\n  #\n  # text - The {String} to indent within the selection.\n  # indentBasis - The beginning indent level.\n  normalizeIndents: (text, indentBasis) ->\n    textPrecedingCursor = @cursor.getCurrentBufferLine()[0...@cursor.getBufferColumn()]\n    isCursorInsideExistingLine = /\\S/.test(textPrecedingCursor)\n\n    lines = text.split('\\n')\n    firstLineIndentLevel = @editor.indentLevelForLine(lines[0])\n    if isCursorInsideExistingLine\n      minimumIndentLevel = @editor.indentationForBufferRow(@cursor.getBufferRow())\n    else\n      minimumIndentLevel = @cursor.getIndentLevel()\n\n    normalizedLines = []\n    for line, i in lines\n      if i == 0\n        indentLevel = 0\n      else if line == '' # remove all indentation from empty lines\n        indentLevel = 0\n      else\n        lineIndentLevel = @editor.indentLevelForLine(lines[i])\n        indentLevel = minimumIndentLevel + (lineIndentLevel - indentBasis)\n\n      normalizedLines.push(@setIndentationForLine(line, indentLevel))\n\n    normalizedLines.join('\\n')\n\n  # Indent the current line(s).\n  #\n  # If the selection is empty, indents the current line if the cursor precedes\n  # non-whitespace characters, and otherwise inserts a tab. If the selection is\n  # non empty, calls {::indentSelectedRows}.\n  #\n  # options - A {Object} with the keys:\n  #   :autoIndent - If `true`, the line is indented to an automatically-inferred\n  #                 level. Otherwise, {Editor::getTabText} is inserted.\n  indent: ({ autoIndent }={})->\n    { row, column } = @cursor.getBufferPosition()\n\n    if @isEmpty()\n      @cursor.skipLeadingWhitespace()\n      desiredIndent = @editor.suggestedIndentForBufferRow(row)\n      delta = desiredIndent - @cursor.getIndentLevel()\n\n      if autoIndent and delta > 0\n        @insertText(@editor.buildIndentString(delta))\n      else\n        @insertText(@editor.getTabText())\n    else\n      @indentSelectedRows()\n\n  # Public: If the selection spans multiple rows, indent all of them.\n  indentSelectedRows: ->\n    [start, end] = @getBufferRowRange()\n    for row in [start..end]\n      @editor.buffer.insert([row, 0], @editor.getTabText()) unless @editor.buffer.lineLengthForRow(row) == 0\n\n  # Public: ?\n  setIndentationForLine: (line, indentLevel) ->\n    desiredIndentLevel = Math.max(0, indentLevel)\n    desiredIndentString = @editor.buildIndentString(desiredIndentLevel)\n    line.replace(/^[\\t ]*/, desiredIndentString)\n\n  # Public: Removes the first character before the selection if the selection\n  # is empty otherwise it deletes the selection.\n  backspace: ->\n    @selectLeft() if @isEmpty() and not @editor.isFoldedAtScreenRow(@cursor.getScreenRow())\n    @deleteSelectedText()\n\n  # Public: Removes from the start of the selection to the beginning of the\n  # current word if the selection is empty otherwise it deletes the selection.\n  backspaceToBeginningOfWord: ->\n    @selectToBeginningOfWord() if @isEmpty()\n    @deleteSelectedText()\n\n  # Public: Removes from the beginning of the line which the selection begins on\n  # all the way through to the end of the selection.\n  backspaceToBeginningOfLine: ->\n    if @isEmpty() and @cursor.isAtBeginningOfLine()\n      @selectLeft()\n    else\n      @selectToBeginningOfLine()\n    @deleteSelectedText()\n\n  # Public: Removes the selection or the next character after the start of the\n  # selection if the selection is empty.\n  delete: ->\n    if @isEmpty()\n      if @cursor.isAtEndOfLine() and fold = @editor.largestFoldStartingAtScreenRow(@cursor.getScreenRow() + 1)\n        @selectToBufferPosition(fold.getBufferRange().end)\n      else\n        @selectRight()\n    @deleteSelectedText()\n\n  # Public: Removes the selection or all characters from the start of the\n  # selection to the end of the current word if nothing is selected.\n  deleteToEndOfWord: ->\n    @selectToEndOfWord() if @isEmpty()\n    @deleteSelectedText()\n\n  # Public: Removes only the selected text.\n  deleteSelectedText: ->\n    bufferRange = @getBufferRange()\n    if bufferRange.isEmpty() and fold = @editor.largestFoldContainingBufferRow(bufferRange.start.row)\n      bufferRange = bufferRange.union(fold.getBufferRange(includeNewline: true))\n    @editor.buffer.delete(bufferRange) unless bufferRange.isEmpty()\n    @cursor?.setBufferPosition(bufferRange.start)\n\n  # Public: Removes the line at the beginning of the selection if the selection\n  # is empty unless the selection spans multiple lines in which case all lines\n  # are removed.\n  deleteLine: ->\n    if @isEmpty()\n      start = @cursor.getScreenRow()\n      range = @editor.bufferRowsForScreenRows(start, start + 1)\n      if range[1] > range[0]\n        @editor.buffer.deleteRows(range[0], range[1] - 1)\n      else\n        @editor.buffer.deleteRow(range[0])\n    else\n      range = @getBufferRange()\n      start = range.start.row\n      end = range.end.row\n      if end isnt @editor.buffer.getLastRow() and range.end.column is 0\n        end--\n      @editor.buffer.deleteRows(start, end)\n\n  # Public: Joins the current line with the one below it.\n  #\n  # If there selection spans more than one line, all the lines are joined together.\n  joinLines: ->\n    selectedRange = @getBufferRange()\n    if selectedRange.isEmpty()\n      return if selectedRange.start.row is @editor.buffer.getLastRow()\n    else\n      joinMarker = @editor.markBufferRange(selectedRange, invalidationStrategy: 'never')\n\n    rowCount = Math.max(1, selectedRange.getRowCount() - 1)\n    for row in [0...rowCount]\n      @cursor.setBufferPosition([selectedRange.start.row])\n      @cursor.moveToEndOfLine()\n      nextRow = selectedRange.start.row + 1\n      if nextRow <= @editor.buffer.getLastRow() and @editor.buffer.lineLengthForRow(nextRow) > 0\n        @insertText(' ')\n        @cursor.moveToEndOfLine()\n      @modifySelection =>\n        @cursor.moveRight()\n        @cursor.moveToFirstCharacterOfLine()\n      @deleteSelectedText()\n\n    if joinMarker?\n      newSelectedRange = joinMarker.getBufferRange()\n      @setBufferRange(newSelectedRange)\n      joinMarker.destroy()\n\n  # Public: Removes one level of indent from the currently selected rows.\n  outdentSelectedRows: ->\n    [start, end] = @getBufferRowRange()\n    buffer = @editor.buffer\n    leadingTabRegex = new RegExp(\"^ {1,#{@editor.getTabLength()}}|\\t\")\n    for row in [start..end]\n      if matchLength = buffer.lineForRow(row).match(leadingTabRegex)?[0].length\n        buffer.delete [[row, 0], [row, matchLength]]\n\n  # Public: Sets the indentation level of all selected rows to values suggested\n  # by the relevant grammars.\n  autoIndentSelectedRows: ->\n    [start, end] = @getBufferRowRange()\n    @editor.autoIndentBufferRows(start, end)\n\n  # Public: Wraps the selected lines in comments if they aren't currently part\n  # of a comment.\n  #\n  # Removes the comment if they are currently wrapped in a comment.\n  #\n  # Returns an Array of the commented {Range}s.\n  toggleLineComments: ->\n    @editor.toggleLineCommentsForBufferRows(@getBufferRowRange()...)\n\n  # Public: Cuts the selection until the end of the line.\n  cutToEndOfLine: (maintainClipboard) ->\n    @selectToEndOfLine() if @isEmpty()\n    @cut(maintainClipboard)\n\n  # Public: Copies the selection to the clipboard and then deletes it.\n  cut: (maintainClipboard=false) ->\n    @copy(maintainClipboard)\n    @delete()\n\n  # Public: Copies the current selection to the clipboard.\n  copy: (maintainClipboard=false) ->\n    return if @isEmpty()\n    text = @editor.buffer.getTextInRange(@getBufferRange())\n    if maintainClipboard\n      text = \"#{atom.clipboard.read()}\\n#{text}\"\n    else\n      metadata = { indentBasis: @editor.indentationForBufferRow(@getBufferRange().start.row) }\n\n    atom.clipboard.write(text, metadata)\n\n  # Public: Creates a fold containing the current selection.\n  fold: ->\n    range = @getBufferRange()\n    @editor.createFold(range.start.row, range.end.row)\n    @cursor.setBufferPosition([range.end.row + 1, 0])\n\n  modifySelection: (fn) ->\n    @retainSelection = true\n    @plantTail()\n    fn()\n    @retainSelection = false\n\n  # Sets the marker's tail to the same position as the marker's head.\n  #\n  # This only works if there isn't already a tail position.\n  #\n  # Returns a {Point} representing the new tail position.\n  plantTail: ->\n    @marker.plantTail()\n\n  # Public: Identifies if a selection intersects with a given buffer range.\n  #\n  # bufferRange - A {Range} to check against.\n  #\n  # Returns a Boolean.\n  intersectsBufferRange: (bufferRange) ->\n    @getBufferRange().intersectsWith(bufferRange)\n\n  # Public: Identifies if a selection intersects with another selection.\n  #\n  # otherSelection - A {Selection} to check against.\n  #\n  # Returns a Boolean.\n  intersectsWith: (otherSelection) ->\n    @getBufferRange().intersectsWith(otherSelection.getBufferRange())\n\n  # Public: Combines the given selection into this selection and then destroys\n  # the given selection.\n  #\n  # otherSelection - A {Selection} to merge with.\n  # options - A hash of options matching those found in {::setBufferRange}.\n  merge: (otherSelection, options) ->\n    myGoalBufferRange = @getGoalBufferRange()\n    otherGoalBufferRange = otherSelection.getGoalBufferRange()\n    if myGoalBufferRange? and otherGoalBufferRange?\n      options.goalBufferRange = myGoalBufferRange.union(otherGoalBufferRange)\n    else\n      options.goalBufferRange = myGoalBufferRange ? otherGoalBufferRange\n    @setBufferRange(@getBufferRange().union(otherSelection.getBufferRange()), options)\n    otherSelection.destroy()\n\n  # Public: Compare this selection's buffer range to another selection's buffer\n  # range.\n  #\n  # See {Range::compare} for more details.\n  #\n  # otherSelection - A {Selection} to compare against.\n  compare: (otherSelection) ->\n    @getBufferRange().compare(otherSelection.getBufferRange())\n\n  # Get the pixel dimensions of rectangular regions that cover selection's area\n  # on the screen. Used by SelectionComponent for rendering.\n  getRegionRects: ->\n    lineHeight = @editor.getLineHeight()\n    {start, end} = @getScreenRange()\n    rowCount = end.row - start.row + 1\n    startPixelPosition = @editor.pixelPositionForScreenPosition(start)\n    endPixelPosition = @editor.pixelPositionForScreenPosition(end)\n\n    if rowCount is 1\n      # Single line selection\n      rects = [{\n        top: startPixelPosition.top\n        height: lineHeight\n        left: startPixelPosition.left\n        width: endPixelPosition.left - startPixelPosition.left\n      }]\n    else\n      # Multi-line selection\n      rects = []\n\n      # First row, extending from selection start to the right side of screen\n      rects.push {\n        top: startPixelPosition.top\n        left: startPixelPosition.left\n        height: lineHeight\n        right: 0\n      }\n      if rowCount > 2\n        # Middle rows, extending from left side to right side of screen\n        rects.push {\n          top: startPixelPosition.top + lineHeight\n          height: (rowCount - 2) * lineHeight\n          left: 0\n          right: 0\n        }\n      # Last row, extending from left side of screen to selection end\n      rects.push {top: endPixelPosition.top, height: lineHeight, left: 0, width: endPixelPosition.left }\n\n    rects\n\n  screenRangeChanged: ->\n    screenRange = @getScreenRange()\n    @emit 'screen-range-changed', screenRange\n    @editor.selectionScreenRangeChanged(this)\n","markers":{"markers":{"1":{"id":1,"range":[[483,32],[483,32]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":57,"autoscroll":true,"goalBufferRange":null,"preserveFolds":true},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/zk/napplelabs/atom/src/selection.coffee","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"ea8648c769dfcee275ecaa1c45d731e261fc9057","deserializer":"TextBuffer"},{"text":"{Range} = require 'text-buffer'\n_ = require 'underscore-plus'\n{OnigRegExp} = require 'oniguruma'\n{Emitter, Subscriber} = require 'emissary'\n\nmodule.exports =\nclass LanguageMode\n  Emitter.includeInto(this)\n  Subscriber.includeInto(this)\n\n  # Sets up a `LanguageMode` for the given {Editor}.\n  #\n  # editor - The {Editor} to associate with\n  constructor: (@editor) ->\n    {@buffer} = @editor\n\n  destroy: ->\n    @unsubscribe()\n\n  toggleLineCommentForBufferRow: (row) ->\n    @toggleLineCommentsForBufferRows(row, row)\n\n  # Wraps the lines between two rows in comments.\n  #\n  # If the language doesn't have comment, nothing happens.\n  #\n  # startRow - The row {Number} to start at\n  # endRow - The row {Number} to end at\n  #\n  # Returns an {Array} of the commented {Ranges}.\n  toggleLineCommentsForBufferRows: (start, end) ->\n    scopes = @editor.scopesForBufferPosition([start, 0])\n    properties = atom.syntax.propertiesForScope(scopes, \"editor.commentStart\")[0]\n    return unless properties\n\n    commentStartString = _.valueForKeyPath(properties, \"editor.commentStart\")\n    commentEndString = _.valueForKeyPath(properties, \"editor.commentEnd\")\n\n    return unless commentStartString\n\n    buffer = @editor.buffer\n    commentStartRegexString = _.escapeRegExp(commentStartString).replace(/(\\s+)$/, '(?:$1)?')\n    commentStartRegex = new OnigRegExp(\"^(\\\\s*)(#{commentStartRegexString})\")\n    shouldUncomment = commentStartRegex.test(buffer.lineForRow(start))\n\n    if commentEndString\n      if shouldUncomment\n        commentEndRegexString = _.escapeRegExp(commentEndString).replace(/^(\\s+)/, '(?:$1)?')\n        commentEndRegex = new OnigRegExp(\"(#{commentEndRegexString})(\\\\s*)$\")\n        startMatch =  commentStartRegex.search(buffer.lineForRow(start))\n        endMatch = commentEndRegex.search(buffer.lineForRow(end))\n        if startMatch and endMatch\n          buffer.transact ->\n            columnStart = startMatch[1].length\n            columnEnd = columnStart + startMatch[2].length\n            buffer.setTextInRange([[start, columnStart], [start, columnEnd]], \"\")\n\n            endLength = buffer.lineLengthForRow(end) - endMatch[2].length\n            endColumn = endLength - endMatch[1].length\n            buffer.setTextInRange([[end, endColumn], [end, endLength]], \"\")\n      else\n        buffer.transact ->\n          indentLength = buffer.lineForRow(start).match(/^\\s*/)?[0].length ? 0\n          buffer.insert([start, indentLength], commentStartString)\n          buffer.insert([end, buffer.lineLengthForRow(end)], commentEndString)\n    else\n      if shouldUncomment and start isnt end\n        shouldUncomment = [start+1..end].every (row) ->\n          line = buffer.lineForRow(row)\n          not line or commentStartRegex.test(line)\n      if shouldUncomment\n        for row in [start..end]\n          if match = commentStartRegex.search(buffer.lineForRow(row))\n            columnStart = match[1].length\n            columnEnd = columnStart + match[2].length\n            buffer.setTextInRange([[row, columnStart], [row, columnEnd]], \"\")\n      else\n        if start is end\n          indent = @editor.indentationForBufferRow(start)\n        else\n          indent = @minIndentLevelForRowRange(start, end)\n        indentString = @editor.buildIndentString(indent)\n        tabLength = @editor.getTabLength()\n        indentRegex = new RegExp(\"(\\t|[ ]{#{tabLength}}){#{Math.floor(indent)}}\")\n        for row in [start..end]\n          line = buffer.lineForRow(row)\n          if indentLength = line.match(indentRegex)?[0].length\n            buffer.insert([row, indentLength], commentStartString)\n          else\n            buffer.setTextInRange([[row, 0], [row, indentString.length]], indentString + commentStartString)\n\n  # Folds all the foldable lines in the buffer.\n  foldAll: ->\n    for currentRow in [0..@buffer.getLastRow()]\n      [startRow, endRow] = @rowRangeForFoldAtBufferRow(currentRow) ? []\n      continue unless startRow?\n      @editor.createFold(startRow, endRow)\n\n  # Unfolds all the foldable lines in the buffer.\n  unfoldAll: ->\n    for row in [@buffer.getLastRow()..0]\n      fold.destroy() for fold in @editor.displayBuffer.foldsStartingAtBufferRow(row)\n\n  # Fold all comment and code blocks at a given indentLevel\n  #\n  # indentLevel - A {Number} indicating indentLevel; 0 based.\n  foldAllAtIndentLevel: (indentLevel) ->\n    for currentRow in [0..@buffer.getLastRow()]\n      [startRow, endRow] = @rowRangeForFoldAtBufferRow(currentRow) ? []\n      continue unless startRow?\n\n      # assumption: startRow will always be the min indent level for the entire range\n      if @editor.indentationForBufferRow(startRow) == indentLevel\n        @editor.createFold(startRow, endRow)\n\n  # Given a buffer row, creates a fold at it.\n  #\n  # bufferRow - A {Number} indicating the buffer row\n  #\n  # Returns the new {Fold}.\n  foldBufferRow: (bufferRow) ->\n    for currentRow in [bufferRow..0]\n      [startRow, endRow] = @rowRangeForFoldAtBufferRow(currentRow) ? []\n      continue unless startRow? and startRow <= bufferRow <= endRow\n      fold = @editor.displayBuffer.largestFoldStartingAtBufferRow(startRow)\n      return @editor.createFold(startRow, endRow) unless fold\n\n  # Find the row range for a fold at a given bufferRow. Will handle comments\n  # and code.\n  #\n  # bufferRow - A {Number} indicating the buffer row\n  #\n  # Returns an {Array} of the [startRow, endRow]. Returns null if no range.\n  rowRangeForFoldAtBufferRow: (bufferRow) ->\n    rowRange = @rowRangeForCommentAtBufferRow(bufferRow)\n    rowRange ?= @rowRangeForCodeFoldAtBufferRow(bufferRow)\n    rowRange\n\n  rowRangeForCommentAtBufferRow: (bufferRow) ->\n    return unless @editor.displayBuffer.tokenizedBuffer.lineForScreenRow(bufferRow).isComment()\n\n    startRow = bufferRow\n    for currentRow in [bufferRow-1..0]\n      break if @buffer.isRowBlank(currentRow)\n      break unless @editor.displayBuffer.tokenizedBuffer.lineForScreenRow(currentRow).isComment()\n      startRow = currentRow\n    endRow = bufferRow\n    for currentRow in [bufferRow+1..@buffer.getLastRow()]\n      break if @buffer.isRowBlank(currentRow)\n      break unless @editor.displayBuffer.tokenizedBuffer.lineForScreenRow(currentRow).isComment()\n      endRow = currentRow\n    return [startRow, endRow] if startRow isnt endRow\n\n  rowRangeForCodeFoldAtBufferRow: (bufferRow) ->\n    return null unless @isFoldableAtBufferRow(bufferRow)\n\n    startIndentLevel = @editor.indentationForBufferRow(bufferRow)\n    scopes = @editor.scopesForBufferPosition([bufferRow, 0])\n    for row in [(bufferRow + 1)..@editor.getLastBufferRow()]\n      continue if @editor.isBufferRowBlank(row)\n      indentation = @editor.indentationForBufferRow(row)\n      if indentation <= startIndentLevel\n        includeRowInFold = indentation == startIndentLevel and @foldEndRegexForScopes(scopes)?.search(@editor.lineForBufferRow(row))\n        foldEndRow = row if includeRowInFold\n        break\n\n      foldEndRow = row\n\n    [bufferRow, foldEndRow]\n\n  # Public: Returns a {Boolean} indicating whether the given buffer row starts a\n  # foldable row range. Rows that are \"foldable\" have a fold icon next to their\n  # icon in the gutter in the default configuration.\n  isFoldableAtBufferRow: (bufferRow) ->\n    @isFoldableCodeAtBufferRow(bufferRow) or @isFoldableCommentAtBufferRow(bufferRow)\n\n  # Returns a {Boolean} indicating whether the given buffer row starts\n  # a a foldable row range due to the code's indentation patterns.\n  isFoldableCodeAtBufferRow: (bufferRow) ->\n    return false if @editor.isBufferRowBlank(bufferRow) or @isLineCommentedAtBufferRow(bufferRow)\n    nextNonEmptyRow = @editor.nextNonBlankBufferRow(bufferRow)\n    return false unless nextNonEmptyRow?\n    @editor.indentationForBufferRow(nextNonEmptyRow) > @editor.indentationForBufferRow(bufferRow)\n\n  # Returns a {Boolean} indicating whether the given buffer row starts\n  # a foldable row range due to being the start of a multi-line comment.\n  isFoldableCommentAtBufferRow: (bufferRow) ->\n    @isLineCommentedAtBufferRow(bufferRow) and\n      @isLineCommentedAtBufferRow(bufferRow + 1) and\n        not @isLineCommentedAtBufferRow(bufferRow - 1)\n\n  # Returns a {Boolean} indicating whether the line at the given buffer\n  # row is a comment.\n  isLineCommentedAtBufferRow: (bufferRow) ->\n    return false unless 0 <= bufferRow <= @editor.getLastBufferRow()\n    @editor.displayBuffer.tokenizedBuffer.lineForScreenRow(bufferRow).isComment()\n\n  # Find a row range for a 'paragraph' around specified bufferRow.\n  # Right now, a paragraph is a block of text bounded by and empty line or a\n  # block of text that is not the same type (comments next to source code).\n  rowRangeForParagraphAtBufferRow: (bufferRow) ->\n    return unless /\\w/.test(@editor.lineForBufferRow(bufferRow))\n\n    if @isLineCommentedAtBufferRow(bufferRow)\n      isOriginalRowComment = true\n      range = @rowRangeForCommentAtBufferRow(bufferRow)\n      [firstRow, lastRow] = range or [bufferRow, bufferRow]\n    else\n      isOriginalRowComment = false\n      [firstRow, lastRow] = [0, @editor.getLastBufferRow()-1]\n\n    startRow = bufferRow\n    while startRow > firstRow\n      break if @isLineCommentedAtBufferRow(startRow - 1) != isOriginalRowComment\n      break unless /\\w/.test(@editor.lineForBufferRow(startRow - 1))\n      startRow--\n\n    endRow = bufferRow\n    lastRow = @editor.getLastBufferRow()\n    while endRow < lastRow\n      break if @isLineCommentedAtBufferRow(endRow + 1) != isOriginalRowComment\n      break unless /\\w/.test(@editor.lineForBufferRow(endRow + 1))\n      endRow++\n\n    new Range([startRow, 0], [endRow, @editor.lineLengthForBufferRow(endRow)])\n\n  # Given a buffer row, this returns a suggested indentation level.\n  #\n  # The indentation level provided is based on the current {LanguageMode}.\n  #\n  # bufferRow - A {Number} indicating the buffer row\n  #\n  # Returns a {Number}.\n  suggestedIndentForBufferRow: (bufferRow) ->\n    currentIndentLevel = @editor.indentationForBufferRow(bufferRow)\n    scopes = @editor.scopesForBufferPosition([bufferRow, 0])\n    return currentIndentLevel unless increaseIndentRegex = @increaseIndentRegexForScopes(scopes)\n\n    currentLine = @buffer.lineForRow(bufferRow)\n    precedingRow = if bufferRow > 0 then bufferRow - 1 else null\n    return currentIndentLevel unless precedingRow?\n\n    precedingLine = @buffer.lineForRow(precedingRow)\n    desiredIndentLevel = @editor.indentationForBufferRow(precedingRow)\n    desiredIndentLevel += 1 if increaseIndentRegex.test(precedingLine) and not @editor.isBufferRowCommented(precedingRow)\n\n    return desiredIndentLevel unless decreaseIndentRegex = @decreaseIndentRegexForScopes(scopes)\n    desiredIndentLevel -= 1 if decreaseIndentRegex.test(currentLine)\n\n    Math.max(desiredIndentLevel, 0)\n\n  # Calculate a minimum indent level for a range of lines excluding empty lines.\n  #\n  # startRow - The row {Number} to start at\n  # endRow - The row {Number} to end at\n  #\n  # Returns a {Number} of the indent level of the block of lines.\n  minIndentLevelForRowRange: (startRow, endRow) ->\n    indents = (@editor.indentationForBufferRow(row) for row in [startRow..endRow] when not @editor.isBufferRowBlank(row))\n    indents = [0] unless indents.length\n    Math.min(indents...)\n\n  # Indents all the rows between two buffer row numbers.\n  #\n  # startRow - The row {Number} to start at\n  # endRow - The row {Number} to end at\n  autoIndentBufferRows: (startRow, endRow) ->\n    @autoIndentBufferRow(row) for row in [startRow..endRow]\n\n  # Given a buffer row, this indents it.\n  #\n  # bufferRow - The row {Number}.\n  # options - An options {Object} to pass through to {Editor::setIndentationForBufferRow}.\n  autoIndentBufferRow: (bufferRow, options) ->\n    indentLevel = @suggestedIndentForBufferRow(bufferRow)\n    @editor.setIndentationForBufferRow(bufferRow, indentLevel, options)\n\n  # Given a buffer row, this decreases the indentation.\n  #\n  # bufferRow - The row {Number}\n  autoDecreaseIndentForBufferRow: (bufferRow) ->\n    scopes = @editor.scopesForBufferPosition([bufferRow, 0])\n    increaseIndentRegex = @increaseIndentRegexForScopes(scopes)\n    decreaseIndentRegex = @decreaseIndentRegexForScopes(scopes)\n    return unless increaseIndentRegex and decreaseIndentRegex\n\n    line = @buffer.lineForRow(bufferRow)\n    return unless decreaseIndentRegex.test(line)\n\n    currentIndentLevel = @editor.indentationForBufferRow(bufferRow)\n    return if currentIndentLevel is 0\n    precedingRow = @buffer.previousNonBlankRow(bufferRow)\n    return unless precedingRow?\n    precedingLine = @buffer.lineForRow(precedingRow)\n\n    desiredIndentLevel = @editor.indentationForBufferRow(precedingRow)\n    desiredIndentLevel -= 1 unless increaseIndentRegex.test(precedingLine)\n    if desiredIndentLevel >= 0 and desiredIndentLevel < currentIndentLevel\n      @editor.setIndentationForBufferRow(bufferRow, desiredIndentLevel)\n\n  getRegexForProperty: (scopes, property) ->\n    if pattern = atom.syntax.getProperty(scopes, property)\n      new OnigRegExp(pattern)\n\n  increaseIndentRegexForScopes: (scopes) ->\n    @getRegexForProperty(scopes, 'editor.increaseIndentPattern')\n\n  decreaseIndentRegexForScopes: (scopes) ->\n    @getRegexForProperty(scopes, 'editor.decreaseIndentPattern')\n\n  foldEndRegexForScopes: (scopes) ->\n    @getRegexForProperty(scopes, 'editor.foldEndPattern')\n","markers":{"markers":{"1":{"id":1,"range":[[236,88],[236,88]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":61,"autoscroll":true,"goalBufferRange":null,"preserveFolds":true},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/zk/napplelabs/atom/src/language-mode.coffee","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"042d6211253f8b2214f90e66f34a8fa3fd864506","deserializer":"TextBuffer"},{"text":"_ = require 'underscore-plus'\n{Emitter} = require 'emissary'\nguid = require 'guid'\nSerializable = require 'serializable'\n{Model} = require 'theorist'\n{Point, Range} = require 'text-buffer'\nTokenizedBuffer = require './tokenized-buffer'\nRowMap = require './row-map'\nFold = require './fold'\nToken = require './token'\nDisplayBufferMarker = require './display-buffer-marker'\n\nclass BufferToScreenConversionError extends Error\n  constructor: (@message, @metadata) ->\n    super\n    Error.captureStackTrace(this, BufferToScreenConversionError)\n\nmodule.exports =\nclass DisplayBuffer extends Model\n  Serializable.includeInto(this)\n\n  @properties\n    manageScrollPosition: false\n    softWrap: null\n    editorWidthInChars: null\n    lineHeight: null\n    defaultCharWidth: null\n    height: null\n    width: null\n    scrollTop: 0\n    scrollLeft: 0\n\n  verticalScrollMargin: 2\n  horizontalScrollMargin: 6\n\n  constructor: ({tabLength, @editorWidthInChars, @tokenizedBuffer, buffer}={}) ->\n    super\n    @softWrap ?= atom.config.get('editor.softWrap') ? false\n    @tokenizedBuffer ?= new TokenizedBuffer({tabLength, buffer})\n    @buffer = @tokenizedBuffer.buffer\n    @charWidthsByScope = {}\n    @markers = {}\n    @foldsByMarkerId = {}\n    @updateAllScreenLines()\n    @createFoldForMarker(marker) for marker in @buffer.findMarkers(@getFoldMarkerAttributes())\n    @subscribe @tokenizedBuffer, 'grammar-changed', (grammar) => @emit 'grammar-changed', grammar\n    @subscribe @tokenizedBuffer, 'changed', @handleTokenizedBufferChange\n    @subscribe @buffer, 'markers-updated', @handleBufferMarkersUpdated\n    @subscribe @buffer, 'marker-created', @handleBufferMarkerCreated\n\n    @subscribe @$softWrap, (softWrap) =>\n      @emit 'soft-wrap-changed', softWrap\n      @updateWrappedScreenLines()\n\n    @subscribe atom.config.observe 'editor.preferredLineLength', callNow: false, =>\n      @updateWrappedScreenLines() if @softWrap and atom.config.get('editor.softWrapAtPreferredLineLength')\n\n    @subscribe atom.config.observe 'editor.softWrapAtPreferredLineLength', callNow: false, =>\n      @updateWrappedScreenLines() if @softWrap\n\n  serializeParams: ->\n    id: @id\n    softWrap: @softWrap\n    editorWidthInChars: @editorWidthInChars\n    scrollTop: @scrollTop\n    scrollLeft: @scrollLeft\n    tokenizedBuffer: @tokenizedBuffer.serialize()\n\n  deserializeParams: (params) ->\n    params.tokenizedBuffer = TokenizedBuffer.deserialize(params.tokenizedBuffer)\n    params\n\n  copy: ->\n    newDisplayBuffer = new DisplayBuffer({@buffer, tabLength: @getTabLength()})\n    newDisplayBuffer.setScrollTop(@getScrollTop())\n    newDisplayBuffer.setScrollLeft(@getScrollLeft())\n\n    for marker in @findMarkers(displayBufferId: @id)\n      marker.copy(displayBufferId: newDisplayBuffer.id)\n    newDisplayBuffer\n\n  updateAllScreenLines: ->\n    @maxLineLength = 0\n    @screenLines = []\n    @rowMap = new RowMap\n    @updateScreenLines(0, @buffer.getLineCount(), null, suppressChangeEvent: true)\n\n  emitChanged: (eventProperties, refreshMarkers=true) ->\n    if refreshMarkers\n      @pauseMarkerObservers()\n      @refreshMarkerScreenPositions()\n    @emit 'changed', eventProperties\n    @resumeMarkerObservers()\n\n  updateWrappedScreenLines: ->\n    start = 0\n    end = @getLastRow()\n    @updateAllScreenLines()\n    screenDelta = @getLastRow() - end\n    bufferDelta = 0\n    @emitChanged({ start, end, screenDelta, bufferDelta })\n\n  # Sets the visibility of the tokenized buffer.\n  #\n  # visible - A {Boolean} indicating of the tokenized buffer is shown\n  setVisible: (visible) -> @tokenizedBuffer.setVisible(visible)\n\n  getVerticalScrollMargin: -> @verticalScrollMargin\n  setVerticalScrollMargin: (@verticalScrollMargin) -> @verticalScrollMargin\n\n  getHorizontalScrollMargin: -> @horizontalScrollMargin\n  setHorizontalScrollMargin: (@horizontalScrollMargin) -> @horizontalScrollMargin\n\n  getHeight: -> @height ? @getScrollHeight()\n  setHeight: (@height) -> @height\n\n  getWidth: -> @width ? @getScrollWidth()\n  setWidth: (newWidth) ->\n    oldWidth = @width\n    @width = newWidth\n    @updateWrappedScreenLines() if newWidth isnt oldWidth and @softWrap\n    @width\n\n  getScrollTop: -> @scrollTop\n  setScrollTop: (scrollTop) ->\n    if @manageScrollPosition\n      @scrollTop = Math.max(0, Math.min(@getScrollHeight() - @getHeight(), scrollTop))\n    else\n      @scrollTop = scrollTop\n\n  getScrollBottom: -> @scrollTop + @height\n  setScrollBottom: (scrollBottom) ->\n    @setScrollTop(scrollBottom - @height)\n    @getScrollBottom()\n\n  getScrollLeft: -> @scrollLeft\n  setScrollLeft: (scrollLeft) ->\n    if @manageScrollPosition\n      @scrollLeft = Math.max(0, Math.min(@getScrollWidth() - @getWidth(), scrollLeft))\n    else\n      @scrollLeft = scrollLeft\n\n  getScrollRight: -> @scrollLeft + @width\n  setScrollRight: (scrollRight) ->\n    @setScrollLeft(scrollRight - @width)\n    @getScrollRight()\n\n  getLineHeight: -> @lineHeight\n  setLineHeight: (@lineHeight) -> @lineHeight\n\n  getDefaultCharWidth: -> @defaultCharWidth\n  setDefaultCharWidth: (@defaultCharWidth) -> @defaultCharWidth\n\n  getScopedCharWidth: (scopeNames, char) ->\n    @getScopedCharWidths(scopeNames)[char]\n\n  getScopedCharWidths: (scopeNames) ->\n    scope = @charWidthsByScope\n    for scopeName in scopeNames\n      scope[scopeName] ?= {}\n      scope = scope[scopeName]\n    scope.charWidths ?= {}\n    scope.charWidths\n\n  setScopedCharWidth: (scopeNames, char, width) ->\n    @getScopedCharWidths(scopeNames)[char] = width\n\n  setScopedCharWidths: (scopeNames, charWidths) ->\n    _.extend(@getScopedCharWidths(scopeNames), charWidths)\n\n  clearScopedCharWidths: ->\n    @charWidthsByScope = {}\n\n  getScrollHeight: ->\n    unless @getLineHeight() > 0\n      throw new Error(\"You must assign lineHeight before calling ::getScrollHeight()\")\n\n    @getLineCount() * @getLineHeight()\n\n  getScrollWidth: ->\n    @getMaxLineLength() * @getDefaultCharWidth()\n\n  getVisibleRowRange: ->\n    unless @getLineHeight() > 0\n      throw new Error(\"You must assign a non-zero lineHeight before calling ::getVisibleRowRange()\")\n\n    heightInLines = Math.ceil(@getHeight() / @getLineHeight()) + 1\n    startRow = Math.floor(@getScrollTop() / @getLineHeight())\n    endRow = Math.min(@getLineCount(), Math.ceil(startRow + heightInLines))\n    [startRow, endRow]\n\n  intersectsVisibleRowRange: (startRow, endRow) ->\n    [visibleStart, visibleEnd] = @getVisibleRowRange()\n    not (endRow <= visibleStart or visibleEnd <= startRow)\n\n  selectionIntersectsVisibleRowRange: (selection) ->\n    {start, end} = selection.getScreenRange()\n    @intersectsVisibleRowRange(start.row, end.row + 1)\n\n  scrollToScreenRange: (screenRange) ->\n    verticalScrollMarginInPixels = @getVerticalScrollMargin() * @getLineHeight()\n    horizontalScrollMarginInPixels = @getHorizontalScrollMargin() * @getDefaultCharWidth()\n\n    {top, left, height, width} = @pixelRectForScreenRange(screenRange)\n    bottom = top + height\n    right = left + width\n    desiredScrollTop = top - verticalScrollMarginInPixels\n    desiredScrollBottom = bottom + verticalScrollMarginInPixels\n    desiredScrollLeft = left - horizontalScrollMarginInPixels\n    desiredScrollRight = right + horizontalScrollMarginInPixels\n\n    if desiredScrollTop < @getScrollTop()\n      @setScrollTop(desiredScrollTop)\n    else if desiredScrollBottom > @getScrollBottom()\n      @setScrollBottom(desiredScrollBottom)\n\n    if desiredScrollLeft < @getScrollLeft()\n      @setScrollLeft(desiredScrollLeft)\n    else if desiredScrollRight > @getScrollRight()\n      @setScrollRight(desiredScrollRight)\n\n  scrollToScreenPosition: (screenPosition) ->\n    @scrollToScreenRange(new Range(screenPosition, screenPosition))\n\n  scrollToBufferPosition: (bufferPosition) ->\n    @scrollToScreenPosition(@screenPositionForBufferPosition(bufferPosition))\n\n  pixelRectForScreenRange: (screenRange) ->\n    if screenRange.end.row > screenRange.start.row\n      top = @pixelPositionForScreenPosition(screenRange.start).top\n      left = 0\n      height = (screenRange.end.row - screenRange.start.row + 1) * @getLineHeight()\n      width = @getScrollWidth()\n    else\n      {top, left} = @pixelPositionForScreenPosition(screenRange.start)\n      height = @getLineHeight()\n      width = @pixelPositionForScreenPosition(screenRange.end).left - left\n\n    {top, left, width, height}\n\n  # Retrieves the current tab length.\n  #\n  # Returns a {Number}.\n  getTabLength: ->\n    @tokenizedBuffer.getTabLength()\n\n  # Specifies the tab length.\n  #\n  # tabLength - A {Number} that defines the new tab length.\n  setTabLength: (tabLength) ->\n    @tokenizedBuffer.setTabLength(tabLength)\n\n  # Deprecated: Use the softWrap property directly\n  setSoftWrap: (@softWrap) -> @softWrap\n\n  # Deprecated: Use the softWrap property directly\n  getSoftWrap: -> @softWrap\n\n  # Set the number of characters that fit horizontally in the editor.\n  #\n  # editorWidthInChars - A {Number} of characters.\n  setEditorWidthInChars: (editorWidthInChars) ->\n    if editorWidthInChars > 0\n      previousWidthInChars = @editorWidthInChars\n      @editorWidthInChars = editorWidthInChars\n      if editorWidthInChars isnt previousWidthInChars and @softWrap\n        @updateWrappedScreenLines()\n\n  getEditorWidthInChars: ->\n    width = @getWidth()\n    if width? and @defaultCharWidth > 0\n      Math.floor(width / @defaultCharWidth)\n    else\n      @editorWidthInChars\n\n  getSoftWrapColumn: ->\n    if atom.config.get('editor.softWrapAtPreferredLineLength')\n      Math.min(@getEditorWidthInChars(), atom.config.getPositiveInt('editor.preferredLineLength', @getEditorWidthInChars()))\n    else\n      @getEditorWidthInChars()\n\n  # Gets the screen line for the given screen row.\n  #\n  # screenRow - A {Number} indicating the screen row.\n  #\n  # Returns a {ScreenLine}.\n  lineForRow: (row) ->\n    @screenLines[row]\n\n  # Gets the screen lines for the given screen row range.\n  #\n  # startRow - A {Number} indicating the beginning screen row.\n  # endRow - A {Number} indicating the ending screen row.\n  #\n  # Returns an {Array} of {ScreenLine}s.\n  linesForRows: (startRow, endRow) ->\n    @screenLines[startRow..endRow]\n\n  # Gets all the screen lines.\n  #\n  # Returns an {Array} of {ScreenLines}s.\n  getLines: ->\n    new Array(@screenLines...)\n\n  indentLevelForLine: (line) ->\n    @tokenizedBuffer.indentLevelForLine(line)\n\n  # Given starting and ending screen rows, this returns an array of the\n  # buffer rows corresponding to every screen row in the range\n  #\n  # startScreenRow - The screen row {Number} to start at\n  # endScreenRow - The screen row {Number} to end at (default: the last screen row)\n  #\n  # Returns an {Array} of buffer rows as {Numbers}s.\n  bufferRowsForScreenRows: (startScreenRow, endScreenRow) ->\n    for screenRow in [startScreenRow..endScreenRow]\n      @rowMap.bufferRowRangeForScreenRow(screenRow)[0]\n\n  # Creates a new fold between two row numbers.\n  #\n  # startRow - The row {Number} to start folding at\n  # endRow - The row {Number} to end the fold\n  #\n  # Returns the new {Fold}.\n  createFold: (startRow, endRow) ->\n    foldMarker =\n      @findFoldMarker({startRow, endRow}) ?\n        @buffer.markRange([[startRow, 0], [endRow, Infinity]], @getFoldMarkerAttributes())\n    @foldForMarker(foldMarker)\n\n  isFoldedAtBufferRow: (bufferRow) ->\n    @largestFoldContainingBufferRow(bufferRow)?\n\n  isFoldedAtScreenRow: (screenRow) ->\n    @largestFoldContainingBufferRow(@bufferRowForScreenRow(screenRow))?\n\n  # Destroys the fold with the given id\n  destroyFoldWithId: (id) ->\n    @foldsByMarkerId[id]?.destroy()\n\n  # Removes any folds found that contain the given buffer row.\n  #\n  # bufferRow - The buffer row {Number} to check against\n  unfoldBufferRow: (bufferRow) ->\n    fold.destroy() for fold in @foldsContainingBufferRow(bufferRow)\n\n  # Given a buffer row, this returns the largest fold that starts there.\n  #\n  # Largest is defined as the fold whose difference between its start and end points\n  # are the greatest.\n  #\n  # bufferRow - A {Number} indicating the buffer row\n  #\n  # Returns a {Fold} or null if none exists.\n  largestFoldStartingAtBufferRow: (bufferRow) ->\n    @foldsStartingAtBufferRow(bufferRow)[0]\n\n  # Public: Given a buffer row, this returns all folds that start there.\n  #\n  # bufferRow - A {Number} indicating the buffer row\n  #\n  # Returns an {Array} of {Fold}s.\n  foldsStartingAtBufferRow: (bufferRow) ->\n    for marker in @findFoldMarkers(startRow: bufferRow)\n      @foldForMarker(marker)\n\n  # Given a screen row, this returns the largest fold that starts there.\n  #\n  # Largest is defined as the fold whose difference between its start and end points\n  # are the greatest.\n  #\n  # screenRow - A {Number} indicating the screen row\n  #\n  # Returns a {Fold}.\n  largestFoldStartingAtScreenRow: (screenRow) ->\n    @largestFoldStartingAtBufferRow(@bufferRowForScreenRow(screenRow))\n\n  # Given a buffer row, this returns the largest fold that includes it.\n  #\n  # Largest is defined as the fold whose difference between its start and end rows\n  # is the greatest.\n  #\n  # bufferRow - A {Number} indicating the buffer row\n  #\n  # Returns a {Fold}.\n  largestFoldContainingBufferRow: (bufferRow) ->\n    @foldsContainingBufferRow(bufferRow)[0]\n\n  # Returns the folds in the given row range (exclusive of end row) that are\n  # not contained by any other folds.\n  outermostFoldsInBufferRowRange: (startRow, endRow) ->\n    @findFoldMarkers(containedInRange: [[startRow, 0], [endRow, 0]])\n      .map (marker) => @foldForMarker(marker)\n      .filter (fold) -> not fold.isInsideLargerFold()\n\n  # Public: Given a buffer row, this returns folds that include it.\n  #\n  #\n  # bufferRow - A {Number} indicating the buffer row\n  #\n  # Returns an {Array} of {Fold}s.\n  foldsContainingBufferRow: (bufferRow) ->\n    for marker in @findFoldMarkers(intersectsRow: bufferRow)\n      @foldForMarker(marker)\n\n  # Given a buffer row, this converts it into a screen row.\n  #\n  # bufferRow - A {Number} representing a buffer row\n  #\n  # Returns a {Number}.\n  screenRowForBufferRow: (bufferRow) ->\n    @rowMap.screenRowRangeForBufferRow(bufferRow)[0]\n\n  lastScreenRowForBufferRow: (bufferRow) ->\n    @rowMap.screenRowRangeForBufferRow(bufferRow)[1] - 1\n\n  # Given a screen row, this converts it into a buffer row.\n  #\n  # screenRow - A {Number} representing a screen row\n  #\n  # Returns a {Number}.\n  bufferRowForScreenRow: (screenRow) ->\n    @rowMap.bufferRowRangeForScreenRow(screenRow)[0]\n\n  # Given a buffer range, this converts it into a screen position.\n  #\n  # bufferRange - The {Range} to convert\n  #\n  # Returns a {Range}.\n  screenRangeForBufferRange: (bufferRange) ->\n    bufferRange = Range.fromObject(bufferRange)\n    start = @screenPositionForBufferPosition(bufferRange.start)\n    end = @screenPositionForBufferPosition(bufferRange.end)\n    new Range(start, end)\n\n  # Given a screen range, this converts it into a buffer position.\n  #\n  # screenRange - The {Range} to convert\n  #\n  # Returns a {Range}.\n  bufferRangeForScreenRange: (screenRange) ->\n    screenRange = Range.fromObject(screenRange)\n    start = @bufferPositionForScreenPosition(screenRange.start)\n    end = @bufferPositionForScreenPosition(screenRange.end)\n    new Range(start, end)\n\n  pixelRangeForScreenRange: (screenRange, clip=true) ->\n    {start, end} = Range.fromObject(screenRange)\n    {start: @pixelPositionForScreenPosition(start, clip), end: @pixelPositionForScreenPosition(end, clip)}\n\n  pixelPositionForScreenPosition: (screenPosition, clip=true) ->\n    screenPosition = Point.fromObject(screenPosition)\n    screenPosition = @clipScreenPosition(screenPosition) if clip\n\n    targetRow = screenPosition.row\n    targetColumn = screenPosition.column\n    defaultCharWidth = @defaultCharWidth\n\n    top = targetRow * @lineHeight\n    left = 0\n    column = 0\n    for token in @lineForRow(targetRow).tokens\n      charWidths = @getScopedCharWidths(token.scopes)\n      for char in token.value\n        return {top, left} if column is targetColumn\n        left += charWidths[char] ? defaultCharWidth\n        column++\n    {top, left}\n\n  screenPositionForPixelPosition: (pixelPosition) ->\n    targetTop = pixelPosition.top\n    targetLeft = pixelPosition.left\n    defaultCharWidth = @defaultCharWidth\n    row = Math.floor(targetTop / @getLineHeight())\n    row = Math.min(row, @getLastRow())\n    row = Math.max(0, row)\n\n    left = 0\n    column = 0\n    for token in @lineForRow(row).tokens\n      charWidths = @getScopedCharWidths(token.scopes)\n      for char in token.value\n        charWidth = charWidths[char] ? defaultCharWidth\n        break if targetLeft <= left + (charWidth / 2)\n        left += charWidth\n        column++\n\n    new Point(row, column)\n\n  pixelPositionForBufferPosition: (bufferPosition) ->\n    @pixelPositionForScreenPosition(@screenPositionForBufferPosition(bufferPosition))\n\n  # Gets the number of screen lines.\n  #\n  # Returns a {Number}.\n  getLineCount: ->\n    @screenLines.length\n\n  # Gets the number of the last screen line.\n  #\n  # Returns a {Number}.\n  getLastRow: ->\n    @getLineCount() - 1\n\n  # Gets the length of the longest screen line.\n  #\n  # Returns a {Number}.\n  getMaxLineLength: ->\n    @maxLineLength\n\n  # Given a buffer position, this converts it into a screen position.\n  #\n  # bufferPosition - An object that represents a buffer position. It can be either\n  #                  an {Object} (`{row, column}`), {Array} (`[row, column]`), or {Point}\n  # options - A hash of options with the following keys:\n  #           wrapBeyondNewlines:\n  #           wrapAtSoftNewlines:\n  #\n  # Returns a {Point}.\n  screenPositionForBufferPosition: (bufferPosition, options) ->\n    { row, column } = @buffer.clipPosition(bufferPosition)\n    [startScreenRow, endScreenRow] = @rowMap.screenRowRangeForBufferRow(row)\n    for screenRow in [startScreenRow...endScreenRow]\n      screenLine = @screenLines[screenRow]\n\n      unless screenLine?\n        throw new BufferToScreenConversionError \"No screen line exists when converting buffer row to screen row\",\n          softWrapEnabled: @getSoftWrap()\n          foldCount: @findFoldMarkers().length\n          lastBufferRow: @buffer.getLastRow()\n          lastScreenRow: @getLastRow()\n\n      maxBufferColumn = screenLine.getMaxBufferColumn()\n      if screenLine.isSoftWrapped() and column > maxBufferColumn\n        continue\n      else\n        if column <= maxBufferColumn\n          screenColumn = screenLine.screenColumnForBufferColumn(column)\n        else\n          screenColumn = Infinity\n        break\n\n    @clipScreenPosition([screenRow, screenColumn], options)\n\n  # Given a buffer position, this converts it into a screen position.\n  #\n  # screenPosition - An object that represents a buffer position. It can be either\n  #                  an {Object} (`{row, column}`), {Array} (`[row, column]`), or {Point}\n  # options - A hash of options with the following keys:\n  #           wrapBeyondNewlines:\n  #           wrapAtSoftNewlines:\n  #\n  # Returns a {Point}.\n  bufferPositionForScreenPosition: (screenPosition, options) ->\n    { row, column } = @clipScreenPosition(Point.fromObject(screenPosition), options)\n    [bufferRow] = @rowMap.bufferRowRangeForScreenRow(row)\n    new Point(bufferRow, @screenLines[row].bufferColumnForScreenColumn(column))\n\n  # Retrieves the grammar's token scopes for a buffer position.\n  #\n  # bufferPosition - A {Point} in the {TextBuffer}\n  #\n  # Returns an {Array} of {String}s.\n  scopesForBufferPosition: (bufferPosition) ->\n    @tokenizedBuffer.scopesForPosition(bufferPosition)\n\n  bufferRangeForScopeAtPosition: (selector, position) ->\n    @tokenizedBuffer.bufferRangeForScopeAtPosition(selector, position)\n\n  # Retrieves the grammar's token for a buffer position.\n  #\n  # bufferPosition - A {Point} in the {TextBuffer}.\n  #\n  # Returns a {Token}.\n  tokenForBufferPosition: (bufferPosition) ->\n    @tokenizedBuffer.tokenForPosition(bufferPosition)\n\n  # Get the grammar for this buffer.\n  #\n  # Returns the current {Grammar} or the {NullGrammar}.\n  getGrammar: ->\n    @tokenizedBuffer.grammar\n\n  # Sets the grammar for the buffer.\n  #\n  # grammar - Sets the new grammar rules\n  setGrammar: (grammar) ->\n    @tokenizedBuffer.setGrammar(grammar)\n\n  # Reloads the current grammar.\n  reloadGrammar: ->\n    @tokenizedBuffer.reloadGrammar()\n\n  # Given a position, this clips it to a real position.\n  #\n  # For example, if `position`'s row exceeds the row count of the buffer,\n  # or if its column goes beyond a line's length, this \"sanitizes\" the value\n  # to a real position.\n  #\n  # position - The {Point} to clip\n  # options - A hash with the following values:\n  #           wrapBeyondNewlines: if `true`, continues wrapping past newlines\n  #           wrapAtSoftNewlines: if `true`, continues wrapping past soft newlines\n  #           screenLine: if `true`, indicates that you're using a line number, not a row number\n  #\n  # Returns the new, clipped {Point}. Note that this could be the same as `position` if no clipping was performed.\n  clipScreenPosition: (screenPosition, options={}) ->\n    { wrapBeyondNewlines, wrapAtSoftNewlines } = options\n    { row, column } = Point.fromObject(screenPosition)\n\n    if row < 0\n      row = 0\n      column = 0\n    else if row > @getLastRow()\n      row = @getLastRow()\n      column = Infinity\n    else if column < 0\n      column = 0\n\n    screenLine = @screenLines[row]\n    maxScreenColumn = screenLine.getMaxScreenColumn()\n\n    if screenLine.isSoftWrapped() and column >= maxScreenColumn\n      if wrapAtSoftNewlines\n        row++\n        column = 0\n      else\n        column = screenLine.clipScreenColumn(maxScreenColumn - 1)\n    else if wrapBeyondNewlines and column > maxScreenColumn and row < @getLastRow()\n      row++\n      column = 0\n    else\n      column = screenLine.clipScreenColumn(column, options)\n    new Point(row, column)\n\n  # Given a line, finds the point where it would wrap.\n  #\n  # line - The {String} to check\n  # softWrapColumn - The {Number} where you want soft wrapping to occur\n  #\n  # Returns a {Number} representing the `line` position where the wrap would take place.\n  # Returns `null` if a wrap wouldn't occur.\n  findWrapColumn: (line, softWrapColumn=@getSoftWrapColumn()) ->\n    return unless @softWrap\n    return unless line.length > softWrapColumn\n\n    if /\\s/.test(line[softWrapColumn])\n      # search forward for the start of a word past the boundary\n      for column in [softWrapColumn..line.length]\n        return column if /\\S/.test(line[column])\n      return line.length\n    else\n      # search backward for the start of the word on the boundary\n      for column in [softWrapColumn..0]\n        return column + 1 if /\\s/.test(line[column])\n      return softWrapColumn\n\n  # Calculates a {Range} representing the start of the {TextBuffer} until the end.\n  #\n  # Returns a {Range}.\n  rangeForAllLines: ->\n    new Range([0, 0], @clipScreenPosition([Infinity, Infinity]))\n\n  # Retrieves a {DisplayBufferMarker} based on its id.\n  #\n  # id - A {Number} representing a marker id\n  #\n  # Returns the {DisplayBufferMarker} (if it exists).\n  getMarker: (id) ->\n    unless marker = @markers[id]\n      if bufferMarker = @buffer.getMarker(id)\n        marker = new DisplayBufferMarker({bufferMarker, displayBuffer: this})\n        @markers[id] = marker\n    marker\n\n  # Retrieves the active markers in the buffer.\n  #\n  # Returns an {Array} of existing {DisplayBufferMarker}s.\n  getMarkers: ->\n    @buffer.getMarkers().map ({id}) => @getMarker(id)\n\n  getMarkerCount: ->\n    @buffer.getMarkerCount()\n\n  # Public: Constructs a new marker at the given screen range.\n  #\n  # range - The marker {Range} (representing the distance between the head and tail)\n  # options - Options to pass to the {Marker} constructor\n  #\n  # Returns a {Number} representing the new marker's ID.\n  markScreenRange: (args...) ->\n    bufferRange = @bufferRangeForScreenRange(args.shift())\n    @markBufferRange(bufferRange, args...)\n\n  # Public: Constructs a new marker at the given buffer range.\n  #\n  # range - The marker {Range} (representing the distance between the head and tail)\n  # options - Options to pass to the {Marker} constructor\n  #\n  # Returns a {Number} representing the new marker's ID.\n  markBufferRange: (range, options) ->\n    @getMarker(@buffer.markRange(range, options).id)\n\n  # Public: Constructs a new marker at the given screen position.\n  #\n  # range - The marker {Range} (representing the distance between the head and tail)\n  # options - Options to pass to the {Marker} constructor\n  #\n  # Returns a {Number} representing the new marker's ID.\n  markScreenPosition: (screenPosition, options) ->\n    @markBufferPosition(@bufferPositionForScreenPosition(screenPosition), options)\n\n  # Public: Constructs a new marker at the given buffer position.\n  #\n  # range - The marker {Range} (representing the distance between the head and tail)\n  # options - Options to pass to the {Marker} constructor\n  #\n  # Returns a {Number} representing the new marker's ID.\n  markBufferPosition: (bufferPosition, options) ->\n    @getMarker(@buffer.markPosition(bufferPosition, options).id)\n\n  # Public: Removes the marker with the given id.\n  #\n  # id - The {Number} of the ID to remove\n  destroyMarker: (id) ->\n    @buffer.destroyMarker(id)\n    delete @markers[id]\n\n  # Finds the first marker satisfying the given attributes\n  #\n  # Refer to {DisplayBuffer::findMarkers} for details.\n  #\n  # Returns a {DisplayBufferMarker} or null\n  findMarker: (params) ->\n    @findMarkers(params)[0]\n\n  # Public: Find all markers satisfying a set of parameters.\n  #\n  # params - An {Object} containing parameters that all returned markers must\n  #   satisfy. Unreserved keys will be compared against the markers' custom\n  #   properties. There are also the following reserved keys with special\n  #   meaning for the query:\n  #   :startBufferRow - A {Number}. Only returns markers starting at this row in\n  #     buffer coordinates.\n  #   :endBufferRow - A {Number}. Only returns markers ending at this row in\n  #     buffer coordinates.\n  #   :containsBufferRange - A {Range} or range-compatible {Array}. Only returns\n  #     markers containing this range in buffer coordinates.\n  #   :containsBufferPosition - A {Point} or point-compatible {Array}. Only\n  #     returns markers containing this position in buffer coordinates.\n  #   :containedInBufferRange - A {Range} or range-compatible {Array}. Only\n  #     returns markers contained within this range.\n  #\n  # Returns an {Array} of {DisplayBufferMarker}s\n  findMarkers: (params) ->\n    params = @translateToBufferMarkerParams(params)\n    @buffer.findMarkers(params).map (stringMarker) => @getMarker(stringMarker.id)\n\n  translateToBufferMarkerParams: (params) ->\n    bufferMarkerParams = {}\n    for key, value of params\n      switch key\n        when 'startBufferRow'\n          key = 'startRow'\n        when 'endBufferRow'\n          key = 'endRow'\n        when 'containsBufferRange'\n          key = 'containsRange'\n        when 'containsBufferPosition'\n          key = 'containsPosition'\n        when 'containedInBufferRange'\n          key = 'containedInRange'\n      bufferMarkerParams[key] = value\n    bufferMarkerParams\n\n  findFoldMarker: (attributes) ->\n    @findFoldMarkers(attributes)[0]\n\n  findFoldMarkers: (attributes) ->\n    @buffer.findMarkers(@getFoldMarkerAttributes(attributes))\n\n  getFoldMarkerAttributes: (attributes={}) ->\n    _.extend(attributes, class: 'fold', displayBufferId: @id)\n\n  pauseMarkerObservers: ->\n    marker.pauseEvents() for marker in @getMarkers()\n\n  resumeMarkerObservers: ->\n    marker.resumeEvents() for marker in @getMarkers()\n    @emit 'markers-updated'\n\n  refreshMarkerScreenPositions: ->\n    for marker in @getMarkers()\n      marker.notifyObservers(textChanged: false)\n\n  destroy: ->\n    marker.unsubscribe() for marker in @getMarkers()\n    @tokenizedBuffer.destroy()\n    @unsubscribe()\n\n  logLines: (start=0, end=@getLastRow())->\n    for row in [start..end]\n      line = @lineForRow(row).text\n      console.log row, @bufferRowForScreenRow(row), line, line.length\n\n  handleTokenizedBufferChange: (tokenizedBufferChange) =>\n    {start, end, delta, bufferChange} = tokenizedBufferChange\n    @updateScreenLines(start, end + 1, delta, delayChangeEvent: bufferChange?)\n\n  updateScreenLines: (startBufferRow, endBufferRow, bufferDelta=0, options={}) ->\n    startBufferRow = @rowMap.bufferRowRangeForBufferRow(startBufferRow)[0]\n    endBufferRow = @rowMap.bufferRowRangeForBufferRow(endBufferRow - 1)[1]\n    startScreenRow = @rowMap.screenRowRangeForBufferRow(startBufferRow)[0]\n    endScreenRow = @rowMap.screenRowRangeForBufferRow(endBufferRow - 1)[1]\n\n    {screenLines, regions} = @buildScreenLines(startBufferRow, endBufferRow + bufferDelta)\n    @screenLines[startScreenRow...endScreenRow] = screenLines\n    @rowMap.spliceRegions(startBufferRow, endBufferRow - startBufferRow, regions)\n    @findMaxLineLength(startScreenRow, endScreenRow, screenLines)\n\n    return if options.suppressChangeEvent\n\n    changeEvent =\n      start: startScreenRow\n      end: endScreenRow - 1\n      screenDelta: screenLines.length - (endScreenRow - startScreenRow)\n      bufferDelta: bufferDelta\n\n    if options.delayChangeEvent\n      @pauseMarkerObservers()\n      @pendingChangeEvent = changeEvent\n    else\n      @emitChanged(changeEvent, options.refreshMarkers)\n\n  buildScreenLines: (startBufferRow, endBufferRow) ->\n    screenLines = []\n    regions = []\n    rectangularRegion = null\n\n    bufferRow = startBufferRow\n    while bufferRow < endBufferRow\n      tokenizedLine = @tokenizedBuffer.lineForScreenRow(bufferRow)\n\n      if fold = @largestFoldStartingAtBufferRow(bufferRow)\n        foldLine = tokenizedLine.copy()\n        foldLine.fold = fold\n        screenLines.push(foldLine)\n\n        if rectangularRegion?\n          regions.push(rectangularRegion)\n          rectangularRegion = null\n\n        foldedRowCount = fold.getBufferRowCount()\n        regions.push(bufferRows: foldedRowCount, screenRows: 1)\n        bufferRow += foldedRowCount\n      else\n        softWraps = 0\n        while wrapScreenColumn = @findWrapColumn(tokenizedLine.text)\n          [wrappedLine, tokenizedLine] = tokenizedLine.softWrapAt(wrapScreenColumn)\n          screenLines.push(wrappedLine)\n          softWraps++\n        screenLines.push(tokenizedLine)\n\n        if softWraps > 0\n          if rectangularRegion?\n            regions.push(rectangularRegion)\n            rectangularRegion = null\n          regions.push(bufferRows: 1, screenRows: softWraps + 1)\n        else\n          rectangularRegion ?= {bufferRows: 0, screenRows: 0}\n          rectangularRegion.bufferRows++\n          rectangularRegion.screenRows++\n\n        bufferRow++\n\n    if rectangularRegion?\n      regions.push(rectangularRegion)\n\n    {screenLines, regions}\n\n  findMaxLineLength: (startScreenRow, endScreenRow, newScreenLines) ->\n    if startScreenRow <= @longestScreenRow < endScreenRow\n      @longestScreenRow = 0\n      @maxLineLength = 0\n      maxLengthCandidatesStartRow = 0\n      maxLengthCandidates = @screenLines\n    else\n      maxLengthCandidatesStartRow = startScreenRow\n      maxLengthCandidates = newScreenLines\n\n    for screenLine, screenRow in maxLengthCandidates\n      length = screenLine.text.length\n      if length > @maxLineLength\n        @longestScreenRow = maxLengthCandidatesStartRow + screenRow\n        @maxLineLength = length\n\n  handleBufferMarkersUpdated: =>\n    if event = @pendingChangeEvent\n      @pendingChangeEvent = null\n      @emitChanged(event, false)\n\n  handleBufferMarkerCreated: (marker) =>\n    @createFoldForMarker(marker) if marker.matchesAttributes(@getFoldMarkerAttributes())\n    @emit 'marker-created', @getMarker(marker.id)\n\n  createFoldForMarker: (marker) ->\n    new Fold(this, marker)\n\n  foldForMarker: (marker) ->\n    @foldsByMarkerId[marker.id]\n","markers":{"markers":{"1":{"id":1,"range":[[305,39],[305,39]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":65,"autoscroll":true,"goalBufferRange":null,"preserveFolds":true},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/zk/napplelabs/atom/src/display-buffer.coffee","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"4bedfed9d5578d039ec14b61d6f7cfa2d47513ed","deserializer":"TextBuffer"},{"text":"_ = require 'underscore-plus'\n{Model} = require 'theorist'\n{Point, Range} = require 'text-buffer'\nSerializable = require 'serializable'\nTokenizedLine = require './tokenized-line'\nToken = require './token'\n\nmodule.exports =\nclass TokenizedBuffer extends Model\n  Serializable.includeInto(this)\n\n  @property 'tabLength'\n\n  grammar: null\n  currentGrammarScore: null\n  buffer: null\n  tokenizedLines: null\n  chunkSize: 50\n  invalidRows: null\n  visible: false\n\n  constructor: ({@buffer, @tabLength}) ->\n    @tabLength ?= atom.config.getPositiveInt('editor.tabLength', 2)\n\n    @subscribe atom.syntax, 'grammar-added grammar-updated', (grammar) =>\n      if grammar.injectionSelector?\n        @resetTokenizedLines() if @hasTokenForSelector(grammar.injectionSelector)\n      else\n        newScore = grammar.getScore(@buffer.getPath(), @buffer.getText())\n        @setGrammar(grammar, newScore) if newScore > @currentGrammarScore\n\n    @on 'grammar-changed grammar-updated', => @resetTokenizedLines()\n    @subscribe @buffer, \"changed\", (e) => @handleBufferChange(e)\n    @subscribe @buffer, \"path-changed\", => @bufferPath = @buffer.getPath()\n\n    @subscribe @$tabLength.changes, (tabLength) =>\n      lastRow = @buffer.getLastRow()\n      @tokenizedLines = @buildPlaceholderTokenizedLinesForRows(0, lastRow)\n      @invalidateRow(0)\n      @emit \"changed\", { start: 0, end: lastRow, delta: 0 }\n\n    @subscribe atom.config.observe 'editor.tabLength', callNow: false, =>\n      @setTabLength(atom.config.getPositiveInt('editor.tabLength', 2))\n\n    @reloadGrammar()\n\n  serializeParams: ->\n    bufferPath: @buffer.getPath()\n    tabLength: @tabLength\n\n  deserializeParams: (params) ->\n    params.buffer = atom.project.bufferForPathSync(params.bufferPath)\n    params\n\n  setGrammar: (grammar, score) ->\n    return if grammar is @grammar\n    @unsubscribe(@grammar) if @grammar\n    @grammar = grammar\n    @currentGrammarScore = score ? grammar.getScore(@buffer.getPath(), @buffer.getText())\n    @subscribe @grammar, 'grammar-updated', => @resetTokenizedLines()\n    @emit 'grammar-changed', grammar\n\n  reloadGrammar: ->\n    if grammar = atom.syntax.selectGrammar(@buffer.getPath(), @buffer.getText())\n      @setGrammar(grammar)\n    else\n      throw new Error(\"No grammar found for path: #{path}\")\n\n  hasTokenForSelector: (selector) ->\n    for {tokens} in @tokenizedLines\n      for token in tokens\n        return true if selector.matches(token.scopes)\n    false\n\n  resetTokenizedLines: ->\n    @tokenizedLines = @buildPlaceholderTokenizedLinesForRows(0, @buffer.getLastRow())\n    @invalidRows = []\n    @invalidateRow(0)\n\n  setVisible: (@visible) ->\n    @tokenizeInBackground() if @visible\n\n  # Retrieves the current tab length.\n  #\n  # Returns a {Number}.\n  getTabLength: ->\n    @tabLength\n\n  # Specifies the tab length.\n  #\n  # tabLength - A {Number} that defines the new tab length.\n  setTabLength: (@tabLength) ->\n\n  tokenizeInBackground: ->\n    return if not @visible or @pendingChunk or not @isAlive()\n    @pendingChunk = true\n    _.defer =>\n      @pendingChunk = false\n      @tokenizeNextChunk() if @isAlive() and @buffer.isAlive()\n\n  tokenizeNextChunk: ->\n    rowsRemaining = @chunkSize\n\n    while @firstInvalidRow()? and rowsRemaining > 0\n      invalidRow = @invalidRows.shift()\n      lastRow = @getLastRow()\n      continue if invalidRow > lastRow\n\n      row = invalidRow\n      loop\n        previousStack = @stackForRow(row)\n        @tokenizedLines[row] = @buildTokenizedTokenizedLineForRow(row, @stackForRow(row - 1))\n        if --rowsRemaining == 0\n          filledRegion = false\n          break\n        if row == lastRow or _.isEqual(@stackForRow(row), previousStack)\n          filledRegion = true\n          break\n        row++\n\n      @validateRow(row)\n      @invalidateRow(row + 1) unless filledRegion\n      @emit \"changed\", { start: invalidRow, end: row, delta: 0 }\n\n    @tokenizeInBackground() if @firstInvalidRow()?\n\n  firstInvalidRow: ->\n    @invalidRows[0]\n\n  validateRow: (row) ->\n    @invalidRows.shift() while @invalidRows[0] <= row\n\n  invalidateRow: (row) ->\n    @invalidRows.push(row)\n    @invalidRows.sort (a, b) -> a - b\n    @tokenizeInBackground()\n\n  updateInvalidRows: (start, end, delta) ->\n    @invalidRows = @invalidRows.map (row) ->\n      if row < start\n        row\n      else if start <= row <= end\n        end + delta + 1\n      else if row > end\n        row + delta\n\n  handleBufferChange: (e) ->\n    {oldRange, newRange} = e\n    start = oldRange.start.row\n    end = oldRange.end.row\n    delta = newRange.end.row - oldRange.end.row\n\n    @updateInvalidRows(start, end, delta)\n    previousEndStack = @stackForRow(end) # used in spill detection below\n    newTokenizedLines = @buildTokenizedLinesForRows(start, end + delta, @stackForRow(start - 1))\n    _.spliceWithArray(@tokenizedLines, start, end - start + 1, newTokenizedLines)\n    newEndStack = @stackForRow(end + delta)\n\n    if newEndStack and not _.isEqual(newEndStack, previousEndStack)\n      @invalidateRow(end + delta + 1)\n\n    @emit \"changed\", { start, end, delta, bufferChange: e }\n\n  buildTokenizedLinesForRows: (startRow, endRow, startingStack) ->\n    ruleStack = startingStack\n    stopTokenizingAt = startRow + @chunkSize\n    tokenizedLines = for row in [startRow..endRow]\n      if (ruleStack or row == 0) and row < stopTokenizingAt\n        screenLine = @buildTokenizedTokenizedLineForRow(row, ruleStack)\n        ruleStack = screenLine.ruleStack\n      else\n        screenLine = @buildPlaceholderTokenizedLineForRow(row)\n      screenLine\n\n    if endRow >= stopTokenizingAt\n      @invalidateRow(stopTokenizingAt)\n      @tokenizeInBackground()\n\n    tokenizedLines\n\n  buildPlaceholderTokenizedLinesForRows: (startRow, endRow) ->\n    @buildPlaceholderTokenizedLineForRow(row) for row in [startRow..endRow]\n\n  buildPlaceholderTokenizedLineForRow: (row) ->\n    line = @buffer.lineForRow(row)\n    tokens = [new Token(value: line, scopes: [@grammar.scopeName])]\n    tabLength = @getTabLength()\n    indentLevel = @indentLevelForRow(row)\n    new TokenizedLine({tokens, tabLength, indentLevel})\n\n  buildTokenizedTokenizedLineForRow: (row, ruleStack) ->\n    line = @buffer.lineForRow(row)\n    lineEnding = @buffer.lineEndingForRow(row)\n    tabLength = @getTabLength()\n    indentLevel = @indentLevelForRow(row)\n    { tokens, ruleStack } = @grammar.tokenizeLine(line, ruleStack, row is 0)\n    new TokenizedLine({tokens, ruleStack, tabLength, lineEnding, indentLevel})\n\n  # FIXME: benogle says: These are actually buffer rows as all buffer rows are\n  # accounted for in @tokenizedLines\n  lineForScreenRow: (row) ->\n    @linesForScreenRows(row, row)[0]\n\n  # FIXME: benogle says: These are actually buffer rows as all buffer rows are\n  # accounted for in @tokenizedLines\n  linesForScreenRows: (startRow, endRow) ->\n    @tokenizedLines[startRow..endRow]\n\n  stackForRow: (row) ->\n    @tokenizedLines[row]?.ruleStack\n\n  indentLevelForRow: (row) ->\n    line = @buffer.lineForRow(row)\n\n    if line is ''\n      nextRow = row + 1\n      lineCount = @getLineCount()\n      while nextRow < lineCount\n        nextLine = @buffer.lineForRow(nextRow)\n        return @indentLevelForLine(nextLine) unless nextLine is ''\n        nextRow++\n\n      previousRow = row - 1\n      while previousRow >= 0\n        previousLine = @buffer.lineForRow(previousRow)\n        return @indentLevelForLine(previousLine) unless previousLine is ''\n        previousRow--\n\n      0\n    else\n      @indentLevelForLine(line)\n\n  indentLevelForLine: (line) ->\n    if match = line.match(/^[\\t ]+/)\n      leadingWhitespace = match[0]\n      tabCount = leadingWhitespace.match(/\\t/g)?.length ? 0\n      spaceCount = leadingWhitespace.match(/[ ]/g)?.length ? 0\n      tabCount + (spaceCount / @getTabLength())\n    else\n      0\n\n  scopesForPosition: (position) ->\n    @tokenForPosition(position).scopes\n\n  tokenForPosition: (position) ->\n    {row, column} = Point.fromObject(position)\n    @tokenizedLines[row].tokenAtBufferColumn(column)\n\n  tokenStartPositionForPosition: (position) ->\n    {row, column} = Point.fromObject(position)\n    column = @tokenizedLines[row].tokenStartColumnForBufferColumn(column)\n    new Point(row, column)\n\n  bufferRangeForScopeAtPosition: (selector, position) ->\n    position = Point.fromObject(position)\n    tokenizedLine = @tokenizedLines[position.row]\n    startIndex = tokenizedLine.tokenIndexAtBufferColumn(position.column)\n\n    for index in [startIndex..0]\n      token = tokenizedLine.tokenAtIndex(index)\n      break unless token.matchesScopeSelector(selector)\n      firstToken = token\n\n    for index in [startIndex...tokenizedLine.getTokenCount()]\n      token = tokenizedLine.tokenAtIndex(index)\n      break unless token.matchesScopeSelector(selector)\n      lastToken = token\n\n    return unless firstToken? and lastToken?\n\n    startColumn = tokenizedLine.bufferColumnForToken(firstToken)\n    endColumn = tokenizedLine.bufferColumnForToken(lastToken) + lastToken.bufferDelta\n    new Range([position.row, startColumn], [position.row, endColumn])\n\n  iterateTokensInBufferRange: (bufferRange, iterator) ->\n    bufferRange = Range.fromObject(bufferRange)\n    { start, end } = bufferRange\n\n    keepLooping = true\n    stop = -> keepLooping = false\n\n    for bufferRow in [start.row..end.row]\n      bufferColumn = 0\n      for token in @tokenizedLines[bufferRow].tokens\n        startOfToken = new Point(bufferRow, bufferColumn)\n        iterator(token, startOfToken, { stop }) if bufferRange.containsPoint(startOfToken)\n        return unless keepLooping\n        bufferColumn += token.bufferDelta\n\n  backwardsIterateTokensInBufferRange: (bufferRange, iterator) ->\n    bufferRange = Range.fromObject(bufferRange)\n    { start, end } = bufferRange\n\n    keepLooping = true\n    stop = -> keepLooping = false\n\n    for bufferRow in [end.row..start.row]\n      bufferColumn = @buffer.lineLengthForRow(bufferRow)\n      for token in new Array(@tokenizedLines[bufferRow].tokens...).reverse()\n        bufferColumn -= token.bufferDelta\n        startOfToken = new Point(bufferRow, bufferColumn)\n        iterator(token, startOfToken, { stop }) if bufferRange.containsPoint(startOfToken)\n        return unless keepLooping\n\n  findOpeningBracket: (startBufferPosition) ->\n    range = [[0,0], startBufferPosition]\n    position = null\n    depth = 0\n    @backwardsIterateTokensInBufferRange range, (token, startPosition, { stop }) ->\n      if token.isBracket()\n        if token.value == '}'\n          depth++\n        else if token.value == '{'\n          depth--\n          if depth == 0\n            position = startPosition\n            stop()\n    position\n\n  findClosingBracket: (startBufferPosition) ->\n    range = [startBufferPosition, @buffer.getEndPosition()]\n    position = null\n    depth = 0\n    @iterateTokensInBufferRange range, (token, startPosition, { stop }) ->\n      if token.isBracket()\n        if token.value == '{'\n          depth++\n        else if token.value == '}'\n          depth--\n          if depth == 0\n            position = startPosition\n            stop()\n    position\n\n  # Gets the row number of the last line.\n  #\n  # Returns a {Number}.\n  getLastRow: ->\n    @buffer.getLastRow()\n\n  getLineCount: ->\n    @buffer.getLineCount()\n\n  logLines: (start=0, end=@buffer.getLastRow()) ->\n    for row in [start..end]\n      line = @lineForScreenRow(row).text\n      console.log row, line, line.length\n","markers":{"markers":{"1":{"id":1,"range":[[232,20],[232,20]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":69,"autoscroll":true,"goalBufferRange":null,"preserveFolds":true},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/zk/napplelabs/atom/src/tokenized-buffer.coffee","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"d3bbc2787e1b6e4c4d6885776a7ce4fc868e8643","deserializer":"TextBuffer"},{"text":"{View, $, $$$} = require './space-pen-extensions'\nGutterView = require './gutter-view'\n{Point, Range} = require 'text-buffer'\nEditor = require './editor'\nCursorView = require './cursor-view'\nSelectionView = require './selection-view'\nfs = require 'fs-plus'\n_ = require 'underscore-plus'\nTextBuffer = require 'text-buffer'\n\nMeasureRange = document.createRange()\nTextNodeFilter = { acceptNode: -> NodeFilter.FILTER_ACCEPT }\nNoScope = ['no-scope']\nLongLineLength = 1000\n\n# Public: Represents the entire visual pane in Atom.\n#\n# The EditorView manages the {Editor}, which manages the file buffers.\n#\n# ## Requiring in packages\n#\n# ```coffee\n# {EditorView} = require 'atom'\n#\n# miniEditorView = new EditorView(mini: true)\n# ```\n#\n# ## Iterating over the open editor views\n#\n# ```coffee\n# for editorView in atom.workspace.getEditorViews()\n#   console.log(editorView.getEditor().getPath())\n# ```\n#\n# ## Subscribing to every current and future editor\n#\n# ```coffee\n# atom.workspace.eachEditorView (editorView) ->\n#   console.log(editorView.getEditor().getPath())\n# ```\nmodule.exports =\nclass EditorView extends View\n  @characterWidthCache: {}\n  @configDefaults:\n    fontFamily: ''\n    fontSize: 16\n    lineHeight: 1.3\n    showInvisibles: false\n    showIndentGuide: false\n    showLineNumbers: true\n    autoIndent: true\n    normalizeIndentOnPaste: true\n    nonWordCharacters: \"./\\\\()\\\"':,.;<>~!@#$%^&*|+=[]{}`?-\"\n    preferredLineLength: 80\n    tabLength: 2\n    softWrap: false\n    softTabs: true\n    softWrapAtPreferredLineLength: false\n\n  @nextEditorId: 1\n\n  @content: (params) ->\n    attributes = { class: @classes(params), tabindex: -1 }\n    _.extend(attributes, params.attributes) if params.attributes\n    @div attributes, =>\n      @subview 'gutter', new GutterView\n      @div class: 'scroll-view', outlet: 'scrollView', =>\n        @div class: 'overlayer', outlet: 'overlayer'\n        @div class: 'lines', outlet: 'renderedLines'\n        @div class: 'underlayer', outlet: 'underlayer', =>\n          @input class: 'hidden-input', outlet: 'hiddenInput'\n      @div class: 'vertical-scrollbar', outlet: 'verticalScrollbar', =>\n        @div outlet: 'verticalScrollbarContent'\n\n  @classes: ({mini} = {}) ->\n    classes = ['editor', 'editor-colors']\n    classes.push 'mini' if mini\n    classes.join(' ')\n\n  vScrollMargin: 2\n  hScrollMargin: 10\n  lineHeight: null\n  charWidth: null\n  charHeight: null\n  cursorViews: null\n  selectionViews: null\n  lineCache: null\n  isFocused: false\n  editor: null\n  attached: false\n  lineOverdraw: 10\n  pendingChanges: null\n  newCursors: null\n  newSelections: null\n  redrawOnReattach: false\n  bottomPaddingInLines: 10\n\n  # The constructor for setting up an `EditorView` instance.\n  #\n  # editorOrOptions - Either an {Editor}, or an object with one property, `mini`.\n  #                   If `mini` is `true`, a \"miniature\" `Editor` is constructed.\n  #                   Typically, this is ideal for scenarios where you need an Atom editor,\n  #                   but without all the chrome, like scrollbars, gutter, _e.t.c._.\n  #\n  initialize: (editorOrOptions) ->\n    if editorOrOptions instanceof Editor\n      editor = editorOrOptions\n    else\n      {editor, @mini, placeholderText} = editorOrOptions ? {}\n\n    @id = EditorView.nextEditorId++\n    @lineCache = []\n    @configure()\n    @bindKeys()\n    @handleEvents()\n    @handleInputEvents()\n    @cursorViews = []\n    @selectionViews = []\n    @pendingChanges = []\n    @newCursors = []\n    @newSelections = []\n\n    @setPlaceholderText(placeholderText) if placeholderText\n\n    if editor?\n      @edit(editor)\n    else if @mini\n      @edit(new Editor\n        buffer: new TextBuffer\n        softWrap: false\n        tabLength: 2\n        softTabs: true\n      )\n    else\n      throw new Error(\"Must supply an Editor or mini: true\")\n\n  # Sets up the core Atom commands.\n  #\n  # Some commands are excluded from mini-editors.\n  bindKeys: ->\n    editorBindings =\n      'core:move-left': => @editor.moveCursorLeft()\n      'core:move-right': => @editor.moveCursorRight()\n      'core:select-left': => @editor.selectLeft()\n      'core:select-right': => @editor.selectRight()\n      'core:select-all': => @editor.selectAll()\n      'core:backspace': => @editor.backspace()\n      'core:delete': => @editor.delete()\n      'core:undo': => @editor.undo()\n      'core:redo': => @editor.redo()\n      'core:cut': => @editor.cutSelectedText()\n      'core:copy': => @editor.copySelectedText()\n      'core:paste': => @editor.pasteText()\n      'editor:move-to-previous-word': => @editor.moveCursorToPreviousWord()\n      'editor:select-word': => @editor.selectWord()\n      'editor:consolidate-selections': (event) => @consolidateSelections(event)\n      'editor:backspace-to-beginning-of-word': => @editor.backspaceToBeginningOfWord()\n      'editor:backspace-to-beginning-of-line': => @editor.backspaceToBeginningOfLine()\n      'editor:delete-to-end-of-word': => @editor.deleteToEndOfWord()\n      'editor:delete-line': => @editor.deleteLine()\n      'editor:cut-to-end-of-line': => @editor.cutToEndOfLine()\n      'editor:move-to-beginning-of-screen-line': => @editor.moveCursorToBeginningOfScreenLine()\n      'editor:move-to-beginning-of-line': => @editor.moveCursorToBeginningOfLine()\n      'editor:move-to-end-of-screen-line': => @editor.moveCursorToEndOfScreenLine()\n      'editor:move-to-end-of-line': => @editor.moveCursorToEndOfLine()\n      'editor:move-to-first-character-of-line': => @editor.moveCursorToFirstCharacterOfLine()\n      'editor:move-to-beginning-of-word': => @editor.moveCursorToBeginningOfWord()\n      'editor:move-to-end-of-word': => @editor.moveCursorToEndOfWord()\n      'editor:move-to-beginning-of-next-word': => @editor.moveCursorToBeginningOfNextWord()\n      'editor:move-to-previous-word-boundary': => @editor.moveCursorToPreviousWordBoundary()\n      'editor:move-to-next-word-boundary': => @editor.moveCursorToNextWordBoundary()\n      'editor:select-to-end-of-line': => @editor.selectToEndOfLine()\n      'editor:select-to-beginning-of-line': => @editor.selectToBeginningOfLine()\n      'editor:select-to-end-of-word': => @editor.selectToEndOfWord()\n      'editor:select-to-beginning-of-word': => @editor.selectToBeginningOfWord()\n      'editor:select-to-beginning-of-next-word': => @editor.selectToBeginningOfNextWord()\n      'editor:select-to-next-word-boundary': => @editor.selectToNextWordBoundary()\n      'editor:select-to-previous-word-boundary': => @editor.selectToPreviousWordBoundary()\n      'editor:select-to-first-character-of-line': => @editor.selectToFirstCharacterOfLine()\n      'editor:select-line': => @editor.selectLine()\n      'editor:transpose': => @editor.transpose()\n      'editor:upper-case': => @editor.upperCase()\n      'editor:lower-case': => @editor.lowerCase()\n\n    unless @mini\n      _.extend editorBindings,\n        'core:move-up': => @editor.moveCursorUp()\n        'core:move-down': => @editor.moveCursorDown()\n        'core:move-to-top': => @editor.moveCursorToTop()\n        'core:move-to-bottom': => @editor.moveCursorToBottom()\n        'core:page-down': => @pageDown()\n        'core:page-up': => @pageUp()\n        'core:select-up': => @editor.selectUp()\n        'core:select-down': => @editor.selectDown()\n        'core:select-to-top': => @editor.selectToTop()\n        'core:select-to-bottom': => @editor.selectToBottom()\n        'editor:indent': => @editor.indent()\n        'editor:auto-indent': => @editor.autoIndentSelectedRows()\n        'editor:indent-selected-rows': => @editor.indentSelectedRows()\n        'editor:outdent-selected-rows': => @editor.outdentSelectedRows()\n        'editor:newline': => @editor.insertNewline()\n        'editor:newline-below': => @editor.insertNewlineBelow()\n        'editor:newline-above': => @editor.insertNewlineAbove()\n        'editor:add-selection-below': => @editor.addSelectionBelow()\n        'editor:add-selection-above': => @editor.addSelectionAbove()\n        'editor:split-selections-into-lines': => @editor.splitSelectionsIntoLines()\n        'editor:toggle-soft-tabs': => @toggleSoftTabs()\n        'editor:toggle-soft-wrap': => @toggleSoftWrap()\n        'editor:fold-all': => @editor.foldAll()\n        'editor:unfold-all': => @editor.unfoldAll()\n        'editor:fold-current-row': => @editor.foldCurrentRow()\n        'editor:unfold-current-row': => @editor.unfoldCurrentRow()\n        'editor:fold-selection': => @editor.foldSelectedLines()\n        'editor:fold-at-indent-level-1': => @editor.foldAllAtIndentLevel(0)\n        'editor:fold-at-indent-level-2': => @editor.foldAllAtIndentLevel(1)\n        'editor:fold-at-indent-level-3': => @editor.foldAllAtIndentLevel(2)\n        'editor:fold-at-indent-level-4': => @editor.foldAllAtIndentLevel(3)\n        'editor:fold-at-indent-level-5': => @editor.foldAllAtIndentLevel(4)\n        'editor:fold-at-indent-level-6': => @editor.foldAllAtIndentLevel(5)\n        'editor:fold-at-indent-level-7': => @editor.foldAllAtIndentLevel(6)\n        'editor:fold-at-indent-level-8': => @editor.foldAllAtIndentLevel(7)\n        'editor:fold-at-indent-level-9': => @editor.foldAllAtIndentLevel(8)\n        'editor:toggle-line-comments': => @toggleLineCommentsInSelection()\n        'editor:log-cursor-scope': => @logCursorScope()\n        'editor:checkout-head-revision': => @checkoutHead()\n        'editor:copy-path': => @copyPathToClipboard()\n        'editor:move-line-up': => @editor.moveLineUp()\n        'editor:move-line-down': => @editor.moveLineDown()\n        'editor:duplicate-lines': => @editor.duplicateLines()\n        'editor:join-lines': => @editor.joinLines()\n        'editor:toggle-indent-guide': => atom.config.toggle('editor.showIndentGuide')\n        'editor:toggle-line-numbers': =>  atom.config.toggle('editor.showLineNumbers')\n        'editor:scroll-to-cursor': => @scrollToCursorPosition()\n\n    documentation = {}\n    for name, method of editorBindings\n      do (name, method) =>\n        @command name, (e) -> method(e); false\n\n  # Public: Get the underlying editor model for this view.\n  #\n  # Returns an {Editor}.\n  getEditor: ->\n    @editor\n\n  # {Delegates to: Editor.getText}\n  getText: ->\n    @editor.getText()\n\n  # {Delegates to: Editor.setText}\n  setText: (text) ->\n    @editor.setText(text)\n\n  # {Delegates to: Editor.insertText}\n  insertText: (text, options) ->\n    @editor.insertText(text, options)\n\n  setHeightInLines: (heightInLines)->\n    heightInLines ?= @calculateHeightInLines()\n    @heightInLines = heightInLines if heightInLines\n\n  # {Delegates to: Editor.setEditorWidthInChars}\n  setWidthInChars: (widthInChars) ->\n    widthInChars ?= @calculateWidthInChars()\n    @editor.setEditorWidthInChars(widthInChars) if widthInChars\n\n  # Public: Emulates the \"page down\" key, where the last row of a buffer scrolls\n  # to become the first.\n  pageDown: ->\n    newScrollTop = @scrollTop() + @scrollView[0].clientHeight\n    @editor.moveCursorDown(@getPageRows())\n    @scrollTop(newScrollTop,  adjustVerticalScrollbar: true)\n\n  # Public: Emulates the \"page up\" key, where the frst row of a buffer scrolls\n  # to become the last.\n  pageUp: ->\n    newScrollTop = @scrollTop() - @scrollView[0].clientHeight\n    @editor.moveCursorUp(@getPageRows())\n    @scrollTop(newScrollTop,  adjustVerticalScrollbar: true)\n\n  # Public: Gets the number of actual page rows existing in an editor.\n  #\n  # Returns a {Number}.\n  getPageRows: ->\n    Math.max(1, Math.ceil(@scrollView[0].clientHeight / @lineHeight))\n\n  # Public: Set whether invisible characters are shown.\n  #\n  # showInvisibles - A {Boolean} which, if `true`, show invisible characters.\n  setShowInvisibles: (showInvisibles) ->\n    return if showInvisibles == @showInvisibles\n    @showInvisibles = showInvisibles\n    @resetDisplay()\n\n  # Public: Defines which characters are invisible.\n  #\n  # invisibles - An {Object} defining the invisible characters:\n  #   :eol   - The end of line invisible {String} (default: `\\u00ac`).\n  #   :space - The space invisible {String} (default: `\\u00b7`).\n  #   :tab   - The tab invisible {String} (default: `\\u00bb`).\n  #   :cr    - The carriage return invisible {String} (default: `\\u00a4`).\n  setInvisibles: (@invisibles={}) ->\n    _.defaults @invisibles,\n      eol: '\\u00ac'\n      space: '\\u00b7'\n      tab: '\\u00bb'\n      cr: '\\u00a4'\n    @resetDisplay()\n\n  # Public: Sets whether you want to show the indentation guides.\n  #\n  # showIndentGuide - A {Boolean} you can set to `true` if you want to see the\n  #                   indentation guides.\n  setShowIndentGuide: (showIndentGuide) ->\n    return if showIndentGuide == @showIndentGuide\n    @showIndentGuide = showIndentGuide\n    @resetDisplay()\n\n  # Public: Set the text to appear in the editor when it is empty.\n  #\n  # This only affects mini editors.\n  #\n  # placeholderText - A {String} of text to display when empty.\n  setPlaceholderText: (placeholderText) ->\n    return unless @mini\n    @placeholderText = placeholderText\n    @requestDisplayUpdate()\n\n  getPlaceholderText: ->\n    @placeholderText\n\n  # Checkout the HEAD revision of this editor's file.\n  checkoutHead: ->\n    if path = @editor.getPath()\n      atom.project.getRepo()?.checkoutHead(path)\n\n  configure: ->\n    @subscribe atom.config.observe 'editor.showLineNumbers', (showLineNumbers) => @gutter.setShowLineNumbers(showLineNumbers)\n    @subscribe atom.config.observe 'editor.showInvisibles', (showInvisibles) => @setShowInvisibles(showInvisibles)\n    @subscribe atom.config.observe 'editor.showIndentGuide', (showIndentGuide) => @setShowIndentGuide(showIndentGuide)\n    @subscribe atom.config.observe 'editor.invisibles', (invisibles) => @setInvisibles(invisibles)\n    @subscribe atom.config.observe 'editor.fontSize', (fontSize) => @setFontSize(fontSize)\n    @subscribe atom.config.observe 'editor.fontFamily', (fontFamily) => @setFontFamily(fontFamily)\n    @subscribe atom.config.observe 'editor.lineHeight', (lineHeight) => @setLineHeight(lineHeight)\n\n  handleEvents: ->\n    @on 'focus', =>\n      @hiddenInput.focus()\n      false\n\n    @hiddenInput.on 'focus', =>\n      @bringHiddenInputIntoView()\n      @isFocused = true\n      @addClass 'is-focused'\n\n    @hiddenInput.on 'focusout', =>\n      @bringHiddenInputIntoView()\n      @isFocused = false\n      @removeClass 'is-focused'\n\n    @underlayer.on 'mousedown', (e) =>\n      @renderedLines.trigger(e)\n      false if @isFocused\n\n    @overlayer.on 'mousedown', (e) =>\n      @overlayer.hide()\n      clickedElement = document.elementFromPoint(e.pageX, e.pageY)\n      @overlayer.show()\n      e.target = clickedElement\n      $(clickedElement).trigger(e)\n      false if @isFocused\n\n    @renderedLines.on 'mousedown', '.fold.line', (e) =>\n      id = $(e.currentTarget).attr('fold-id')\n      marker = @editor.displayBuffer.getMarker(id)\n      @editor.setCursorBufferPosition(marker.getBufferRange().start)\n      @editor.destroyFoldWithId(id)\n      false\n\n    @gutter.on 'mousedown', '.foldable .icon-right', (e) =>\n      bufferRow = $(e.target).parent().data('bufferRow')\n      @editor.toggleFoldAtBufferRow(bufferRow)\n      false\n\n    @renderedLines.on 'mousedown', (e) =>\n      clickCount = e.originalEvent.detail\n\n      screenPosition = @screenPositionFromMouseEvent(e)\n      if clickCount == 1\n        if e.metaKey\n          @editor.addCursorAtScreenPosition(screenPosition)\n        else if e.shiftKey\n          @editor.selectToScreenPosition(screenPosition)\n        else\n          @editor.setCursorScreenPosition(screenPosition)\n      else if clickCount == 2\n        @editor.selectWord() unless e.shiftKey\n      else if clickCount == 3\n        @editor.selectLine() unless e.shiftKey\n\n      @selectOnMousemoveUntilMouseup() unless e.ctrlKey or e.originalEvent.which > 1\n\n    unless @mini\n      @scrollView.on 'mousewheel', (e) =>\n        if delta = e.originalEvent.wheelDeltaY\n          @scrollTop(@scrollTop() - delta)\n          false\n\n    @verticalScrollbar.on 'scroll', =>\n      @scrollTop(@verticalScrollbar.scrollTop(), adjustVerticalScrollbar: false)\n\n    @scrollView.on 'scroll', =>\n      if @scrollLeft() == 0\n        @gutter.removeClass('drop-shadow')\n      else\n        @gutter.addClass('drop-shadow')\n\n    # Listen for overflow events to detect when the editor's width changes\n    # to update the soft wrap column.\n    updateWidthInChars = _.debounce((=> @setWidthInChars()), 100)\n    @scrollView.on 'overflowchanged', =>\n      updateWidthInChars() if @[0].classList.contains('soft-wrap')\n\n    @subscribe atom.themes, 'stylesheets-changed', => @recalculateDimensions()\n\n  handleInputEvents: ->\n    @on 'cursor:moved', =>\n      return unless @isFocused\n      cursorView = @getCursorView()\n\n      if cursorView.isVisible()\n        # This is an order of magnitude faster than checking .offset().\n        style = cursorView[0].style\n        @hiddenInput[0].style.top = style.top\n        @hiddenInput[0].style.left = style.left\n\n    selectedText = null\n    @hiddenInput.on 'compositionstart', =>\n      selectedText = @editor.getSelectedText()\n      @hiddenInput.css('width', '100%')\n    @hiddenInput.on 'compositionupdate', (e) =>\n      @editor.insertText(e.originalEvent.data, {select: true, undo: 'skip'})\n    @hiddenInput.on 'compositionend', =>\n      @editor.insertText(selectedText, {select: true, undo: 'skip'})\n      @hiddenInput.css('width', '1px')\n\n    lastInput = ''\n    @on \"textInput\", (e) =>\n      # Work around of the accented character suggestion feature in OS X.\n      selectedLength = @hiddenInput[0].selectionEnd - @hiddenInput[0].selectionStart\n      if selectedLength is 1 and lastInput is @hiddenInput.val()\n        @editor.selectLeft()\n\n      lastInput = e.originalEvent.data\n      @editor.insertText(lastInput)\n\n      if lastInput is ' '\n        true # Prevents parent elements from scrolling when a space is typed\n      else\n        @hiddenInput.val(lastInput)\n        false\n\n    # Ignore paste event, on Linux is wrongly emitted when user presses ctrl-v.\n    @on \"paste\", -> false\n\n  bringHiddenInputIntoView: ->\n    @hiddenInput.css(top: @scrollTop(), left: @scrollLeft())\n\n  selectOnMousemoveUntilMouseup: ->\n    lastMoveEvent = null\n\n    finalizeSelections = =>\n      clearInterval(interval)\n      $(document).off 'mousemove', moveHandler\n      $(document).off 'mouseup', finalizeSelections\n\n      unless @editor.isDestroyed()\n        @editor.mergeIntersectingSelections(reversed: @editor.getLastSelection().isReversed())\n        @editor.finalizeSelections()\n        @syncCursorAnimations()\n\n    moveHandler = (event = lastMoveEvent) =>\n      return unless event?\n\n      if event.which is 1 and @[0].style.display isnt 'none'\n        @editor.selectToScreenPosition(@screenPositionFromMouseEvent(event))\n        lastMoveEvent = event\n      else\n        finalizeSelections()\n\n    $(document).on \"mousemove.editor-#{@id}\", moveHandler\n    interval = setInterval(moveHandler, 20)\n    $(document).one \"mouseup.editor-#{@id}\", finalizeSelections\n\n  afterAttach: (onDom) ->\n    return unless onDom\n\n    # TODO: Remove this guard when we understand why this is happening\n    unless @editor.isAlive()\n      if atom.isReleasedVersion()\n        return\n      else\n        throw new Error(\"Assertion failure: EditorView is getting attached to a dead editor. Why?\")\n\n    @redraw() if @redrawOnReattach\n    return if @attached\n    @attached = true\n    @calculateDimensions()\n    @setWidthInChars()\n    @subscribe $(window), \"resize.editor-#{@id}\", =>\n      @setHeightInLines()\n      @setWidthInChars()\n      @updateLayerDimensions()\n      @requestDisplayUpdate()\n    @focus() if @isFocused\n\n    if pane = @getPane()\n      @active = @is(pane.activeView)\n      @subscribe pane, 'pane:active-item-changed', (event, item) =>\n        wasActive = @active\n        @active = @is(pane.activeView)\n        @redraw() if @active and not wasActive\n\n    @resetDisplay()\n\n    @trigger 'editor:attached', [this]\n\n  edit: (editor) ->\n    return if editor is @editor\n\n    if @editor\n      @saveScrollPositionForEditor()\n      @unsubscribe(@editor)\n\n    @editor = editor\n\n    return unless @editor?\n\n    @editor.setVisible(true)\n\n    @subscribe @editor, \"destroyed\", =>\n      @remove()\n\n    @subscribe @editor, \"contents-conflicted\", =>\n      @showBufferConflictAlert(@editor)\n\n    @subscribe @editor, \"path-changed\", =>\n      @editor.reloadGrammar()\n      @trigger 'editor:path-changed'\n\n    @subscribe @editor, \"grammar-changed\", =>\n      @trigger 'editor:grammar-changed'\n\n    @subscribe @editor, 'selection-added', (selection) =>\n      @newCursors.push(selection.cursor)\n      @newSelections.push(selection)\n      @requestDisplayUpdate()\n\n    @subscribe @editor, 'screen-lines-changed', (e) =>\n      @handleScreenLinesChange(e)\n\n    @subscribe @editor, 'scroll-top-changed', (scrollTop) =>\n      @scrollTop(scrollTop)\n\n    @subscribe @editor, 'scroll-left-changed', (scrollLeft) =>\n      @scrollLeft(scrollLeft)\n\n    @subscribe @editor, 'soft-wrap-changed', (softWrap) =>\n      @setSoftWrap(softWrap)\n\n    @trigger 'editor:path-changed'\n    @resetDisplay()\n\n    if @attached and @editor.buffer.isInConflict()\n      _.defer => @showBufferConflictAlert(@editor) # Display after editor has a chance to display\n\n  getModel: ->\n    @editor\n\n  setModel: (editor) ->\n    @edit(editor)\n\n  showBufferConflictAlert: (editor) ->\n    atom.confirm\n      message: editor.getPath()\n      detailedMessage: \"Has changed on disk. Do you want to reload it?\"\n      buttons:\n        Reload: -> editor.getBuffer().reload()\n        Cancel: null\n\n  scrollTop: (scrollTop, options={}) ->\n    return @cachedScrollTop or 0 unless scrollTop?\n    maxScrollTop = @verticalScrollbar.prop('scrollHeight') - @verticalScrollbar.height()\n    scrollTop = Math.floor(Math.max(0, Math.min(maxScrollTop, scrollTop)))\n    return if scrollTop == @cachedScrollTop\n    @cachedScrollTop = scrollTop\n\n    @updateDisplay() if @attached\n\n    @renderedLines.css('top', -scrollTop)\n    @underlayer.css('top', -scrollTop)\n    @overlayer.css('top', -scrollTop)\n    @gutter.lineNumbers.css('top', -scrollTop)\n\n    if options?.adjustVerticalScrollbar ? true\n      @verticalScrollbar.scrollTop(scrollTop)\n    @editor.setScrollTop(@scrollTop())\n\n  scrollBottom: (scrollBottom) ->\n    if scrollBottom?\n      @scrollTop(scrollBottom - @scrollView.height())\n    else\n      @scrollTop() + @scrollView.height()\n\n  scrollLeft: (scrollLeft) ->\n    if scrollLeft?\n      @scrollView.scrollLeft(scrollLeft)\n      @editor.setScrollLeft(@scrollLeft())\n    else\n      @scrollView.scrollLeft()\n\n  scrollRight: (scrollRight) ->\n    if scrollRight?\n      @scrollView.scrollRight(scrollRight)\n      @editor.setScrollLeft(@scrollLeft())\n    else\n      @scrollView.scrollRight()\n\n  # Public: Scrolls the editor to the bottom.\n  scrollToBottom: ->\n    @scrollBottom(@editor.getScreenLineCount() * @lineHeight)\n\n  # Public: Scrolls the editor to the position of the most recently added\n  # cursor.\n  #\n  # The editor is also centered.\n  scrollToCursorPosition: ->\n    @scrollToBufferPosition(@editor.getCursorBufferPosition(), center: true)\n\n  # Public: Scrolls the editor to the given buffer position.\n  #\n  # bufferPosition - An object that represents a buffer position. It can be either\n  #                  an {Object} (`{row, column}`), {Array} (`[row, column]`), or {Point}\n  # options - A hash matching the options available to {::scrollToPixelPosition}\n  scrollToBufferPosition: (bufferPosition, options) ->\n    @scrollToPixelPosition(@pixelPositionForBufferPosition(bufferPosition), options)\n\n  # Public: Scrolls the editor to the given screen position.\n  #\n  # screenPosition - An object that represents a buffer position. It can be either\n  #                  an {Object} (`{row, column}`), {Array} (`[row, column]`), or {Point}\n  # options - A hash matching the options available to {::scrollToPixelPosition}\n  scrollToScreenPosition: (screenPosition, options) ->\n    @scrollToPixelPosition(@pixelPositionForScreenPosition(screenPosition), options)\n\n  # Public: Scrolls the editor to the given pixel position.\n  #\n  # pixelPosition - An object that represents a pixel position. It can be either\n  #                 an {Object} (`{row, column}`), {Array} (`[row, column]`), or\n  #                 {Point}.\n  # options - A hash with the following keys:\n  #   :center - if `true`, the position is scrolled such that it's in\n  #             the center of the editor\n  scrollToPixelPosition: (pixelPosition, options) ->\n    return unless @attached\n    @scrollVertically(pixelPosition, options)\n    @scrollHorizontally(pixelPosition)\n\n  # Public: Highlight all the folds within the given buffer range.\n  #\n  # \"Highlighting\" essentially just adds the `fold-selected` class to the line's\n  # DOM element.\n  #\n  # bufferRange - The {Range} to check.\n  highlightFoldsContainingBufferRange: (bufferRange) ->\n    screenLines = @editor.linesForScreenRows(@firstRenderedScreenRow, @lastRenderedScreenRow)\n    for screenLine, i in screenLines\n      if fold = screenLine.fold\n        screenRow = @firstRenderedScreenRow + i\n        element = @lineElementForScreenRow(screenRow)\n\n        if bufferRange.intersectsWith(fold.getBufferRange())\n          element.addClass('fold-selected')\n        else\n          element.removeClass('fold-selected')\n\n  saveScrollPositionForEditor: ->\n    if @attached\n      @editor.setScrollTop(@scrollTop())\n      @editor.setScrollLeft(@scrollLeft())\n\n  # Public: Toggle soft tabs on the edit session.\n  toggleSoftTabs: ->\n    @editor.setSoftTabs(not @editor.getSoftTabs())\n\n  # Public: Toggle soft wrap on the edit session.\n  toggleSoftWrap: ->\n    @setWidthInChars()\n    @editor.setSoftWrap(not @editor.getSoftWrap())\n\n  calculateWidthInChars: ->\n    Math.floor((@scrollView.width() - @getScrollbarWidth()) / @charWidth)\n\n  calculateHeightInLines: ->\n    Math.ceil($(window).height() / @lineHeight)\n\n  getScrollbarWidth: ->\n    scrollbarElement = @verticalScrollbar[0]\n    scrollbarElement.offsetWidth - scrollbarElement.clientWidth\n\n  # Public: Enables/disables soft wrap on the editor.\n  #\n  # softWrap - A {Boolean} which, if `true`, enables soft wrap\n  setSoftWrap: (softWrap) ->\n    if softWrap\n      @addClass 'soft-wrap'\n      @scrollLeft(0)\n    else\n      @removeClass 'soft-wrap'\n\n  # Public: Sets the font size for the editor.\n  #\n  # fontSize - A {Number} indicating the font size in pixels.\n  setFontSize: (fontSize) ->\n    @css('font-size', \"#{fontSize}px\")\n\n    @clearCharacterWidthCache()\n\n    if @isOnDom()\n      @redraw()\n    else\n      @redrawOnReattach = @attached\n\n  # Public: Retrieves the font size for the editor.\n  #\n  # Returns a {Number} indicating the font size in pixels.\n  getFontSize: ->\n    parseInt(@css(\"font-size\"))\n\n  # Public: Sets the font family for the editor.\n  #\n  # fontFamily - A {String} identifying the CSS `font-family`.\n  setFontFamily: (fontFamily='') ->\n    @css('font-family', fontFamily)\n\n    @clearCharacterWidthCache()\n\n    @redraw()\n\n  # Public: Gets the font family for the editor.\n  #\n  # Returns a {String} identifying the CSS `font-family`.\n  getFontFamily: -> @css(\"font-family\")\n\n  # Public: Sets the line height of the editor.\n  #\n  # Calling this method has no effect when called on a mini editor.\n  #\n  # lineHeight - A {Number} without a unit suffix identifying the CSS\n  # `line-height`.\n  setLineHeight: (lineHeight) ->\n    return if @mini\n    @css('line-height', lineHeight)\n    @redraw()\n\n  # Public: Redraw the editor\n  redraw: ->\n    return unless @hasParent()\n    return unless @attached\n    @redrawOnReattach = false\n    @calculateDimensions()\n    @updatePaddingOfRenderedLines()\n    @updateLayerDimensions()\n    @requestDisplayUpdate()\n\n  # Public: Split the editor view left.\n  splitLeft: ->\n    pane = @getPane()\n    pane?.splitLeft(pane?.copyActiveItem()).activeView\n\n  # Public: Split the editor view right.\n  splitRight: ->\n    pane = @getPane()\n    pane?.splitRight(pane?.copyActiveItem()).activeView\n\n  # Public: Split the editor view up.\n  splitUp: ->\n    pane = @getPane()\n    pane?.splitUp(pane?.copyActiveItem()).activeView\n\n  # Public: Split the editor view down.\n  splitDown: ->\n    pane = @getPane()\n    pane?.splitDown(pane?.copyActiveItem()).activeView\n\n  # Public: Get this view's pane.\n  #\n  # Returns a {Pane}.\n  getPane: ->\n    @parent('.item-views').parents('.pane').view()\n\n  remove: (selector, keepData) ->\n    return super if keepData or @removed\n    super\n    atom.workspaceView?.focus()\n\n  beforeRemove: ->\n    @trigger 'editor:will-be-removed'\n    @removed = true\n    @editor?.destroy()\n    $(window).off(\".editor-#{@id}\")\n    $(document).off(\".editor-#{@id}\")\n\n  getCursorView: (index) ->\n    index ?= @cursorViews.length - 1\n    @cursorViews[index]\n\n  getCursorViews: ->\n    new Array(@cursorViews...)\n\n  addCursorView: (cursor, options) ->\n    cursorView = new CursorView(cursor, this, options)\n    @cursorViews.push(cursorView)\n    @overlayer.append(cursorView)\n    cursorView\n\n  removeCursorView: (cursorView) ->\n    _.remove(@cursorViews, cursorView)\n\n  getSelectionView: (index) ->\n    index ?= @selectionViews.length - 1\n    @selectionViews[index]\n\n  getSelectionViews: ->\n    new Array(@selectionViews...)\n\n  addSelectionView: (selection) ->\n    selectionView = new SelectionView({editorView: this, selection})\n    @selectionViews.push(selectionView)\n    @underlayer.append(selectionView)\n    selectionView\n\n  removeSelectionView: (selectionView) ->\n    _.remove(@selectionViews, selectionView)\n\n  removeAllCursorAndSelectionViews: ->\n    cursorView.remove() for cursorView in @getCursorViews()\n    selectionView.remove() for selectionView in @getSelectionViews()\n\n  appendToLinesView: (view) ->\n    @overlayer.append(view)\n\n  # Scrolls the editor vertically to a given position.\n  scrollVertically: (pixelPosition, {center}={}) ->\n    scrollViewHeight = @scrollView.height()\n    scrollTop = @scrollTop()\n    scrollBottom = scrollTop + scrollViewHeight\n\n    if center\n      unless scrollTop < pixelPosition.top < scrollBottom\n        @scrollTop(pixelPosition.top - (scrollViewHeight / 2))\n    else\n      linesInView = @scrollView.height() / @lineHeight\n      maxScrollMargin = Math.floor((linesInView - 1) / 2)\n      scrollMargin = Math.min(@vScrollMargin, maxScrollMargin)\n      margin = scrollMargin * @lineHeight\n      desiredTop = pixelPosition.top - margin\n      desiredBottom = pixelPosition.top + @lineHeight + margin\n      if desiredBottom > scrollBottom\n        @scrollTop(desiredBottom - scrollViewHeight)\n      else if desiredTop < scrollTop\n        @scrollTop(desiredTop)\n\n  # Scrolls the editor horizontally to a given position.\n  scrollHorizontally: (pixelPosition) ->\n    return if @editor.getSoftWrap()\n\n    charsInView = @scrollView.width() / @charWidth\n    maxScrollMargin = Math.floor((charsInView - 1) / 2)\n    scrollMargin = Math.min(@hScrollMargin, maxScrollMargin)\n    margin = scrollMargin * @charWidth\n    desiredRight = pixelPosition.left + @charWidth + margin\n    desiredLeft = pixelPosition.left - margin\n\n    if desiredRight > @scrollRight()\n      @scrollRight(desiredRight)\n    else if desiredLeft < @scrollLeft()\n      @scrollLeft(desiredLeft)\n    @saveScrollPositionForEditor()\n\n  calculateDimensions: ->\n    fragment = $('<div class=\"line\" style=\"position: absolute; visibility: hidden;\"><span>x</span></div>')\n    @renderedLines.append(fragment)\n\n    lineRect = fragment[0].getBoundingClientRect()\n    charRect = fragment.find('span')[0].getBoundingClientRect()\n    @lineHeight = lineRect.height\n    @charWidth = charRect.width\n    @charHeight = charRect.height\n    fragment.remove()\n    @setHeightInLines()\n\n  recalculateDimensions: ->\n    return unless @attached and @isVisible()\n\n    oldCharWidth = @charWidth\n    oldLineHeight = @lineHeight\n\n    @calculateDimensions()\n\n    unless @charWidth is oldCharWidth and @lineHeight is oldLineHeight\n      @clearCharacterWidthCache()\n      @requestDisplayUpdate()\n\n  updateLayerDimensions: (scrollViewWidth) ->\n    height = @lineHeight * @editor.getScreenLineCount()\n    unless @layerHeight == height\n      @layerHeight = height\n      @underlayer.height(@layerHeight)\n      @renderedLines.height(@layerHeight)\n      @overlayer.height(@layerHeight)\n      @verticalScrollbarContent.height(@layerHeight)\n      @scrollBottom(height) if @scrollBottom() > height\n\n    minWidth = Math.max(@charWidth * @editor.getMaxScreenLineLength() + 20, scrollViewWidth)\n    unless @layerMinWidth == minWidth\n      @renderedLines.css('min-width', minWidth)\n      @underlayer.css('min-width', minWidth)\n      @overlayer.css('min-width', minWidth)\n      @layerMinWidth = minWidth\n      @trigger 'editor:min-width-changed'\n\n  # Override for speed. The base function checks computedStyle, unnecessary here.\n  isHidden: ->\n    style = this[0].style\n    if style.display == 'none' or not @isOnDom()\n      true\n    else\n      false\n\n  clearRenderedLines: ->\n    @renderedLines.empty()\n    @firstRenderedScreenRow = null\n    @lastRenderedScreenRow = null\n\n  resetDisplay: ->\n    return unless @attached\n\n    @clearRenderedLines()\n    @removeAllCursorAndSelectionViews()\n    editorScrollTop = @editor.getScrollTop() ? 0\n    editorScrollLeft = @editor.getScrollLeft() ? 0\n    @updateLayerDimensions()\n    @scrollTop(editorScrollTop)\n    @scrollLeft(editorScrollLeft)\n    @setSoftWrap(@editor.getSoftWrap())\n    @newCursors = @editor.getCursors()\n    @newSelections = @editor.getSelections()\n    @updateDisplay(suppressAutoscroll: true)\n\n  requestDisplayUpdate: ->\n    return if @pendingDisplayUpdate\n    return unless @isVisible()\n    @pendingDisplayUpdate = true\n    setImmediate =>\n      @updateDisplay()\n      @pendingDisplayUpdate = false\n\n  updateDisplay: (options) ->\n    return unless @attached and @editor\n    return if @editor.isDestroyed()\n    unless @isOnDom() and @isVisible()\n      @redrawOnReattach = true\n      return\n\n    scrollViewWidth = @scrollView.width()\n    @updateRenderedLines(scrollViewWidth)\n    @updatePlaceholderText()\n    @highlightCursorLine()\n    @updateCursorViews()\n    @updateSelectionViews()\n    @autoscroll(options?.suppressAutoscroll ? false)\n    @trigger 'editor:display-updated'\n\n  updateCursorViews: ->\n    if @newCursors.length > 0\n      @addCursorView(cursor) for cursor in @newCursors when not cursor.destroyed\n      @syncCursorAnimations()\n      @newCursors = []\n\n    for cursorView in @getCursorViews()\n      if cursorView.needsRemoval\n        cursorView.remove()\n      else if @shouldUpdateCursor(cursorView)\n        cursorView.updateDisplay()\n\n  shouldUpdateCursor: (cursorView) ->\n    return false unless cursorView.needsUpdate\n\n    pos = cursorView.getScreenPosition()\n    pos.row >= @firstRenderedScreenRow and pos.row <= @lastRenderedScreenRow\n\n  updateSelectionViews: ->\n    if @newSelections.length > 0\n      @addSelectionView(selection) for selection in @newSelections when not selection.destroyed\n      @newSelections = []\n\n    for selectionView in @getSelectionViews()\n      if selectionView.needsRemoval\n        selectionView.remove()\n      else if @shouldUpdateSelection(selectionView)\n        selectionView.updateDisplay()\n\n  shouldUpdateSelection: (selectionView) ->\n    screenRange = selectionView.getScreenRange()\n    startRow = screenRange.start.row\n    endRow = screenRange.end.row\n    (startRow >= @firstRenderedScreenRow and startRow <= @lastRenderedScreenRow) or # startRow in range\n      (endRow >= @firstRenderedScreenRow and endRow <= @lastRenderedScreenRow) or # endRow in range\n      (startRow <= @firstRenderedScreenRow and endRow >= @lastRenderedScreenRow) # selection surrounds the rendered items\n\n  syncCursorAnimations: ->\n    cursorView.resetBlinking() for cursorView in @getCursorViews()\n\n  autoscroll: (suppressAutoscroll) ->\n    for cursorView in @getCursorViews()\n      if !suppressAutoscroll and cursorView.needsAutoscroll()\n        @scrollToPixelPosition(cursorView.getPixelPosition())\n      cursorView.clearAutoscroll()\n\n    for selectionView in @getSelectionViews()\n      if !suppressAutoscroll and selectionView.needsAutoscroll()\n        @scrollToPixelPosition(selectionView.getCenterPixelPosition(), center: true)\n        selectionView.highlight()\n      selectionView.clearAutoscroll()\n\n  updatePlaceholderText: ->\n    return unless @mini\n    if (not @placeholderText) or @editor.getText()\n      @find('.placeholder-text').remove()\n    else if @placeholderText and not @editor.getText()\n      element = @find('.placeholder-text')\n      if element.length\n        element.text(@placeholderText)\n      else\n        @underlayer.append($('<span/>', class: 'placeholder-text', text: @placeholderText))\n\n  updateRenderedLines: (scrollViewWidth) ->\n    firstVisibleScreenRow = @getFirstVisibleScreenRow()\n    lastScreenRowToRender = firstVisibleScreenRow + @heightInLines - 1\n    lastScreenRow = @editor.getLastScreenRow()\n\n    if @firstRenderedScreenRow? and firstVisibleScreenRow >= @firstRenderedScreenRow and lastScreenRowToRender <= @lastRenderedScreenRow\n      renderFrom = Math.min(lastScreenRow, @firstRenderedScreenRow)\n      renderTo = Math.min(lastScreenRow, @lastRenderedScreenRow)\n    else\n      renderFrom = Math.min(lastScreenRow, Math.max(0, firstVisibleScreenRow - @lineOverdraw))\n      renderTo = Math.min(lastScreenRow, lastScreenRowToRender + @lineOverdraw)\n\n    if @pendingChanges.length == 0 and @firstRenderedScreenRow and @firstRenderedScreenRow <= renderFrom and renderTo <= @lastRenderedScreenRow\n      return\n\n    changes = @pendingChanges\n    intactRanges = @computeIntactRanges(renderFrom, renderTo)\n\n    @gutter.updateLineNumbers(changes, renderFrom, renderTo)\n\n    @clearDirtyRanges(intactRanges)\n    @fillDirtyRanges(intactRanges, renderFrom, renderTo)\n    @firstRenderedScreenRow = renderFrom\n    @lastRenderedScreenRow = renderTo\n    @updateLayerDimensions(scrollViewWidth)\n    @updatePaddingOfRenderedLines()\n\n  computeSurroundingEmptyLineChanges: (change) ->\n    emptyLineChanges = []\n\n    if change.bufferDelta?\n      afterStart = change.end + change.bufferDelta + 1\n      if @editor.lineForBufferRow(afterStart) is ''\n        afterEnd = afterStart\n        afterEnd++ while @editor.lineForBufferRow(afterEnd + 1) is ''\n        emptyLineChanges.push({start: afterStart, end: afterEnd, screenDelta: 0})\n\n      beforeEnd = change.start - 1\n      if @editor.lineForBufferRow(beforeEnd) is ''\n        beforeStart = beforeEnd\n        beforeStart-- while @editor.lineForBufferRow(beforeStart - 1) is ''\n        emptyLineChanges.push({start: beforeStart, end: beforeEnd, screenDelta: 0})\n\n    emptyLineChanges\n\n  computeIntactRanges: (renderFrom, renderTo) ->\n    return [] if !@firstRenderedScreenRow? and !@lastRenderedScreenRow?\n\n    intactRanges = [{start: @firstRenderedScreenRow, end: @lastRenderedScreenRow, domStart: 0}]\n\n    if not @mini and @showIndentGuide\n      emptyLineChanges = []\n      for change in @pendingChanges\n        emptyLineChanges.push(@computeSurroundingEmptyLineChanges(change)...)\n      @pendingChanges.push(emptyLineChanges...)\n\n    for change in @pendingChanges\n      newIntactRanges = []\n      for range in intactRanges\n        if change.end < range.start and change.screenDelta != 0\n          newIntactRanges.push(\n            start: range.start + change.screenDelta\n            end: range.end + change.screenDelta\n            domStart: range.domStart\n          )\n        else if change.end < range.start or change.start > range.end\n          newIntactRanges.push(range)\n        else\n          if change.start > range.start\n            newIntactRanges.push(\n              start: range.start\n              end: change.start - 1\n              domStart: range.domStart)\n          if change.end < range.end\n            newIntactRanges.push(\n              start: change.end + change.screenDelta + 1\n              end: range.end + change.screenDelta\n              domStart: range.domStart + change.end + 1 - range.start\n            )\n      intactRanges = newIntactRanges\n\n    @truncateIntactRanges(intactRanges, renderFrom, renderTo)\n\n    @pendingChanges = []\n\n    intactRanges\n\n  truncateIntactRanges: (intactRanges, renderFrom, renderTo) ->\n    i = 0\n    while i < intactRanges.length\n      range = intactRanges[i]\n      if range.start < renderFrom\n        range.domStart += renderFrom - range.start\n        range.start = renderFrom\n      if range.end > renderTo\n        range.end = renderTo\n      if range.start >= range.end\n        intactRanges.splice(i--, 1)\n      i++\n    intactRanges.sort (a, b) -> a.domStart - b.domStart\n\n  clearDirtyRanges: (intactRanges) ->\n    if intactRanges.length == 0\n      @renderedLines[0].innerHTML = ''\n    else if currentLine = @renderedLines[0].firstChild\n      domPosition = 0\n      for intactRange in intactRanges\n        while intactRange.domStart > domPosition\n          currentLine = @clearLine(currentLine)\n          domPosition++\n        for i in [intactRange.start..intactRange.end]\n          currentLine = currentLine.nextSibling\n          domPosition++\n      while currentLine\n        currentLine = @clearLine(currentLine)\n\n  clearLine: (lineElement) ->\n    next = lineElement.nextSibling\n    @renderedLines[0].removeChild(lineElement)\n    next\n\n  fillDirtyRanges: (intactRanges, renderFrom, renderTo) ->\n    i = 0\n    nextIntact = intactRanges[i]\n    currentLine = @renderedLines[0].firstChild\n\n    row = renderFrom\n    while row <= renderTo\n      if row == nextIntact?.end + 1\n        nextIntact = intactRanges[++i]\n\n      if !nextIntact or row < nextIntact.start\n        if nextIntact\n          dirtyRangeEnd = nextIntact.start - 1\n        else\n          dirtyRangeEnd = renderTo\n\n        for lineElement in @buildLineElementsForScreenRows(row, dirtyRangeEnd)\n          @renderedLines[0].insertBefore(lineElement, currentLine)\n          row++\n      else\n        currentLine = currentLine.nextSibling\n        row++\n\n  updatePaddingOfRenderedLines: ->\n    paddingTop = @firstRenderedScreenRow * @lineHeight\n    @renderedLines.css('padding-top', paddingTop)\n    @gutter.lineNumbers.css('padding-top', paddingTop)\n\n    paddingBottom = (@editor.getLastScreenRow() - @lastRenderedScreenRow) * @lineHeight\n    @renderedLines.css('padding-bottom', paddingBottom)\n    @gutter.lineNumbers.css('padding-bottom', paddingBottom)\n\n  # Public: Retrieves the number of the row that is visible and currently at the\n  # top of the editor.\n  #\n  # Returns a {Number}.\n  getFirstVisibleScreenRow: ->\n    screenRow = Math.floor(@scrollTop() / @lineHeight)\n    screenRow = 0 if isNaN(screenRow)\n    screenRow\n\n  # Public: Retrieves the number of the row that is visible and currently at the\n  # bottom of the editor.\n  #\n  # Returns a {Number}.\n  getLastVisibleScreenRow: ->\n    calculatedRow = Math.ceil((@scrollTop() + @scrollView.height()) / @lineHeight) - 1\n    screenRow = Math.max(0, Math.min(@editor.getScreenLineCount() - 1, calculatedRow))\n    screenRow = 0 if isNaN(screenRow)\n    screenRow\n\n  # Public: Given a row number, identifies if it is currently visible.\n  #\n  # row - A row {Number} to check\n  #\n  # Returns a {Boolean}.\n  isScreenRowVisible: (row) ->\n    @getFirstVisibleScreenRow() <= row <= @getLastVisibleScreenRow()\n\n  handleScreenLinesChange: (change) ->\n    @pendingChanges.push(change)\n    @requestDisplayUpdate()\n\n  buildLineElementForScreenRow: (screenRow) ->\n    @buildLineElementsForScreenRows(screenRow, screenRow)[0]\n\n  buildLineElementsForScreenRows: (startRow, endRow) ->\n    div = document.createElement('div')\n    div.innerHTML = @htmlForScreenRows(startRow, endRow)\n    new Array(div.children...)\n\n  htmlForScreenRows: (startRow, endRow) ->\n    htmlLines = ''\n    screenRow = startRow\n    for line in @editor.linesForScreenRows(startRow, endRow)\n      htmlLines += @htmlForScreenLine(line, screenRow++)\n    htmlLines\n\n  htmlForScreenLine: (screenLine, screenRow) ->\n    { tokens, text, lineEnding, fold, isSoftWrapped } =  screenLine\n    if fold\n      attributes = { class: 'fold line', 'fold-id': fold.id }\n    else\n      attributes = { class: 'line' }\n\n    invisibles = @invisibles if @showInvisibles\n    eolInvisibles = @getEndOfLineInvisibles(screenLine)\n    htmlEolInvisibles = @buildHtmlEndOfLineInvisibles(screenLine)\n\n    indentation = EditorView.buildIndentation(screenRow, @editor)\n\n    EditorView.buildLineHtml({tokens, text, lineEnding, fold, isSoftWrapped, invisibles, eolInvisibles, htmlEolInvisibles, attributes, @showIndentGuide, indentation, @editor, @mini})\n\n  @buildIndentation: (screenRow, editor) ->\n    bufferRow = editor.bufferPositionForScreenPosition([screenRow]).row\n    bufferLine = editor.lineForBufferRow(bufferRow)\n    if bufferLine is ''\n      indentation = 0\n      nextRow = screenRow + 1\n      while nextRow < editor.getBuffer().getLineCount()\n        bufferRow = editor.bufferPositionForScreenPosition([nextRow]).row\n        bufferLine = editor.lineForBufferRow(bufferRow)\n        if bufferLine isnt ''\n          indentation = Math.ceil(editor.indentLevelForLine(bufferLine))\n          break\n        nextRow++\n\n      previousRow = screenRow - 1\n      while previousRow >= 0\n        bufferRow = editor.bufferPositionForScreenPosition([previousRow]).row\n        bufferLine = editor.lineForBufferRow(bufferRow)\n        if bufferLine isnt ''\n          indentation = Math.max(indentation, Math.ceil(editor.indentLevelForLine(bufferLine)))\n          break\n        previousRow--\n\n      indentation\n    else\n      Math.ceil(editor.indentLevelForLine(bufferLine))\n\n  buildHtmlEndOfLineInvisibles: (screenLine) ->\n    invisibles = []\n    for invisible in @getEndOfLineInvisibles(screenLine)\n      invisibles.push(\"<span class='invisible-character'>#{invisible}</span>\")\n    invisibles.join('')\n\n  getEndOfLineInvisibles: (screenLine) ->\n    return [] unless @showInvisibles and @invisibles\n    return [] if @mini or screenLine.isSoftWrapped()\n\n    invisibles = []\n    invisibles.push(@invisibles.cr) if @invisibles.cr and screenLine.lineEnding is '\\r\\n'\n    invisibles.push(@invisibles.eol) if @invisibles.eol\n    invisibles\n\n  lineElementForScreenRow: (screenRow) ->\n    @renderedLines.children(\":eq(#{screenRow - @firstRenderedScreenRow})\")\n\n  toggleLineCommentsInSelection: ->\n    @editor.toggleLineCommentsInSelection()\n\n  # Public: Converts a buffer position to a pixel position.\n  #\n  # position - An object that represents a buffer position. It can be either\n  #            an {Object} (`{row, column}`), {Array} (`[row, column]`), or {Point}\n  #\n  # Returns an object with two values: `top` and `left`, representing the pixel positions.\n  pixelPositionForBufferPosition: (position) ->\n    @pixelPositionForScreenPosition(@editor.screenPositionForBufferPosition(position))\n\n  # Public: Converts a screen position to a pixel position.\n  #\n  # position - An object that represents a screen position. It can be either\n  #            an {Object} (`{row, column}`), {Array} (`[row, column]`), or {Point}\n  #\n  # Returns an object with two values: `top` and `left`, representing the pixel positions.\n  pixelPositionForScreenPosition: (position) ->\n    return { top: 0, left: 0 } unless @isOnDom() and @isVisible()\n    {row, column} = Point.fromObject(position)\n    actualRow = Math.floor(row)\n\n    lineElement = existingLineElement = @lineElementForScreenRow(actualRow)[0]\n    unless existingLineElement\n      lineElement = @buildLineElementForScreenRow(actualRow)\n      @renderedLines.append(lineElement)\n    left = @positionLeftForLineAndColumn(lineElement, actualRow, column)\n    unless existingLineElement\n      @renderedLines[0].removeChild(lineElement)\n    { top: row * @lineHeight, left }\n\n  positionLeftForLineAndColumn: (lineElement, screenRow, screenColumn) ->\n    return 0 if screenColumn == 0\n\n    tokenizedLine = @editor.displayBuffer.lineForRow(screenRow)\n    textContent = lineElement.textContent\n\n    left = 0\n    index = 0\n    for token in tokenizedLine.tokens\n      for bufferChar in token.value\n        return left if index >= screenColumn\n\n        # Invisibles might cause renderedChar to be different than bufferChar\n        renderedChar = textContent[index]\n        val = @getCharacterWidthCache(token.scopes, renderedChar)\n        if val?\n          left += val\n        else\n          return @measureToColumn(lineElement, tokenizedLine, screenColumn)\n\n        index++\n    left\n\n  measureToColumn: (lineElement, tokenizedLine, screenColumn) ->\n    left = oldLeft = index = 0\n    iterator = document.createNodeIterator(lineElement, NodeFilter.SHOW_TEXT, TextNodeFilter)\n\n    returnLeft = null\n\n    offsetLeft = @scrollView.offset().left\n    paddingLeft = parseInt(@scrollView.css('padding-left'))\n\n    while textNode = iterator.nextNode()\n      content = textNode.textContent\n\n      for char, i in content\n        # Don't continue caching long lines :racehorse:\n        break if index > LongLineLength and screenColumn < index\n\n        # Dont return right away, finish caching the whole line\n        returnLeft = left if index == screenColumn\n        oldLeft = left\n\n        scopes = tokenizedLine.tokenAtBufferColumn(index)?.scopes\n        cachedCharWidth = @getCharacterWidthCache(scopes, char)\n\n        if cachedCharWidth?\n          left = oldLeft + cachedCharWidth\n        else\n          # i + 1 to measure to the end of the current character\n          MeasureRange.setEnd(textNode, i + 1)\n          MeasureRange.collapse()\n          rects = MeasureRange.getClientRects()\n          return 0 if rects.length == 0\n          left = rects[0].left - Math.floor(offsetLeft) + Math.floor(@scrollLeft()) - paddingLeft\n\n          if scopes?\n            cachedCharWidth = left - oldLeft\n            @setCharacterWidthCache(scopes, char, cachedCharWidth)\n\n        # Assume all the characters are the same width when dealing with long\n        # lines :racehorse:\n        return screenColumn * cachedCharWidth if index > LongLineLength\n\n        index++\n\n    returnLeft ? left\n\n  getCharacterWidthCache: (scopes, char) ->\n    scopes ?= NoScope\n    obj = @constructor.characterWidthCache\n    for scope in scopes\n      obj = obj[scope]\n      return null unless obj?\n    obj[char]\n\n  setCharacterWidthCache: (scopes, char, val) ->\n    scopes ?= NoScope\n    obj = @constructor.characterWidthCache\n    for scope in scopes\n      obj[scope] ?= {}\n      obj = obj[scope]\n    obj[char] = val\n\n  clearCharacterWidthCache: ->\n    @constructor.characterWidthCache = {}\n\n  pixelOffsetForScreenPosition: (position) ->\n    {top, left} = @pixelPositionForScreenPosition(position)\n    offset = @renderedLines.offset()\n    {top: top + offset.top, left: left + offset.left}\n\n  screenPositionFromMouseEvent: (e) ->\n    { pageX, pageY } = e\n    offset = @scrollView.offset()\n\n    editorRelativeTop = pageY - offset.top + @scrollTop()\n    row = Math.floor(editorRelativeTop / @lineHeight)\n    column = 0\n\n    if pageX > offset.left and lineElement = @lineElementForScreenRow(row)[0]\n      range = document.createRange()\n      iterator = document.createNodeIterator(lineElement, NodeFilter.SHOW_TEXT, acceptNode: -> NodeFilter.FILTER_ACCEPT)\n      while node = iterator.nextNode()\n        range.selectNodeContents(node)\n        column += node.textContent.length\n        {left, right} = range.getClientRects()[0]\n        break if left <= pageX <= right\n\n      if node\n        for characterPosition in [node.textContent.length...0]\n          range.setStart(node, characterPosition - 1)\n          range.setEnd(node, characterPosition)\n          {left, right, width} = range.getClientRects()[0]\n          break if left <= pageX - width / 2 <= right\n          column--\n\n      range.detach()\n\n    new Point(row, column)\n\n  # Highlights the current line the cursor is on.\n  highlightCursorLine: ->\n    return if @mini\n\n    @highlightedLine?.removeClass('cursor-line')\n    if @editor.getSelection().isEmpty()\n      @highlightedLine = @lineElementForScreenRow(@editor.getCursorScreenRow())\n      @highlightedLine.addClass('cursor-line')\n    else\n      @highlightedLine = null\n\n  # Copies the current file path to the native clipboard.\n  copyPathToClipboard: ->\n    path = @editor.getPath()\n    atom.clipboard.write(path) if path?\n\n  @buildLineHtml: ({tokens, text, lineEnding, fold, isSoftWrapped, invisibles, eolInvisibles, htmlEolInvisibles, attributes, showIndentGuide, indentation, editor, mini}) ->\n    scopeStack = []\n    line = []\n\n    attributePairs = ''\n    attributePairs += \" #{attributeName}=\\\"#{value}\\\"\" for attributeName, value of attributes\n    line.push(\"<div #{attributePairs}>\")\n\n    if text == ''\n      html = @buildEmptyLineHtml(showIndentGuide, eolInvisibles, htmlEolInvisibles, indentation, editor, mini)\n      line.push(html) if html\n    else\n      firstTrailingWhitespacePosition = text.search(/\\s*$/)\n      lineIsWhitespaceOnly = firstTrailingWhitespacePosition is 0\n      position = 0\n      for token in tokens\n        @updateScopeStack(line, scopeStack, token.scopes)\n        hasIndentGuide = not mini and showIndentGuide and token.hasLeadingWhitespace or (token.hasTrailingWhitespace and lineIsWhitespaceOnly)\n        line.push(token.getValueAsHtml({invisibles, hasIndentGuide}))\n        position += token.value.length\n\n    @popScope(line, scopeStack) while scopeStack.length > 0\n    line.push(htmlEolInvisibles) unless text == ''\n    line.push(\"<span class='fold-marker'/>\") if fold\n\n    line.push('</div>')\n    line.join('')\n\n  @updateScopeStack: (line, scopeStack, desiredScopes) ->\n    excessScopes = scopeStack.length - desiredScopes.length\n    if excessScopes > 0\n      @popScope(line, scopeStack) while excessScopes--\n\n    # pop until common prefix\n    for i in [scopeStack.length..0]\n      break if _.isEqual(scopeStack[0...i], desiredScopes[0...i])\n      @popScope(line, scopeStack)\n\n    # push on top of common prefix until scopeStack == desiredScopes\n    for j in [i...desiredScopes.length]\n      @pushScope(line, scopeStack, desiredScopes[j])\n\n    null\n\n  @pushScope: (line, scopeStack, scope) ->\n    scopeStack.push(scope)\n    line.push(\"<span class=\\\"#{scope.replace(/\\.+/g, ' ')}\\\">\")\n\n  @popScope: (line, scopeStack) ->\n    scopeStack.pop()\n    line.push(\"</span>\")\n\n  @buildEmptyLineHtml: (showIndentGuide, eolInvisibles, htmlEolInvisibles, indentation, editor, mini) ->\n    indentCharIndex = 0\n    if not mini and showIndentGuide\n      if indentation > 0\n        tabLength = editor.getTabLength()\n        indentGuideHtml = ''\n        for level in [0...indentation]\n          indentLevelHtml = \"<span class='indent-guide'>\"\n          for characterPosition in [0...tabLength]\n            if invisible = eolInvisibles[indentCharIndex++]\n              indentLevelHtml += \"<span class='invisible-character'>#{invisible}</span>\"\n            else\n              indentLevelHtml += ' '\n          indentLevelHtml += \"</span>\"\n          indentGuideHtml += indentLevelHtml\n\n        while indentCharIndex < eolInvisibles.length\n          indentGuideHtml += \"<span class='invisible-character'>#{eolInvisibles[indentCharIndex++]}</span>\"\n\n        return indentGuideHtml\n\n    if htmlEolInvisibles.length > 0\n      htmlEolInvisibles\n    else\n      '&nbsp;'\n\n  replaceSelectedText: (replaceFn) ->\n    selection = @editor.getSelection()\n    return false if selection.isEmpty()\n\n    text = replaceFn(@editor.getTextInRange(selection.getBufferRange()))\n    return false if text is null or text is undefined\n\n    @editor.insertText(text, select: true)\n    true\n\n  consolidateSelections: (e) -> e.abortKeyBinding() unless @editor.consolidateSelections()\n\n  logCursorScope: ->\n    console.log @editor.getCursorScopes()\n\n  logScreenLines: (start, end) ->\n    @editor.logScreenLines(start, end)\n\n  logRenderedLines: ->\n    @renderedLines.find('.line').each (n) ->\n      console.log n, $(this).text()\n","markers":{"markers":{"1":{"id":1,"range":[[0,0],[0,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":155,"preserveFolds":true,"goalBufferRange":null},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/zk/napplelabs/atom/src/editor-view.coffee","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"d5bb31c8f461e4d32db79986f868b80b8da45755","deserializer":"TextBuffer"},{"text":"_ = require 'underscore-plus'\nspacePen = require 'space-pen'\n{Subscriber} = require 'emissary'\n\nSubscriber.includeInto(spacePen.View)\n\njQuery = spacePen.jQuery\noriginalCleanData = jQuery.cleanData\njQuery.cleanData = (elements) ->\n  jQuery(element).view()?.unsubscribe() for element in elements\n  originalCleanData(elements)\n\ntooltipDefaults =\n  delay:\n    show: 1000\n    hide: 100\n  container: 'body'\n  html: true\n  placement: 'auto top'\n  viewportPadding: 2\n\nhumanizeKeystrokes = (keystroke) ->\n  keystrokes = keystroke.split(' ')\n  keystrokes = (_.humanizeKeystroke(stroke) for stroke in keystrokes)\n  keystrokes.join(' ')\n\ngetKeystroke = (bindings) ->\n  if bindings?.length\n    \"<span class=\\\"keystroke\\\">#{humanizeKeystrokes(bindings[0].keystrokes)}</span>\"\n  else\n    ''\n\nrequireBootstrapTooltip = _.once ->\n  atom.requireWithGlobals('bootstrap/js/tooltip', {jQuery})\n\n# options from http://getbootstrap.com/javascript/#tooltips\njQuery.fn.setTooltip = (tooltipOptions, {command, commandElement}={}) ->\n  requireBootstrapTooltip()\n\n  tooltipOptions = {title: tooltipOptions} if _.isString(tooltipOptions)\n\n  if commandElement\n    bindings = atom.keymaps.findKeyBindings(command: command, target: commandElement[0])\n  else if command\n    bindings = atom.keymaps.findKeyBindings(command: command)\n\n  tooltipOptions.title = \"#{tooltipOptions.title} #{getKeystroke(bindings)}\"\n\n  @tooltip(jQuery.extend({}, tooltipDefaults, tooltipOptions))\n\njQuery.fn.hideTooltip = ->\n  tip = @data('bs.tooltip')\n  if tip\n    tip.leave(currentTarget: this)\n    tip.hide()\n\njQuery.fn.destroyTooltip = ->\n  @hideTooltip()\n  requireBootstrapTooltip()\n  @tooltip('destroy')\n\n# Hide tooltips when window is resized\njQuery(document.body).on 'show.bs.tooltip', ({target}) ->\n  windowHandler = -> jQuery(target).hideTooltip()\n  jQuery(window).one('resize', windowHandler)\n  jQuery(target).one 'hide.bs.tooltip', ->\n    jQuery(window).off('resize', windowHandler)\n\njQuery.fn.setTooltip.getKeystroke = getKeystroke\njQuery.fn.setTooltip.humanizeKeystrokes = humanizeKeystrokes\n\nObject.defineProperty jQuery.fn, 'element', get: -> @[0]\n\nmodule.exports = spacePen\n","markers":{"markers":{"1":{"id":1,"range":[[0,0],[0,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":159,"preserveFolds":true,"goalBufferRange":null},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/zk/napplelabs/atom/src/space-pen-extensions.coffee","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"84d761359183d6688e013d4b187c6d8eb39f927a","deserializer":"TextBuffer"},{"text":"path = require 'path'\n\n_ = require 'underscore-plus'\nasync = require 'async'\nCSON = require 'season'\nfs = require 'fs-plus'\n{Emitter} = require 'emissary'\nQ = require 'q'\n\n$ = null # Defer require in case this is in the window-less browser process\nScopedProperties = require './scoped-properties'\n\n# Loads and activates a package's main module and resources such as\n# stylesheets, keymaps, grammar, editor properties, and menus.\nmodule.exports =\nclass Package\n  Emitter.includeInto(this)\n\n  @stylesheetsDir: 'stylesheets'\n\n  @loadMetadata: (packagePath, ignoreErrors=false) ->\n    if metadataPath = CSON.resolve(path.join(packagePath, 'package'))\n      try\n        metadata = CSON.readFileSync(metadataPath)\n      catch error\n        throw error unless ignoreErrors\n    metadata ?= {}\n    metadata.name = path.basename(packagePath)\n    metadata\n\n  keymaps: null\n  menus: null\n  stylesheets: null\n  grammars: null\n  scopedProperties: null\n  mainModulePath: null\n  resolvedMainModulePath: false\n  mainModule: null\n\n  constructor: (@path, @metadata) ->\n    @metadata ?= Package.loadMetadata(@path)\n    @name = @metadata?.name ? path.basename(@path)\n    @reset()\n\n  enable: ->\n    atom.config.removeAtKeyPath('core.disabledPackages', @name)\n\n  disable: ->\n    atom.config.pushAtKeyPath('core.disabledPackages', @name)\n\n  isTheme: ->\n    @metadata?.theme?\n\n  measure: (key, fn) ->\n    startTime = Date.now()\n    value = fn()\n    @[key] = Date.now() - startTime\n    value\n\n  getType: -> 'atom'\n\n  getStylesheetType: -> 'bundled'\n\n  load: ->\n    @measure 'loadTime', =>\n      try\n        @loadKeymaps()\n        @loadMenus()\n        @loadStylesheets()\n        @grammarsPromise = @loadGrammars()\n        @scopedPropertiesPromise = @loadScopedProperties()\n        @requireMainModule() unless @hasActivationEvents()\n\n      catch error\n        console.warn \"Failed to load package named '#{@name}'\", error.stack ? error\n    this\n\n  reset: ->\n    @stylesheets = []\n    @keymaps = []\n    @menus = []\n    @grammars = []\n    @scopedProperties = []\n\n  activate: ->\n    unless @activationDeferred?\n      @activationDeferred = Q.defer()\n      @measure 'activateTime', =>\n        @activateResources()\n        if @hasActivationEvents()\n          @subscribeToActivationEvents()\n        else\n          @activateNow()\n\n    Q.all([@grammarsPromise, @scopedPropertiesPromise, @activationDeferred.promise])\n\n  activateNow: ->\n    try\n      @activateConfig()\n      @activateStylesheets()\n      if @requireMainModule()\n        @mainModule.activate(atom.packages.getPackageState(@name) ? {})\n        @mainActivated = true\n    catch e\n      console.warn \"Failed to activate package named '#{@name}'\", e.stack\n\n    @activationDeferred.resolve()\n\n  activateConfig: ->\n    return if @configActivated\n\n    @requireMainModule()\n    if @mainModule?\n      atom.config.setDefaults(@name, @mainModule.configDefaults)\n      @mainModule.activateConfig?()\n    @configActivated = true\n\n  activateStylesheets: ->\n    return if @stylesheetsActivated\n\n    type = @getStylesheetType()\n    for [stylesheetPath, content] in @stylesheets\n      atom.themes.applyStylesheet(stylesheetPath, content, type)\n    @stylesheetsActivated = true\n\n  activateResources: ->\n    atom.keymaps.add(keymapPath, map) for [keymapPath, map] in @keymaps\n    atom.contextMenu.add(menuPath, map['context-menu']) for [menuPath, map] in @menus\n    atom.menu.add(map.menu) for [menuPath, map] in @menus when map.menu\n\n    grammar.activate() for grammar in @grammars\n    @grammarsActivated = true\n\n    scopedProperties.activate() for scopedProperties in @scopedProperties\n    @scopedPropertiesActivated = true\n\n  loadKeymaps: ->\n    @keymaps = @getKeymapPaths().map (keymapPath) -> [keymapPath, CSON.readFileSync(keymapPath)]\n\n  loadMenus: ->\n    @menus = @getMenuPaths().map (menuPath) -> [menuPath, CSON.readFileSync(menuPath)]\n\n  getKeymapPaths: ->\n    keymapsDirPath = path.join(@path, 'keymaps')\n    if @metadata.keymaps\n      @metadata.keymaps.map (name) -> fs.resolve(keymapsDirPath, name, ['json', 'cson', ''])\n    else\n      fs.listSync(keymapsDirPath, ['cson', 'json'])\n\n  getMenuPaths: ->\n    menusDirPath = path.join(@path, 'menus')\n    if @metadata.menus\n      @metadata.menus.map (name) -> fs.resolve(menusDirPath, name, ['json', 'cson', ''])\n    else\n      fs.listSync(menusDirPath, ['cson', 'json'])\n\n  loadStylesheets: ->\n    @stylesheets = @getStylesheetPaths().map (stylesheetPath) ->\n      [stylesheetPath, atom.themes.loadStylesheet(stylesheetPath)]\n\n  getStylesheetsPath: ->\n    path.join(@path, @constructor.stylesheetsDir)\n\n  getStylesheetPaths: ->\n    stylesheetDirPath = @getStylesheetsPath()\n\n    if @metadata.stylesheetMain\n      [fs.resolve(@path, @metadata.stylesheetMain)]\n    else if @metadata.stylesheets\n      @metadata.stylesheets.map (name) -> fs.resolve(stylesheetDirPath, name, ['css', 'less', ''])\n    else if indexStylesheet = fs.resolve(@path, 'index', ['css', 'less'])\n      [indexStylesheet]\n    else\n      fs.listSync(stylesheetDirPath, ['css', 'less'])\n\n  loadGrammars: ->\n    @grammars = []\n\n    loadGrammar = (grammarPath, callback) =>\n      atom.syntax.readGrammar grammarPath, (error, grammar) =>\n        if error?\n          console.warn(\"Failed to load grammar: #{grammarPath}\", error.stack ? error)\n        else\n          @grammars.push(grammar)\n          grammar.activate() if @grammarsActivated\n        callback()\n\n    deferred = Q.defer()\n    grammarsDirPath = path.join(@path, 'grammars')\n    fs.list grammarsDirPath, ['json', 'cson'], (error, grammarPaths=[]) ->\n      async.each grammarPaths, loadGrammar, -> deferred.resolve()\n    deferred.promise\n\n  loadScopedProperties: ->\n    @scopedProperties = []\n\n    loadScopedPropertiesFile = (scopedPropertiesPath, callback) =>\n      ScopedProperties.load scopedPropertiesPath, (error, scopedProperties) =>\n        if error?\n          console.warn(\"Failed to load scoped properties: #{scopedPropertiesPath}\", error.stack ? error)\n        else\n          @scopedProperties.push(scopedProperties)\n          scopedProperties.activate() if @scopedPropertiesActivated\n        callback()\n\n    deferred = Q.defer()\n    scopedPropertiesDirPath = path.join(@path, 'scoped-properties')\n    fs.list scopedPropertiesDirPath, ['json', 'cson'], (error, scopedPropertiesPaths=[]) ->\n      async.each scopedPropertiesPaths, loadScopedPropertiesFile, -> deferred.resolve()\n    deferred.promise\n\n  serialize: ->\n    if @mainActivated\n      try\n        @mainModule?.serialize?()\n      catch e\n        console.error \"Error serializing package '#{@name}'\", e.stack\n\n  deactivate: ->\n    @activationDeferred?.reject()\n    @activationDeferred = null\n    @unsubscribeFromActivationEvents()\n    @deactivateResources()\n    @deactivateConfig()\n    @mainModule?.deactivate?() if @mainActivated\n    @emit('deactivated')\n\n  deactivateConfig: ->\n    @mainModule?.deactivateConfig?()\n    @configActivated = false\n\n  deactivateResources: ->\n    grammar.deactivate() for grammar in @grammars\n    scopedProperties.deactivate() for scopedProperties in @scopedProperties\n    atom.keymaps.remove(keymapPath) for [keymapPath] in @keymaps\n    atom.themes.removeStylesheet(stylesheetPath) for [stylesheetPath] in @stylesheets\n    @stylesheetsActivated = false\n    @grammarsActivated = false\n    @scopedPropertiesActivated = false\n\n  reloadStylesheets: ->\n    oldSheets = _.clone(@stylesheets)\n    @loadStylesheets()\n    atom.themes.removeStylesheet(stylesheetPath) for [stylesheetPath] in oldSheets\n    @reloadStylesheet(stylesheetPath, content) for [stylesheetPath, content] in @stylesheets\n\n  reloadStylesheet: (stylesheetPath, content) ->\n    atom.themes.applyStylesheet(stylesheetPath, content, @getStylesheetType())\n\n  requireMainModule: ->\n    return @mainModule if @mainModule?\n    mainModulePath = @getMainModulePath()\n    @mainModule = require(mainModulePath) if fs.isFileSync(mainModulePath)\n\n  getMainModulePath: ->\n    return @mainModulePath if @resolvedMainModulePath\n    @resolvedMainModulePath = true\n    mainModulePath =\n      if @metadata.main\n        path.join(@path, @metadata.main)\n      else\n        path.join(@path, 'index')\n    @mainModulePath = fs.resolveExtension(mainModulePath, [\"\", _.keys(require.extensions)...])\n\n  hasActivationEvents: ->\n    if _.isArray(@metadata.activationEvents)\n      return @metadata.activationEvents.some (activationEvent) ->\n        activationEvent?.length > 0\n    else if _.isString(@metadata.activationEvents)\n      return @metadata.activationEvents.length > 0\n    else if _.isObject(@metadata.activationEvents)\n      for event, selector of @metadata.activationEvents\n        return true if event.length > 0 and selector.length > 0\n\n    false\n\n  subscribeToActivationEvents: ->\n    return unless @metadata.activationEvents?\n    if _.isArray(@metadata.activationEvents)\n      atom.workspaceView.command(event, @handleActivationEvent) for event in @metadata.activationEvents\n    else if _.isString(@metadata.activationEvents)\n      atom.workspaceView.command(@metadata.activationEvents, @handleActivationEvent)\n    else\n      atom.workspaceView.command(event, selector, @handleActivationEvent) for event, selector of @metadata.activationEvents\n\n  handleActivationEvent: (event) =>\n    bubblePathEventHandlers = @disableEventHandlersOnBubblePath(event)\n    @activateNow()\n    $ ?= require('./space-pen-extensions').$\n    $(event.target).trigger(event)\n    @restoreEventHandlersOnBubblePath(bubblePathEventHandlers)\n    @unsubscribeFromActivationEvents()\n    false\n\n  unsubscribeFromActivationEvents: ->\n    return unless atom.workspaceView?\n\n    if _.isArray(@metadata.activationEvents)\n      atom.workspaceView.off(event, @handleActivationEvent) for event in @metadata.activationEvents\n    else if _.isString(@metadata.activationEvents)\n      atom.workspaceView.off(@metadata.activationEvents, @handleActivationEvent)\n    else\n      atom.workspaceView.off(event, selector, @handleActivationEvent) for event, selector of @metadata.activationEvents\n\n  disableEventHandlersOnBubblePath: (event) ->\n    bubblePathEventHandlers = []\n    disabledHandler = ->\n    $ ?= require('./space-pen-extensions').$\n    element = $(event.target)\n    while element.length\n      if eventHandlers = element.handlers()?[event.type]\n        for eventHandler in eventHandlers\n          eventHandler.disabledHandler = eventHandler.handler\n          eventHandler.handler = disabledHandler\n          bubblePathEventHandlers.push(eventHandler)\n      element = element.parent()\n    bubblePathEventHandlers\n\n  restoreEventHandlersOnBubblePath: (eventHandlers) ->\n    for eventHandler in eventHandlers\n      eventHandler.handler = eventHandler.disabledHandler\n      delete eventHandler.disabledHandler\n","markers":{"markers":{"1":{"id":1,"range":[[0,0],[0,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":215,"preserveFolds":true,"goalBufferRange":null},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/zk/napplelabs/atom/src/package.coffee","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"9471e570e213585d0865bb9b7a4bbc28160c4bc9","deserializer":"TextBuffer"}],"deserializer":"Project"},"workspace":{"paneContainer":{"root":{"items":[{"id":69,"softTabs":true,"displayBuffer":{"id":70,"softWrap":false,"editorWidthInChars":153,"scrollTop":2606,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/zk/napplelabs/atom/src/tokenized-buffer.coffee","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":155,"softTabs":true,"displayBuffer":{"id":156,"softWrap":false,"editorWidthInChars":153,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/zk/napplelabs/atom/src/editor-view.coffee","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":159,"softTabs":true,"displayBuffer":{"id":160,"softWrap":false,"editorWidthInChars":153,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/zk/napplelabs/atom/src/space-pen-extensions.coffee","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":215,"softTabs":true,"displayBuffer":{"id":216,"softWrap":false,"editorWidthInChars":148,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/zk/napplelabs/atom/src/package.coffee","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":65,"softTabs":true,"displayBuffer":{"id":66,"softWrap":false,"editorWidthInChars":153,"scrollTop":5773,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/zk/napplelabs/atom/src/display-buffer.coffee","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":61,"softTabs":true,"displayBuffer":{"id":62,"softWrap":false,"editorWidthInChars":153,"scrollTop":4677,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/zk/napplelabs/atom/src/language-mode.coffee","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":57,"softTabs":true,"displayBuffer":{"id":58,"softWrap":false,"editorWidthInChars":153,"scrollTop":9313,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/zk/napplelabs/atom/src/selection.coffee","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":53,"softTabs":true,"displayBuffer":{"id":54,"softWrap":false,"editorWidthInChars":153,"scrollTop":7415,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/zk/napplelabs/atom/src/editor.coffee","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":41,"softTabs":true,"displayBuffer":{"id":42,"softWrap":false,"editorWidthInChars":153,"scrollTop":3171,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/zk/napplelabs/atom/src/editor-component.coffee","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"}],"activeItemUri":"/Users/zk/napplelabs/atom/src/tokenized-buffer.coffee","focused":false,"active":true,"deserializer":"Pane"},"deserializer":"PaneContainer"},"fullScreen":false,"deserializer":"Workspace"},"packageStates":{"find-and-replace":{"viewState":{"findHistory":["auto-indent","autoIndentSelectedRows","autoIndentBufferRow","suggestedIndentForBufferRow","indentLevelForLine"],"replaceHistory":[],"modelState":{"useRegex":false,"inCurrentSelection":false,"caseSensitive":false}},"projectViewState":{"findHistory":["auto indent","editor:auto-indent","autoIndentSelectedRows","autoIndentBufferRows","increaseIndentPattern","increaseIndentRegexForScopes","indentationForBufferRow","indentLevelForLine","package","package root","package.*root","package.*path","property.*of object.*is not a function","is not a function"],"replaceHistory":[],"pathsHistory":[],"modelState":{"useRegex":true,"caseSensitive":false}},"resultsModelState":{"useRegex":true,"caseSensitive":false}},"fuzzy-finder":{"/Users/zk/napplelabs/atom/src/tokenized-buffer.coffee":1399488286447,"/Users/zk/napplelabs/atom/src/editor-view.coffee":1399488251860,"/Users/zk/napplelabs/atom/src/space-pen-extensions.coffee":1399488252770,"/Users/zk/napplelabs/atom/src/package.coffee":1399488253214,"/Users/zk/napplelabs/atom/src/display-buffer.coffee":1399488253843,"/Users/zk/napplelabs/atom/src/language-mode.coffee":1399488255951,"/Users/zk/napplelabs/atom/src/selection.coffee":1399433077241,"/Users/zk/napplelabs/atom/src/editor.coffee":1399434429291,"/Users/zk/napplelabs/atom/src/editor-component.coffee":1399433038923},"keybinding-resolver":{"attached":false},"metrics":{"sessionLength":48703659},"tree-view":{"directoryExpansionStates":{"vendor":{}},"selectedPath":"/Users/zk/napplelabs/atom/src","hasFocus":false,"attached":true,"scrollLeft":0,"scrollTop":0,"width":200}}}